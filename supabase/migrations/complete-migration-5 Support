-- ============================================
-- FINOTAUR SUPPORT SYSTEM - COMPLETE SETUP v2.0
-- ××¢×¨×›×ª ×ª××™×›×” + ×¢×“×›×•× ×™× + ××¢×§×‘ ××©×ª××©×™× ×©×¢×–×‘×•
-- Fixed for Finotaur schema (account_type, top_secret_enabled, etc.)
-- ============================================

-- ============================================
-- PART 0: SUPPORT TICKETS TABLE + RLS
-- ×˜×‘×œ×ª ×˜×™×§×˜×™× ×œ×ª××™×›×”
-- ============================================

DO $$
BEGIN
  RAISE NOTICE '';
  RAISE NOTICE 'â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—';
  RAISE NOTICE 'â•‘  ğŸ« SETTING UP SUPPORT TICKETS TABLE                    â•‘';
  RAISE NOTICE 'â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•';
  RAISE NOTICE '';
END $$;

-- Create support_tickets table if not exists
CREATE TABLE IF NOT EXISTS support_tickets (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES auth.users(id) ON DELETE SET NULL,
  user_email TEXT NOT NULL,
  user_name TEXT,
  subject TEXT,
  message TEXT,
  messages JSONB DEFAULT '[]'::jsonb,
  category TEXT CHECK (category IN ('technical', 'payment', 'question', 'feedback')),
  status TEXT DEFAULT 'open' CHECK (status IN ('open', 'pending', 'resolved', 'closed')),
  priority TEXT DEFAULT 'normal' CHECK (priority IN ('low', 'normal', 'high', 'urgent')),
  assigned_to UUID REFERENCES auth.users(id) ON DELETE SET NULL,
  message_count INTEGER DEFAULT 1,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Add category column if it doesn't exist
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns 
    WHERE table_name = 'support_tickets' AND column_name = 'category'
  ) THEN
    ALTER TABLE support_tickets ADD COLUMN category TEXT CHECK (category IN ('technical', 'payment', 'question', 'feedback'));
  END IF;
END $$;

-- Enable RLS
ALTER TABLE support_tickets ENABLE ROW LEVEL SECURITY;

-- Drop existing policies if they exist
DROP POLICY IF EXISTS "Users can create tickets" ON support_tickets;
DROP POLICY IF EXISTS "Users can view own tickets" ON support_tickets;
DROP POLICY IF EXISTS "Users can update own tickets" ON support_tickets;
DROP POLICY IF EXISTS "Admins can manage all tickets" ON support_tickets;
DROP POLICY IF EXISTS "Allow anonymous ticket creation" ON support_tickets;

-- Users can create their own tickets (authenticated)
CREATE POLICY "Users can create tickets"
  ON support_tickets
  FOR INSERT
  TO authenticated
  WITH CHECK (
    user_id = auth.uid() 
    OR user_id IS NULL
  );

-- Allow anonymous/guest ticket creation
CREATE POLICY "Allow anonymous ticket creation"
  ON support_tickets
  FOR INSERT
  TO anon
  WITH CHECK (user_id IS NULL);

-- Users can view their own tickets
CREATE POLICY "Users can view own tickets"
  ON support_tickets
  FOR SELECT
  TO authenticated
  USING (user_id = auth.uid());

-- Users can update their own tickets
CREATE POLICY "Users can update own tickets"
  ON support_tickets
  FOR UPDATE
  TO authenticated
  USING (user_id = auth.uid());

-- Admins can do everything
CREATE POLICY "Admins can manage all tickets"
  ON support_tickets
  FOR ALL
  TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM profiles
      WHERE profiles.id = auth.uid()
      AND profiles.role IN ('admin', 'super_admin')
    )
  );

-- Indexes for support_tickets
CREATE INDEX IF NOT EXISTS idx_support_tickets_user_id ON support_tickets(user_id);
CREATE INDEX IF NOT EXISTS idx_support_tickets_status ON support_tickets(status);
CREATE INDEX IF NOT EXISTS idx_support_tickets_category ON support_tickets(category);
CREATE INDEX IF NOT EXISTS idx_support_tickets_created_at ON support_tickets(created_at DESC);
CREATE INDEX IF NOT EXISTS idx_support_tickets_updated_at ON support_tickets(updated_at DESC);

DO $$
BEGIN
  RAISE NOTICE 'âœ… support_tickets table configured with RLS';
END $$;

-- ============================================
-- PART 1: CREATE SYSTEM_UPDATES TABLE
-- ×˜×‘×œ×” ×œ×”×•×“×¢×•×ª ××¢×¨×›×ª ×•×¢×“×›×•× ×™× ×œ××©×ª××©×™×
-- ============================================

DO $$
BEGIN
  RAISE NOTICE '';
  RAISE NOTICE 'â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—';
  RAISE NOTICE 'â•‘  ğŸ“¢ CREATING SYSTEM UPDATES TABLE                       â•‘';
  RAISE NOTICE 'â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•';
  RAISE NOTICE '';
END $$;

CREATE TABLE IF NOT EXISTS system_updates (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  title TEXT NOT NULL,
  content TEXT NOT NULL,
  type TEXT DEFAULT 'info' CHECK (type IN ('info', 'warning', 'success', 'error', 'feature', 'maintenance', 'announcement')),
  target_group TEXT DEFAULT 'all' CHECK (target_group IN ('all', 'trading_journal', 'newsletter', 'top_secret')),
  is_active BOOLEAN DEFAULT true,
  is_pinned BOOLEAN DEFAULT false,
  priority INTEGER DEFAULT 0,
  metadata JSONB,
  starts_at TIMESTAMPTZ DEFAULT NOW(),
  expires_at TIMESTAMPTZ,
  views_count INTEGER DEFAULT 0,
  created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Add columns if they don't exist
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns 
    WHERE table_name = 'system_updates' AND column_name = 'is_pinned'
  ) THEN
    ALTER TABLE system_updates ADD COLUMN is_pinned BOOLEAN DEFAULT false;
  END IF;
  
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns 
    WHERE table_name = 'system_updates' AND column_name = 'metadata'
  ) THEN
    ALTER TABLE system_updates ADD COLUMN metadata JSONB;
  END IF;
  
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns 
    WHERE table_name = 'system_updates' AND column_name = 'views_count'
  ) THEN
    ALTER TABLE system_updates ADD COLUMN views_count INTEGER DEFAULT 0;
  END IF;
END $$;

-- Enable RLS
ALTER TABLE system_updates ENABLE ROW LEVEL SECURITY;

-- Drop existing policies if they exist
DROP POLICY IF EXISTS "Users can read updates for their group" ON system_updates;
DROP POLICY IF EXISTS "Admins can manage updates" ON system_updates;

-- Helper function to get user's group
CREATE OR REPLACE FUNCTION get_user_target_group(user_id UUID)
RETURNS TEXT AS $$
DECLARE
  user_group TEXT;
  is_top_secret BOOLEAN;
  is_newsletter BOOLEAN;
BEGIN
  SELECT 
    COALESCE(top_secret_enabled, false),
    COALESCE(newsletter_enabled, false) OR COALESCE(newsletter_paid, false)
  INTO is_top_secret, is_newsletter
  FROM profiles
  WHERE id = user_id;

  -- Priority: top_secret > newsletter > trading_journal
  IF is_top_secret THEN
    RETURN 'top_secret';
  ELSIF is_newsletter THEN
    RETURN 'newsletter';
  ELSE
    RETURN 'trading_journal';
  END IF;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Users can read active updates for their group
CREATE POLICY "Users can read updates for their group"
  ON system_updates
  FOR SELECT
  TO authenticated
  USING (
    is_active = true
    AND (starts_at IS NULL OR starts_at <= NOW())
    AND (expires_at IS NULL OR expires_at > NOW())
    AND (
      target_group = 'all'
      OR target_group = get_user_target_group(auth.uid())
      -- Admins can see all updates
      OR EXISTS (
        SELECT 1 FROM profiles
        WHERE profiles.id = auth.uid()
        AND profiles.role IN ('admin', 'super_admin')
      )
    )
  );

-- Admins can manage all updates
CREATE POLICY "Admins can manage updates"
  ON system_updates
  FOR ALL
  TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM profiles
      WHERE profiles.id = auth.uid()
      AND profiles.role IN ('admin', 'super_admin')
    )
  );

-- Indexes
CREATE INDEX IF NOT EXISTS idx_system_updates_active ON system_updates(is_active) WHERE is_active = true;
CREATE INDEX IF NOT EXISTS idx_system_updates_target_group ON system_updates(target_group);
CREATE INDEX IF NOT EXISTS idx_system_updates_dates ON system_updates(starts_at, expires_at);
CREATE INDEX IF NOT EXISTS idx_system_updates_priority ON system_updates(priority DESC);
CREATE INDEX IF NOT EXISTS idx_system_updates_pinned ON system_updates(is_pinned DESC);
CREATE INDEX IF NOT EXISTS idx_system_updates_created_at ON system_updates(created_at DESC);

DO $$
BEGIN
  RAISE NOTICE 'âœ… system_updates table created with RLS';
END $$;

-- ============================================
-- PART 2: CREATE USER_UPDATE_READS TABLE
-- ××¢×§×‘ ××™×œ×• ×¢×“×›×•× ×™× ×›×œ ××©×ª××© ×§×¨×
-- ============================================

DO $$
BEGIN
  RAISE NOTICE '';
  RAISE NOTICE 'â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—';
  RAISE NOTICE 'â•‘  ğŸ‘ï¸ CREATING USER UPDATE READS TABLE                    â•‘';
  RAISE NOTICE 'â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•';
  RAISE NOTICE '';
END $$;

CREATE TABLE IF NOT EXISTS user_update_reads (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  update_id UUID NOT NULL REFERENCES system_updates(id) ON DELETE CASCADE,
  read_at TIMESTAMPTZ DEFAULT NOW(),
  UNIQUE(user_id, update_id)
);

-- Enable RLS
ALTER TABLE user_update_reads ENABLE ROW LEVEL SECURITY;

-- Drop existing policies if they exist
DROP POLICY IF EXISTS "Users can view own reads" ON user_update_reads;
DROP POLICY IF EXISTS "Users can mark as read" ON user_update_reads;

-- Users can see their own reads
CREATE POLICY "Users can view own reads"
  ON user_update_reads
  FOR SELECT
  TO authenticated
  USING (user_id = auth.uid());

-- Users can mark as read
CREATE POLICY "Users can mark as read"
  ON user_update_reads
  FOR INSERT
  TO authenticated
  WITH CHECK (user_id = auth.uid());

-- Index
CREATE INDEX IF NOT EXISTS idx_user_update_reads_user ON user_update_reads(user_id);
CREATE INDEX IF NOT EXISTS idx_user_update_reads_update ON user_update_reads(update_id);

DO $$
BEGIN
  RAISE NOTICE 'âœ… user_update_reads table created';
END $$;

-- ============================================
-- PART 3: CREATE CHURNED_USERS TABLE
-- ××¢×§×‘ ××©×ª××©×™× ×©×‘×™×˜×œ×•/×¢×–×‘×•
-- ============================================

DO $$
BEGIN
  RAISE NOTICE '';
  RAISE NOTICE 'â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—';
  RAISE NOTICE 'â•‘  ğŸ‘‹ CREATING CHURNED USERS TABLE                        â•‘';
  RAISE NOTICE 'â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•';
  RAISE NOTICE '';
END $$;

CREATE TABLE IF NOT EXISTS churned_users (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES auth.users(id) ON DELETE SET NULL,
  email TEXT NOT NULL,
  display_name TEXT,
  account_type TEXT,
  user_group TEXT,
  churned_at TIMESTAMPTZ DEFAULT NOW(),
  reason TEXT,
  last_subscription_end TIMESTAMPTZ,
  total_paid DECIMAL(10,2) DEFAULT 0,
  notes TEXT,
  had_top_secret BOOLEAN DEFAULT false,
  had_newsletter BOOLEAN DEFAULT false,
  cancellation_reason TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Enable RLS
ALTER TABLE churned_users ENABLE ROW LEVEL SECURITY;

-- Drop existing policies if they exist
DROP POLICY IF EXISTS "Admins can view churned users" ON churned_users;
DROP POLICY IF EXISTS "Admins can manage churned users" ON churned_users;

-- Only admins can view churned users
CREATE POLICY "Admins can view churned users"
  ON churned_users
  FOR SELECT
  TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM profiles
      WHERE profiles.id = auth.uid()
      AND profiles.role IN ('admin', 'super_admin')
    )
  );

-- Only admins can manage churned users
CREATE POLICY "Admins can manage churned users"
  ON churned_users
  FOR ALL
  TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM profiles
      WHERE profiles.id = auth.uid()
      AND profiles.role IN ('admin', 'super_admin')
    )
  );

-- Indexes for faster queries
CREATE INDEX IF NOT EXISTS idx_churned_users_email ON churned_users(email);
CREATE INDEX IF NOT EXISTS idx_churned_users_churned_at ON churned_users(churned_at DESC);
CREATE INDEX IF NOT EXISTS idx_churned_users_group ON churned_users(user_group);
CREATE INDEX IF NOT EXISTS idx_churned_users_reason ON churned_users(reason);

DO $$
BEGIN
  RAISE NOTICE 'âœ… churned_users table created with RLS';
END $$;

-- ============================================
-- PART 4: TRIGGER TO AUTO-LOG CHURNED USERS
-- ×›×©×¡×˜×˜×•×¡ ×× ×•×™ ××©×ª× ×” ×œ×‘×™×˜×•×œ/×¤×’ ×ª×•×§×£
-- ============================================

DO $$
BEGIN
  RAISE NOTICE '';
  RAISE NOTICE 'â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—';
  RAISE NOTICE 'â•‘  âš¡ CREATING AUTO-CHURN TRIGGER                         â•‘';
  RAISE NOTICE 'â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•';
  RAISE NOTICE '';
END $$;

CREATE OR REPLACE FUNCTION log_churned_user()
RETURNS TRIGGER AS $$
BEGIN
  -- If subscription changed from active to cancelled/expired
  IF (OLD.subscription_status IS DISTINCT FROM NEW.subscription_status)
     AND OLD.subscription_status IN ('active', 'trialing') 
     AND NEW.subscription_status IN ('canceled', 'cancelled', 'expired', 'unpaid') THEN
    
    -- Check if not already logged recently
    IF NOT EXISTS (
      SELECT 1 FROM churned_users 
      WHERE user_id = NEW.id 
      AND churned_at > NOW() - INTERVAL '1 day'
    ) THEN
      INSERT INTO churned_users (
        user_id,
        email,
        display_name,
        account_type,
        user_group,
        reason,
        last_subscription_end,
        had_top_secret,
        had_newsletter,
        cancellation_reason
      ) VALUES (
        NEW.id,
        COALESCE(NEW.email, ''),
        NEW.display_name,
        OLD.account_type,
        CASE 
          WHEN OLD.top_secret_enabled THEN 'top_secret'
          WHEN OLD.newsletter_enabled OR OLD.newsletter_paid THEN 'newsletter'
          ELSE 'trading_journal'
        END,
        NEW.subscription_status,
        NEW.subscription_expires_at,
        COALESCE(OLD.top_secret_enabled, false),
        COALESCE(OLD.newsletter_enabled, false) OR COALESCE(OLD.newsletter_paid, false),
        NEW.cancellation_reason
      );
      
      RAISE LOG 'Churned user logged: % (%)', NEW.email, NEW.subscription_status;
    END IF;
  END IF;
  
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Create trigger (drop first if exists)
DROP TRIGGER IF EXISTS trigger_log_churned_user ON profiles;
CREATE TRIGGER trigger_log_churned_user
  AFTER UPDATE ON profiles
  FOR EACH ROW
  EXECUTE FUNCTION log_churned_user();

DO $$
BEGIN
  RAISE NOTICE 'âœ… Auto-churn trigger created on profiles';
END $$;

-- ============================================
-- PART 5: HELPER FUNCTIONS
-- ============================================

DO $$
BEGIN
  RAISE NOTICE '';
  RAISE NOTICE 'â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—';
  RAISE NOTICE 'â•‘  ğŸ“Š CREATING HELPER FUNCTIONS                           â•‘';
  RAISE NOTICE 'â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•';
  RAISE NOTICE '';
END $$;

-- Function: Get user counts per group
CREATE OR REPLACE FUNCTION get_user_group_counts()
RETURNS TABLE (
  group_name TEXT,
  user_count BIGINT
) AS $$
BEGIN
  RETURN QUERY
  SELECT 'all'::TEXT, COUNT(*)::BIGINT 
  FROM profiles 
  WHERE role NOT IN ('admin', 'super_admin')
  
  UNION ALL
  
  SELECT 'trading_journal'::TEXT, COUNT(*)::BIGINT 
  FROM profiles 
  WHERE COALESCE(top_secret_enabled, false) = false
    AND COALESCE(newsletter_enabled, false) = false
    AND COALESCE(newsletter_paid, false) = false
    AND role NOT IN ('admin', 'super_admin')
  
  UNION ALL
  
  SELECT 'newsletter'::TEXT, COUNT(*)::BIGINT 
  FROM profiles 
  WHERE (COALESCE(newsletter_enabled, false) = true OR COALESCE(newsletter_paid, false) = true)
    AND role NOT IN ('admin', 'super_admin')
  
  UNION ALL
  
  SELECT 'top_secret'::TEXT, COUNT(*)::BIGINT 
  FROM profiles 
  WHERE COALESCE(top_secret_enabled, false) = true
    AND role NOT IN ('admin', 'super_admin');
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function: Get unread updates count for current user
CREATE OR REPLACE FUNCTION get_unread_updates_count()
RETURNS INTEGER AS $$
DECLARE
  user_group TEXT;
  unread_count INTEGER;
BEGIN
  user_group := get_user_target_group(auth.uid());

  SELECT COUNT(*)::INTEGER INTO unread_count
  FROM system_updates su
  WHERE su.is_active = true
    AND (su.starts_at IS NULL OR su.starts_at <= NOW())
    AND (su.expires_at IS NULL OR su.expires_at > NOW())
    AND (su.target_group = 'all' OR su.target_group = user_group)
    AND NOT EXISTS (
      SELECT 1 FROM user_update_reads ur
      WHERE ur.update_id = su.id AND ur.user_id = auth.uid()
    );

  RETURN unread_count;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function: Mark update as read
CREATE OR REPLACE FUNCTION mark_update_as_read(p_update_id UUID)
RETURNS BOOLEAN AS $$
BEGIN
  INSERT INTO user_update_reads (user_id, update_id)
  VALUES (auth.uid(), p_update_id)
  ON CONFLICT (user_id, update_id) DO NOTHING;
  
  RETURN true;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function: Increment update views
CREATE OR REPLACE FUNCTION increment_update_views(update_id UUID)
RETURNS VOID AS $$
BEGIN
  UPDATE system_updates 
  SET views_count = COALESCE(views_count, 0) + 1
  WHERE id = update_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function: Get churn statistics
CREATE OR REPLACE FUNCTION get_churn_stats(p_days INTEGER DEFAULT 30)
RETURNS TABLE (
  total_churned BIGINT,
  trading_journal_churned BIGINT,
  newsletter_churned BIGINT,
  top_secret_churned BIGINT
) AS $$
BEGIN
  RETURN QUERY
  SELECT 
    COUNT(*)::BIGINT,
    COUNT(*) FILTER (WHERE user_group = 'trading_journal')::BIGINT,
    COUNT(*) FILTER (WHERE user_group = 'newsletter')::BIGINT,
    COUNT(*) FILTER (WHERE user_group = 'top_secret')::BIGINT
  FROM churned_users
  WHERE churned_at > NOW() - (p_days || ' days')::INTERVAL;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function: Get detailed user stats for admin
CREATE OR REPLACE FUNCTION get_admin_user_stats()
RETURNS TABLE (
  total_users BIGINT,
  free_users BIGINT,
  basic_users BIGINT,
  premium_users BIGINT,
  newsletter_users BIGINT,
  top_secret_users BIGINT,
  active_subscriptions BIGINT,
  trialing_users BIGINT,
  lifetime_users BIGINT
) AS $$
BEGIN
  RETURN QUERY
  SELECT 
    COUNT(*)::BIGINT,
    COUNT(*) FILTER (WHERE account_type = 'FREE')::BIGINT,
    COUNT(*) FILTER (WHERE account_type = 'BASIC')::BIGINT,
    COUNT(*) FILTER (WHERE account_type = 'PREMIUM')::BIGINT,
    COUNT(*) FILTER (WHERE newsletter_enabled = true OR newsletter_paid = true)::BIGINT,
    COUNT(*) FILTER (WHERE top_secret_enabled = true)::BIGINT,
    COUNT(*) FILTER (WHERE subscription_status = 'active')::BIGINT,
    COUNT(*) FILTER (WHERE subscription_status = 'trialing' OR is_in_trial = true)::BIGINT,
    COUNT(*) FILTER (WHERE is_lifetime = true)::BIGINT
  FROM profiles
  WHERE role NOT IN ('admin', 'super_admin');
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function: Get support ticket statistics
CREATE OR REPLACE FUNCTION get_support_stats(p_days INTEGER DEFAULT 30)
RETURNS TABLE (
  total_tickets BIGINT,
  open_tickets BIGINT,
  resolved_tickets BIGINT,
  technical_tickets BIGINT,
  payment_tickets BIGINT,
  question_tickets BIGINT,
  feedback_tickets BIGINT,
  avg_response_time_hours NUMERIC
) AS $$
BEGIN
  RETURN QUERY
  SELECT 
    COUNT(*)::BIGINT,
    COUNT(*) FILTER (WHERE status = 'open')::BIGINT,
    COUNT(*) FILTER (WHERE status = 'resolved')::BIGINT,
    COUNT(*) FILTER (WHERE category = 'technical')::BIGINT,
    COUNT(*) FILTER (WHERE category = 'payment')::BIGINT,
    COUNT(*) FILTER (WHERE category = 'question')::BIGINT,
    COUNT(*) FILTER (WHERE category = 'feedback')::BIGINT,
    ROUND(AVG(EXTRACT(EPOCH FROM (updated_at - created_at)) / 3600)::NUMERIC, 2)
  FROM support_tickets
  WHERE created_at > NOW() - (p_days || ' days')::INTERVAL;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

DO $$
BEGIN
  RAISE NOTICE 'âœ… Helper functions created:';
  RAISE NOTICE '   â€¢ get_user_target_group(user_id)';
  RAISE NOTICE '   â€¢ get_user_group_counts()';
  RAISE NOTICE '   â€¢ get_unread_updates_count()';
  RAISE NOTICE '   â€¢ mark_update_as_read(update_id)';
  RAISE NOTICE '   â€¢ increment_update_views(update_id)';
  RAISE NOTICE '   â€¢ get_churn_stats(days)';
  RAISE NOTICE '   â€¢ get_admin_user_stats()';
  RAISE NOTICE '   â€¢ get_support_stats(days)';
END $$;

-- ============================================
-- PART 6: ADD INDEXES FOR FASTER QUERIES
-- ============================================

CREATE INDEX IF NOT EXISTS idx_profiles_account_type ON profiles(account_type);
CREATE INDEX IF NOT EXISTS idx_profiles_top_secret ON profiles(top_secret_enabled) WHERE top_secret_enabled = true;
CREATE INDEX IF NOT EXISTS idx_profiles_newsletter ON profiles(newsletter_enabled) WHERE newsletter_enabled = true;
CREATE INDEX IF NOT EXISTS idx_profiles_subscription_status ON profiles(subscription_status);

-- ============================================
-- PART 7: ENABLE REALTIME (Optional)
-- ============================================

DO $$
BEGIN
  ALTER PUBLICATION supabase_realtime ADD TABLE system_updates;
  RAISE NOTICE 'âœ… Realtime enabled for system_updates';
EXCEPTION
  WHEN duplicate_object THEN
    RAISE NOTICE 'â­ï¸ Realtime already enabled for system_updates';
END $$;

DO $$
BEGIN
  ALTER PUBLICATION supabase_realtime ADD TABLE support_tickets;
  RAISE NOTICE 'âœ… Realtime enabled for support_tickets';
EXCEPTION
  WHEN duplicate_object THEN
    RAISE NOTICE 'â­ï¸ Realtime already enabled for support_tickets';
END $$;

-- ============================================
-- VERIFICATION & SUMMARY
-- ============================================

DO $$
BEGIN
  RAISE NOTICE '';
  RAISE NOTICE 'â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—';
  RAISE NOTICE 'â•‘  âœ… SETUP COMPLETE                                      â•‘';
  RAISE NOTICE 'â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•';
  RAISE NOTICE '';
  RAISE NOTICE 'ğŸ“‹ Tables Created/Updated:';
  RAISE NOTICE '';
  RAISE NOTICE '  0ï¸âƒ£  support_tickets';
  RAISE NOTICE '      â€¢ ×˜×™×§×˜×™× ×œ×ª××™×›×”';
  RAISE NOTICE '      â€¢ ×§×˜×’×•×¨×™×•×ª: technical, payment, question, feedback';
  RAISE NOTICE '      â€¢ ×¡×˜×˜×•×¡×™×: open, pending, resolved, closed';
  RAISE NOTICE '';
  RAISE NOTICE '  1ï¸âƒ£  system_updates';
  RAISE NOTICE '      â€¢ ×”×•×“×¢×•×ª ××¢×¨×›×ª ×•×¢×“×›×•× ×™×';
  RAISE NOTICE '      â€¢ ×¡×™× ×•×Ÿ ×œ×¤×™ ×§×‘×•×¦×ª ×™×¢×“';
  RAISE NOTICE '      â€¢ ×ª××™×›×” ×‘×ª×–××•×Ÿ (starts_at, expires_at)';
  RAISE NOTICE '      â€¢ ×ª××™×›×” ×‘-metadata (PDF, PMI, etc.)';
  RAISE NOTICE '';
  RAISE NOTICE '  2ï¸âƒ£  user_update_reads';
  RAISE NOTICE '      â€¢ ××¢×§×‘ ××™×œ×• ×¢×“×›×•× ×™× × ×§×¨××•';
  RAISE NOTICE '';
  RAISE NOTICE '  3ï¸âƒ£  churned_users';
  RAISE NOTICE '      â€¢ ××¢×§×‘ ××©×ª××©×™× ×©×¢×–×‘×•';
  RAISE NOTICE '      â€¢ ×œ×•×’ ××•×˜×•××˜×™ ×“×¨×š trigger';
  RAISE NOTICE '';
  RAISE NOTICE 'ğŸ¯ Target Groups:';
  RAISE NOTICE '  â€¢ all - ×›×•×œ×';
  RAISE NOTICE '  â€¢ trading_journal - ××©×ª××©×™ ×™×•××Ÿ ××¡×—×¨';
  RAISE NOTICE '  â€¢ newsletter - ×× ×•×™×™ × ×™×•×–×œ×˜×¨';
  RAISE NOTICE '  â€¢ top_secret - ×× ×•×™×™ TOP SECRET';
  RAISE NOTICE '';
  RAISE NOTICE 'ğŸ“ Ticket Categories:';
  RAISE NOTICE '  â€¢ technical - ×‘×¢×™×” ×˜×›× ×™×ª';
  RAISE NOTICE '  â€¢ payment - ×‘×¢×™×™×ª ×ª×©×œ×•×';
  RAISE NOTICE '  â€¢ question - ×©××œ×”';
  RAISE NOTICE '  â€¢ feedback - ×”××œ×¦×•×ª ×œ×©×™×¤×•×¨';
  RAISE NOTICE '';
END $$;

-- ============================================
-- TEST QUERIES
-- ============================================

-- Show user group counts
SELECT * FROM get_user_group_counts();

-- Show admin stats
SELECT * FROM get_admin_user_stats();

-- Show support stats
SELECT * FROM get_support_stats(30);

-- Show recent tickets by category
SELECT 
  category,
  COUNT(*) as count,
  COUNT(*) FILTER (WHERE status = 'open') as open_count
FROM support_tickets
WHERE created_at > NOW() - INTERVAL '30 days'
GROUP BY category;

-- ============================================
-- EXAMPLE USAGE
-- ============================================

-- Create a general update for everyone:
/*
INSERT INTO system_updates (title, content, type, target_group)
VALUES (
  'ğŸš€ ×¤×™×¦×³×¨ ×—×“×©!',
  '×”×•×¡×¤× ×• ××¤×©×¨×•×ª ×—×“×©×” ×œ××¢×§×‘ ×¢×¡×§××•×ª. ×›× ×¡×• ×œ×¨××•×ª!',
  'feature',
  'all'
);
*/

-- Create update with PDF metadata (for ISM reports):
/*
INSERT INTO system_updates (title, content, type, target_group, metadata)
VALUES (
  'ğŸ­ ISM Manufacturing Report - January 2025',
  'The latest ISM Manufacturing PMI report is now available.',
  'announcement',
  'top_secret',
  '{"report_type": "ism", "report_month": "January 2025", "pdf_url": "https://...", "pmi_value": 49.3, "pmi_change": -0.9}'::jsonb
);
*/