-- ============================================================================
-- FINOTAUR - Multi-Broker Integration Database Schema (UNIFIED)
-- Version: 3.2.0 - WITH SNAPTRADE INTEGRATION
-- ============================================================================
-- 
-- This migration intelligently handles:
-- ✅ Existing broker_connections table with 'broker' text column
-- ✅ Creates new tables only if they don't exist
-- ✅ Adds missing columns without breaking existing data
-- ✅ Fixes constraints to support all brokers
-- ✅ Safe to run multiple times (idempotent)
-- ✅ Optimized indexes for high-performance queries
-- ✅ Partial indexes to reduce index size
-- ✅ BRIN indexes for time-series data
-- ✅ SnapTrade integration (users, activity, trades columns)
--
-- ============================================================================

-- ============================================================================
-- STEP 0: FIX CRITICAL CONSTRAINTS ON TRADES TABLE FIRST
-- ============================================================================

-- Add 'tradovate' and all other brokers to broker constraint
ALTER TABLE trades DROP CONSTRAINT IF EXISTS trades_broker_check;
ALTER TABLE trades ADD CONSTRAINT trades_broker_check 
  CHECK (broker = ANY (ARRAY[
    'manual'::text, 
    'interactive_brokers'::text, 
    'td_ameritrade'::text, 
    'alpaca'::text, 
    'tradingview'::text, 
    'mt4'::text, 
    'mt5'::text, 
    'ninja_trader'::text,
    'tradovate'::text,
    'rithmic'::text,
    'topstepx'::text,
    'tradelocker'::text,
    'bybit'::text,
    'binance'::text,
    'schwab'::text,
    'robinhood'::text,
    'snaptrade'::text,
    'sierra_chart'::text,
    'dxtrade'::text,
    'colmexpro'::text
  ]));

-- Add 'tradovate' and other sources to import_source constraint
ALTER TABLE trades DROP CONSTRAINT IF EXISTS check_import_source;
ALTER TABLE trades ADD CONSTRAINT check_import_source 
  CHECK (import_source = ANY (ARRAY[
    'manual'::text, 
    'snaptrade'::text, 
    'csv'::text, 
    'api'::text,
    'tradovate'::text,
    'broker_sync'::text,
    'webhook'::text,
    'rithmic'::text,
    'ninja_trader'::text
  ]));

-- ============================================================================
-- STEP 1: BROKER DEFINITIONS - Master list of all supported brokers
-- ============================================================================

CREATE TABLE IF NOT EXISTS broker_definitions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    
    -- Basic Info
    name VARCHAR(100) NOT NULL,
    display_name VARCHAR(100) NOT NULL,
    slug VARCHAR(50) NOT NULL,
    description TEXT,
    logo_url TEXT,
    website_url TEXT,
    
    -- Broker Type & Category
    broker_type VARCHAR(50) NOT NULL DEFAULT 'broker',
    asset_classes TEXT[] DEFAULT ARRAY['futures'],
    
    -- Authentication Configuration
    auth_method VARCHAR(50) NOT NULL DEFAULT 'credentials',
    auth_config JSONB DEFAULT '{}',
    
    -- API Configuration
    api_config JSONB DEFAULT '{}',
    
    -- Features & Capabilities
    features JSONB DEFAULT '{}',
    
    -- Data Mapping Configuration
    data_mapping JSONB DEFAULT '{}',
    
    -- Status & Availability
    is_active BOOLEAN DEFAULT true,
    is_beta BOOLEAN DEFAULT false,
    requires_subscription VARCHAR(20) DEFAULT 'FREE',
    
    -- Regional Availability
    supported_regions TEXT[] DEFAULT ARRAY['US', 'EU', 'GLOBAL'],
    
    -- Timestamps
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Add unique constraints if they don't exist
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_constraint WHERE conname = 'broker_definitions_name_key') THEN
        ALTER TABLE broker_definitions ADD CONSTRAINT broker_definitions_name_key UNIQUE (name);
    END IF;
    IF NOT EXISTS (SELECT 1 FROM pg_constraint WHERE conname = 'broker_definitions_slug_key') THEN
        ALTER TABLE broker_definitions ADD CONSTRAINT broker_definitions_slug_key UNIQUE (slug);
    END IF;
END $$;

-- Optimized indexes for broker_definitions
CREATE INDEX IF NOT EXISTS idx_broker_definitions_slug ON broker_definitions(slug) WHERE is_active = true;
CREATE INDEX IF NOT EXISTS idx_broker_definitions_active ON broker_definitions(is_active) WHERE is_active = true;
CREATE INDEX IF NOT EXISTS idx_broker_definitions_type ON broker_definitions(broker_type) WHERE is_active = true;

-- ============================================================================
-- STEP 2: UPDATE EXISTING BROKER_CONNECTIONS TABLE
-- ============================================================================

-- Add broker_id reference to broker_definitions
ALTER TABLE broker_connections 
ADD COLUMN IF NOT EXISTS broker_id UUID REFERENCES broker_definitions(id) ON DELETE SET NULL;

-- Add connection identification
ALTER TABLE broker_connections 
ADD COLUMN IF NOT EXISTS connection_name VARCHAR(100);

-- Add environment
ALTER TABLE broker_connections 
ADD COLUMN IF NOT EXISTS environment VARCHAR(20) DEFAULT 'demo';

-- Add connection metadata
ALTER TABLE broker_connections 
ADD COLUMN IF NOT EXISTS connection_data JSONB DEFAULT '{}';

-- Add status management columns
ALTER TABLE broker_connections 
ADD COLUMN IF NOT EXISTS status_message TEXT;

ALTER TABLE broker_connections 
ADD COLUMN IF NOT EXISTS last_error TEXT;

ALTER TABLE broker_connections 
ADD COLUMN IF NOT EXISTS last_error_at TIMESTAMPTZ;

ALTER TABLE broker_connections 
ADD COLUMN IF NOT EXISTS error_count INTEGER DEFAULT 0;

-- Add sync configuration
ALTER TABLE broker_connections 
ADD COLUMN IF NOT EXISTS auto_sync_enabled BOOLEAN DEFAULT true;

ALTER TABLE broker_connections 
ADD COLUMN IF NOT EXISTS sync_interval_minutes INTEGER DEFAULT 15;

ALTER TABLE broker_connections 
ADD COLUMN IF NOT EXISTS last_successful_sync_at TIMESTAMPTZ;

-- Add activity tracking
ALTER TABLE broker_connections 
ADD COLUMN IF NOT EXISTS is_active BOOLEAN DEFAULT true;

ALTER TABLE broker_connections 
ADD COLUMN IF NOT EXISTS disconnected_at TIMESTAMPTZ;

-- Add encrypted credentials storage
ALTER TABLE broker_connections 
ADD COLUMN IF NOT EXISTS credentials_encrypted BYTEA;

ALTER TABLE broker_connections 
ADD COLUMN IF NOT EXISTS credentials_iv BYTEA;

-- Add token_expires_at
ALTER TABLE broker_connections 
ADD COLUMN IF NOT EXISTS token_expires_at TIMESTAMPTZ;

-- Optimized indexes for broker_connections
DROP INDEX IF EXISTS idx_broker_connections_user;
DROP INDEX IF EXISTS idx_broker_connections_broker;
DROP INDEX IF EXISTS idx_broker_connections_broker_id;
DROP INDEX IF EXISTS idx_broker_connections_status;
DROP INDEX IF EXISTS idx_broker_connections_active;
DROP INDEX IF EXISTS idx_broker_connections_environment;

-- Composite indexes for common query patterns
CREATE INDEX IF NOT EXISTS idx_bc_user_active ON broker_connections(user_id, is_active) WHERE is_active = true;
CREATE INDEX IF NOT EXISTS idx_bc_user_broker_env ON broker_connections(user_id, broker, environment) WHERE is_active = true;
CREATE INDEX IF NOT EXISTS idx_bc_status ON broker_connections(status) WHERE status IN ('connected', 'pending', 'error');
CREATE INDEX IF NOT EXISTS idx_bc_broker_id ON broker_connections(broker_id) WHERE broker_id IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_bc_last_sync ON broker_connections(last_sync_at DESC NULLS LAST) WHERE is_active = true;

-- ============================================================================
-- STEP 3: BROKER ACCOUNTS - Individual trading accounts within a connection
-- ============================================================================

CREATE TABLE IF NOT EXISTS broker_accounts (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    connection_id UUID NOT NULL REFERENCES broker_connections(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    
    -- Account Identification
    broker_account_id VARCHAR(100) NOT NULL,
    account_name VARCHAR(100),
    account_number VARCHAR(100),
    
    -- Account Type
    account_type VARCHAR(50) DEFAULT 'individual',
    account_subtype VARCHAR(50),
    
    -- Currency & Base Info
    base_currency VARCHAR(10) DEFAULT 'USD',
    timezone VARCHAR(50) DEFAULT 'America/New_York',
    
    -- Account Status from Broker
    broker_status VARCHAR(50),
    
    -- Balance Snapshot (updated on sync)
    balance_snapshot JSONB DEFAULT '{}',
    
    -- Account Metadata
    account_data JSONB DEFAULT '{}',
    
    -- Selection & Display
    is_primary BOOLEAN DEFAULT false,
    is_active BOOLEAN DEFAULT true,
    display_order INTEGER DEFAULT 0,
    
    -- Sync Status
    last_sync_at TIMESTAMPTZ,
    sync_status VARCHAR(30) DEFAULT 'pending',
    
    -- Timestamps
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Add unique constraint
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_constraint WHERE conname = 'broker_accounts_connection_id_broker_account_id_key') THEN
        ALTER TABLE broker_accounts ADD CONSTRAINT broker_accounts_connection_id_broker_account_id_key 
        UNIQUE(connection_id, broker_account_id);
    END IF;
END $$;

-- Optimized indexes for broker_accounts
CREATE INDEX IF NOT EXISTS idx_ba_connection_active ON broker_accounts(connection_id, is_active) WHERE is_active = true;
CREATE INDEX IF NOT EXISTS idx_ba_user_primary ON broker_accounts(user_id, is_primary) WHERE is_primary = true;
CREATE INDEX IF NOT EXISTS idx_ba_user_active ON broker_accounts(user_id) WHERE is_active = true;

-- ============================================================================
-- STEP 4: BROKER SYNC LOGS - Detailed logging of sync operations
-- ============================================================================

CREATE TABLE IF NOT EXISTS broker_sync_logs (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    connection_id UUID NOT NULL REFERENCES broker_connections(id) ON DELETE CASCADE,
    account_id UUID REFERENCES broker_accounts(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    
    -- Sync Operation Details
    sync_type VARCHAR(50) NOT NULL,
    sync_trigger VARCHAR(50) NOT NULL DEFAULT 'manual',
    
    -- Time Range Synced
    sync_from_date TIMESTAMPTZ,
    sync_to_date TIMESTAMPTZ,
    
    -- Results
    status VARCHAR(30) NOT NULL DEFAULT 'started',
    
    -- Counts
    records_fetched INTEGER DEFAULT 0,
    records_created INTEGER DEFAULT 0,
    records_updated INTEGER DEFAULT 0,
    records_skipped INTEGER DEFAULT 0,
    records_failed INTEGER DEFAULT 0,
    
    -- Details
    sync_details JSONB DEFAULT '{}',
    
    -- Error Information
    error_message TEXT,
    error_details JSONB,
    
    -- Timing
    started_at TIMESTAMPTZ DEFAULT NOW(),
    completed_at TIMESTAMPTZ,
    duration_ms INTEGER,
    
    -- Timestamps
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Optimized indexes for broker_sync_logs
-- BRIN index for time-series queries (much smaller than B-tree)
CREATE INDEX IF NOT EXISTS idx_bsl_created_brin ON broker_sync_logs USING BRIN(created_at) WITH (pages_per_range = 32);
CREATE INDEX IF NOT EXISTS idx_bsl_connection_status ON broker_sync_logs(connection_id, status) WHERE status IN ('started', 'in_progress', 'failed');
CREATE INDEX IF NOT EXISTS idx_bsl_user_recent ON broker_sync_logs(user_id, created_at DESC);
CREATE INDEX IF NOT EXISTS idx_bsl_account ON broker_sync_logs(account_id) WHERE account_id IS NOT NULL;

-- ============================================================================
-- STEP 5: BROKER RAW DATA - Store raw data from brokers for debugging/replay
-- ============================================================================

CREATE TABLE IF NOT EXISTS broker_raw_data (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    sync_log_id UUID REFERENCES broker_sync_logs(id) ON DELETE CASCADE,
    connection_id UUID NOT NULL REFERENCES broker_connections(id) ON DELETE CASCADE,
    
    -- Data Type
    data_type VARCHAR(50) NOT NULL,
    
    -- Raw Data
    broker_record_id VARCHAR(100),
    raw_data JSONB NOT NULL,
    
    -- Processing Status
    is_processed BOOLEAN DEFAULT false,
    processed_at TIMESTAMPTZ,
    processing_error TEXT,
    
    -- Link to Created Record
    created_trade_id UUID,
    
    -- Timestamps
    broker_timestamp TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Optimized indexes for broker_raw_data
CREATE INDEX IF NOT EXISTS idx_brd_connection_unprocessed ON broker_raw_data(connection_id, is_processed) WHERE is_processed = false;
CREATE INDEX IF NOT EXISTS idx_brd_broker_record ON broker_raw_data(broker_record_id) WHERE broker_record_id IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_brd_sync_log ON broker_raw_data(sync_log_id) WHERE sync_log_id IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_brd_created_brin ON broker_raw_data USING BRIN(created_at) WITH (pages_per_range = 32);

-- ============================================================================
-- STEP 6: ADD BROKER COLUMNS TO TRADES TABLE
-- ============================================================================

DO $$
BEGIN
    -- Broker Connection Reference
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns 
                   WHERE table_name = 'trades' AND column_name = 'broker_connection_id') THEN
        ALTER TABLE trades ADD COLUMN broker_connection_id UUID REFERENCES broker_connections(id) ON DELETE SET NULL;
    END IF;
    
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns 
                   WHERE table_name = 'trades' AND column_name = 'broker_account_id') THEN
        ALTER TABLE trades ADD COLUMN broker_account_id UUID REFERENCES broker_accounts(id) ON DELETE SET NULL;
    END IF;
    
    -- Broker Identification
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns 
                   WHERE table_name = 'trades' AND column_name = 'broker_name') THEN
        ALTER TABLE trades ADD COLUMN broker_name VARCHAR(50);
    END IF;
    
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns 
                   WHERE table_name = 'trades' AND column_name = 'broker_trade_id') THEN
        ALTER TABLE trades ADD COLUMN broker_trade_id VARCHAR(100);
    END IF;
    
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns 
                   WHERE table_name = 'trades' AND column_name = 'broker_order_id') THEN
        ALTER TABLE trades ADD COLUMN broker_order_id VARCHAR(100);
    END IF;
    
    -- Contract Information (for Futures)
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns 
                   WHERE table_name = 'trades' AND column_name = 'contract_id') THEN
        ALTER TABLE trades ADD COLUMN contract_id VARCHAR(100);
    END IF;
    
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns 
                   WHERE table_name = 'trades' AND column_name = 'contract_name') THEN
        ALTER TABLE trades ADD COLUMN contract_name VARCHAR(100);
    END IF;
    
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns 
                   WHERE table_name = 'trades' AND column_name = 'contract_month') THEN
        ALTER TABLE trades ADD COLUMN contract_month VARCHAR(20);
    END IF;
    
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns 
                   WHERE table_name = 'trades' AND column_name = 'underlying_symbol') THEN
        ALTER TABLE trades ADD COLUMN underlying_symbol VARCHAR(20);
    END IF;
    
    -- Instrument Details
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns 
                   WHERE table_name = 'trades' AND column_name = 'tick_size') THEN
        ALTER TABLE trades ADD COLUMN tick_size DECIMAL(18, 8);
    END IF;
    
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns 
                   WHERE table_name = 'trades' AND column_name = 'tick_value') THEN
        ALTER TABLE trades ADD COLUMN tick_value DECIMAL(18, 4);
    END IF;
    
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns 
                   WHERE table_name = 'trades' AND column_name = 'point_value') THEN
        ALTER TABLE trades ADD COLUMN point_value DECIMAL(18, 4);
    END IF;
    
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns 
                   WHERE table_name = 'trades' AND column_name = 'contract_multiplier') THEN
        ALTER TABLE trades ADD COLUMN contract_multiplier DECIMAL(18, 4) DEFAULT 1;
    END IF;
    
    -- Execution Details
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns 
                   WHERE table_name = 'trades' AND column_name = 'execution_id') THEN
        ALTER TABLE trades ADD COLUMN execution_id VARCHAR(100);
    END IF;
    
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns 
                   WHERE table_name = 'trades' AND column_name = 'order_type') THEN
        ALTER TABLE trades ADD COLUMN order_type VARCHAR(30);
    END IF;
    
    -- Sync Metadata
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns 
                   WHERE table_name = 'trades' AND column_name = 'synced_at') THEN
        ALTER TABLE trades ADD COLUMN synced_at TIMESTAMPTZ;
    END IF;
    
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns 
                   WHERE table_name = 'trades' AND column_name = 'sync_source') THEN
        ALTER TABLE trades ADD COLUMN sync_source VARCHAR(30);
    END IF;
    
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns 
                   WHERE table_name = 'trades' AND column_name = 'raw_data') THEN
        ALTER TABLE trades ADD COLUMN raw_data JSONB;
    END IF;
END $$;

-- Optimized indexes for broker columns on trades
-- Partial indexes to reduce size and improve performance
CREATE INDEX IF NOT EXISTS idx_trades_broker_conn ON trades(broker_connection_id) WHERE broker_connection_id IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_trades_broker_acc ON trades(broker_account_id) WHERE broker_account_id IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_trades_external_id ON trades(external_id) WHERE external_id IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_trades_broker_trade_id ON trades(broker_trade_id) WHERE broker_trade_id IS NOT NULL;

-- Composite index for duplicate checking (most common query during sync)
CREATE INDEX IF NOT EXISTS idx_trades_dedup ON trades(user_id, broker, external_id) WHERE external_id IS NOT NULL;

-- ============================================================================
-- STEP 7: INSTRUMENT DEFINITIONS - Master list of tradeable instruments
-- ============================================================================

CREATE TABLE IF NOT EXISTS instrument_definitions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    
    -- Identification
    symbol VARCHAR(50) NOT NULL,
    name VARCHAR(200),
    description TEXT,
    
    -- Classification
    asset_class VARCHAR(30) NOT NULL,
    instrument_type VARCHAR(50),
    
    -- Exchange & Product
    exchange VARCHAR(50),
    exchange_symbol VARCHAR(50),
    product_code VARCHAR(20),
    
    -- Contract Specifications
    tick_size DECIMAL(18, 8),
    tick_value DECIMAL(18, 4),
    point_value DECIMAL(18, 4),
    contract_size DECIMAL(18, 4),
    
    -- Currency
    currency VARCHAR(10) DEFAULT 'USD',
    quote_currency VARCHAR(10),
    
    -- Trading Hours
    trading_hours JSONB,
    
    -- Margin Requirements
    margin_requirements JSONB,
    
    -- Status
    is_active BOOLEAN DEFAULT true,
    is_tradeable BOOLEAN DEFAULT true,
    
    -- Timestamps
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Add unique constraint
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_constraint WHERE conname = 'instrument_definitions_symbol_exchange_key') THEN
        ALTER TABLE instrument_definitions ADD CONSTRAINT instrument_definitions_symbol_exchange_key 
        UNIQUE(symbol, exchange);
    END IF;
END $$;

-- Optimized indexes for instrument_definitions
CREATE INDEX IF NOT EXISTS idx_inst_symbol_active ON instrument_definitions(symbol) WHERE is_active = true;
CREATE INDEX IF NOT EXISTS idx_inst_asset_class ON instrument_definitions(asset_class) WHERE is_active = true;
CREATE INDEX IF NOT EXISTS idx_inst_exchange ON instrument_definitions(exchange) WHERE is_active = true;

-- ============================================================================
-- STEP 8: SEED DATA - Pre-populate broker definitions
-- ============================================================================

INSERT INTO broker_definitions (
    name, display_name, slug, description, broker_type, asset_classes,
    auth_method, auth_config, api_config, features, is_active, is_beta
) VALUES 
-- Tradovate
(
    'Tradovate',
    'Tradovate',
    'tradovate',
    'Commission-free futures trading platform',
    'broker',
    ARRAY['futures'],
    'credentials',
    '{
        "fields": ["username", "password", "device_id"],
        "optional_fields": ["cid", "sec"],
        "supports_mfa": true
    }'::jsonb,
    '{
        "demo_api_url": "https://demo.tradovateapi.com/v1",
        "live_api_url": "https://live.tradovateapi.com/v1",
        "demo_ws_url": "wss://demo.tradovateapi.com/v1/websocket",
        "live_ws_url": "wss://live.tradovateapi.com/v1/websocket",
        "rate_limit": 120,
        "rate_limit_window": 60
    }'::jsonb,
    '{
        "realtime_sync": true,
        "historical_sync": true,
        "positions": true,
        "orders": true,
        "account_balance": true,
        "margin_info": true,
        "trade_execution": false
    }'::jsonb,
    true,
    false
),

-- NinjaTrader
(
    'NinjaTrader',
    'NinjaTrader',
    'ninjatrader',
    'Advanced charting and trading platform for futures',
    'platform',
    ARRAY['futures'],
    'credentials',
    '{
        "fields": ["username", "password"],
        "connection_type": "rithmic"
    }'::jsonb,
    '{
        "connection_types": ["rithmic", "continuum"],
        "supports_demo": true
    }'::jsonb,
    '{
        "realtime_sync": true,
        "historical_sync": true,
        "positions": true,
        "orders": true,
        "account_balance": true,
        "margin_info": true
    }'::jsonb,
    true,
    true
),

-- Interactive Brokers
(
    'Interactive Brokers',
    'Interactive Brokers (IBKR)',
    'interactive-brokers',
    'Global electronic brokerage firm',
    'broker',
    ARRAY['stocks', 'options', 'futures', 'forex', 'crypto'],
    'oauth2',
    '{
        "oauth_url": "https://www.interactivebrokers.com/oauth",
        "client_portal_url": "https://localhost:5000",
        "gateway_required": true
    }'::jsonb,
    '{
        "api_type": "client_portal",
        "websocket_url": "wss://localhost:5000/v1/api/ws"
    }'::jsonb,
    '{
        "realtime_sync": true,
        "historical_sync": true,
        "positions": true,
        "orders": true,
        "account_balance": true,
        "margin_info": true,
        "trade_execution": true
    }'::jsonb,
    true,
    true
),

-- Rithmic
(
    'Rithmic',
    'Rithmic',
    'rithmic',
    'Professional trading infrastructure for futures',
    'data_provider',
    ARRAY['futures'],
    'credentials',
    '{
        "fields": ["username", "password", "server"],
        "servers": ["Rithmic Paper Trading", "Rithmic 01", "Rithmic 04"]
    }'::jsonb,
    '{
        "protocol": "rithmic_protocol_buffer"
    }'::jsonb,
    '{
        "realtime_sync": true,
        "historical_sync": true,
        "positions": true,
        "orders": true,
        "account_balance": true,
        "margin_info": true
    }'::jsonb,
    true,
    true
),

-- TopstepX
(
    'TopstepX',
    'TopstepX',
    'topstepx',
    'Funded trader program using Tradovate infrastructure',
    'prop_firm',
    ARRAY['futures'],
    'credentials',
    '{
        "fields": ["username", "password"],
        "uses_tradovate_api": true
    }'::jsonb,
    '{
        "base_broker": "tradovate",
        "api_url": "https://api.topstepx.com"
    }'::jsonb,
    '{
        "realtime_sync": true,
        "historical_sync": true,
        "positions": true,
        "orders": true,
        "account_balance": true
    }'::jsonb,
    true,
    true
),

-- MetaTrader 5
(
    'MetaTrader 5',
    'MetaTrader 5 (MT5)',
    'metatrader5',
    'Multi-asset trading platform',
    'platform',
    ARRAY['forex', 'stocks', 'futures', 'crypto', 'cfd'],
    'csv_import',
    '{
        "import_formats": ["mt5_history", "mt5_statement"],
        "fields": ["server", "login", "password"]
    }'::jsonb,
    '{
        "requires_terminal": true,
        "export_path": "~/AppData/Roaming/MetaQuotes/Terminal"
    }'::jsonb,
    '{
        "realtime_sync": false,
        "historical_sync": true,
        "csv_import": true,
        "positions": true
    }'::jsonb,
    true,
    true
),

-- TradeLocker
(
    'TradeLocker',
    'TradeLocker',
    'tradelocker',
    'Modern prop trading platform',
    'prop_firm',
    ARRAY['futures', 'forex', 'crypto'],
    'api_key',
    '{
        "fields": ["api_key", "api_secret"]
    }'::jsonb,
    '{
        "api_url": "https://api.tradelocker.com",
        "websocket_url": "wss://ws.tradelocker.com"
    }'::jsonb,
    '{
        "realtime_sync": true,
        "historical_sync": true,
        "positions": true,
        "orders": true,
        "account_balance": true
    }'::jsonb,
    true,
    true
),

-- Bybit
(
    'Bybit',
    'Bybit',
    'bybit',
    'Cryptocurrency derivatives exchange',
    'exchange',
    ARRAY['crypto'],
    'api_key',
    '{
        "fields": ["api_key", "api_secret"],
        "supports_subaccounts": true
    }'::jsonb,
    '{
        "api_url": "https://api.bybit.com",
        "testnet_url": "https://api-testnet.bybit.com",
        "websocket_url": "wss://stream.bybit.com/v5/private"
    }'::jsonb,
    '{
        "realtime_sync": true,
        "historical_sync": true,
        "positions": true,
        "orders": true,
        "account_balance": true,
        "trade_execution": true
    }'::jsonb,
    true,
    false
),

-- Binance
(
    'Binance',
    'Binance',
    'binance',
    'World''s largest cryptocurrency exchange',
    'exchange',
    ARRAY['crypto'],
    'api_key',
    '{
        "fields": ["api_key", "api_secret"],
        "supports_subaccounts": true
    }'::jsonb,
    '{
        "spot_url": "https://api.binance.com",
        "futures_url": "https://fapi.binance.com",
        "testnet_url": "https://testnet.binancefuture.com",
        "websocket_url": "wss://fstream.binance.com"
    }'::jsonb,
    '{
        "realtime_sync": true,
        "historical_sync": true,
        "positions": true,
        "orders": true,
        "account_balance": true,
        "trade_execution": true
    }'::jsonb,
    true,
    false
),

-- Sierra Chart
(
    'Sierra Chart',
    'Sierra Chart',
    'sierra-chart',
    'Professional trading platform with advanced charting',
    'platform',
    ARRAY['futures', 'stocks'],
    'csv_import',
    '{
        "import_formats": ["sierra_trade_log", "sierra_activity_log"],
        "data_feed_options": ["denali", "teton"]
    }'::jsonb,
    '{
        "export_path": "SierraChart/Data"
    }'::jsonb,
    '{
        "realtime_sync": false,
        "historical_sync": true,
        "csv_import": true
    }'::jsonb,
    true,
    true
),

-- TradingView
(
    'TradingView',
    'TradingView',
    'tradingview',
    'Popular charting platform with broker integrations',
    'platform',
    ARRAY['stocks', 'futures', 'forex', 'crypto'],
    'csv_import',
    '{
        "import_formats": ["tradingview_export"]
    }'::jsonb,
    '{
        "chart_url": "https://www.tradingview.com"
    }'::jsonb,
    '{
        "realtime_sync": false,
        "historical_sync": true,
        "csv_import": true
    }'::jsonb,
    true,
    true
),

-- Charles Schwab
(
    'Charles Schwab',
    'Charles Schwab',
    'charles-schwab',
    'Major US brokerage firm (includes TD Ameritrade)',
    'broker',
    ARRAY['stocks', 'options', 'futures', 'etf'],
    'oauth2',
    '{
        "oauth_url": "https://api.schwabapi.com/v1/oauth"
    }'::jsonb,
    '{
        "api_url": "https://api.schwabapi.com"
    }'::jsonb,
    '{
        "realtime_sync": true,
        "historical_sync": true,
        "positions": true,
        "orders": true,
        "account_balance": true
    }'::jsonb,
    true,
    true
),

-- Robinhood
(
    'Robinhood',
    'Robinhood',
    'robinhood',
    'Commission-free stock and crypto trading',
    'broker',
    ARRAY['stocks', 'options', 'crypto'],
    'csv_import',
    '{
        "import_formats": ["robinhood_export"],
        "notes": "API access limited, CSV import recommended"
    }'::jsonb,
    '{}',
    '{
        "realtime_sync": false,
        "historical_sync": true,
        "csv_import": true
    }'::jsonb,
    true,
    true
),

-- ColmexPro
(
    'ColmexPro',
    'ColmexPro',
    'colmexpro',
    'Prop trading and forex broker',
    'prop_firm',
    ARRAY['forex', 'cfd'],
    'credentials',
    '{
        "fields": ["username", "password"]
    }'::jsonb,
    '{
        "platform": "metatrader"
    }'::jsonb,
    '{
        "realtime_sync": false,
        "historical_sync": true,
        "csv_import": true
    }'::jsonb,
    true,
    true
),

-- DXtrade
(
    'DXtrade',
    'DXtrade',
    'dxtrade',
    'Multi-asset trading platform by Devexperts',
    'platform',
    ARRAY['forex', 'cfd', 'crypto'],
    'credentials',
    '{
        "fields": ["username", "password", "server"]
    }'::jsonb,
    '{}',
    '{
        "realtime_sync": true,
        "historical_sync": true,
        "positions": true
    }'::jsonb,
    true,
    true
),

-- SnapTrade (Aggregator)
(
    'SnapTrade',
    'SnapTrade',
    'snaptrade',
    'Brokerage aggregator supporting 50+ brokers',
    'aggregator',
    ARRAY['stocks', 'options', 'etf', 'crypto'],
    'oauth2',
    '{
        "oauth_flow": "redirect",
        "supports_multiple_brokers": true
    }'::jsonb,
    '{
        "api_url": "https://api.snaptrade.com/api/v1",
        "docs_url": "https://docs.snaptrade.com"
    }'::jsonb,
    '{
        "realtime_sync": true,
        "historical_sync": true,
        "positions": true,
        "orders": true,
        "account_balance": true,
        "multi_broker": true
    }'::jsonb,
    true,
    false
)

ON CONFLICT (slug) DO UPDATE SET
    display_name = EXCLUDED.display_name,
    description = EXCLUDED.description,
    broker_type = EXCLUDED.broker_type,
    asset_classes = EXCLUDED.asset_classes,
    auth_method = EXCLUDED.auth_method,
    auth_config = EXCLUDED.auth_config,
    api_config = EXCLUDED.api_config,
    features = EXCLUDED.features,
    is_beta = EXCLUDED.is_beta,
    updated_at = NOW();

-- ============================================================================
-- STEP 9: SEED DATA - Common Futures Instruments
-- ============================================================================

INSERT INTO instrument_definitions (
    symbol, name, asset_class, instrument_type, exchange, product_code,
    tick_size, tick_value, point_value, contract_size, currency
) VALUES
-- CME E-mini Futures
('ES', 'E-mini S&P 500', 'futures', 'quarterly', 'CME', 'ES', 0.25, 12.50, 50.00, 50, 'USD'),
('NQ', 'E-mini Nasdaq 100', 'futures', 'quarterly', 'CME', 'NQ', 0.25, 5.00, 20.00, 20, 'USD'),
('RTY', 'E-mini Russell 2000', 'futures', 'quarterly', 'CME', 'RTY', 0.10, 5.00, 50.00, 50, 'USD'),
('YM', 'E-mini Dow', 'futures', 'quarterly', 'CBOT', 'YM', 1.00, 5.00, 5.00, 5, 'USD'),

-- Micro Futures
('MES', 'Micro E-mini S&P 500', 'futures', 'quarterly', 'CME', 'MES', 0.25, 1.25, 5.00, 5, 'USD'),
('MNQ', 'Micro E-mini Nasdaq 100', 'futures', 'quarterly', 'CME', 'MNQ', 0.25, 0.50, 2.00, 2, 'USD'),
('M2K', 'Micro E-mini Russell 2000', 'futures', 'quarterly', 'CME', 'M2K', 0.10, 0.50, 5.00, 5, 'USD'),
('MYM', 'Micro E-mini Dow', 'futures', 'quarterly', 'CBOT', 'MYM', 1.00, 0.50, 0.50, 0.5, 'USD'),

-- Commodities
('CL', 'Crude Oil', 'futures', 'monthly', 'NYMEX', 'CL', 0.01, 10.00, 1000.00, 1000, 'USD'),
('GC', 'Gold', 'futures', 'monthly', 'COMEX', 'GC', 0.10, 10.00, 100.00, 100, 'USD'),
('SI', 'Silver', 'futures', 'monthly', 'COMEX', 'SI', 0.005, 25.00, 5000.00, 5000, 'USD'),
('NG', 'Natural Gas', 'futures', 'monthly', 'NYMEX', 'NG', 0.001, 10.00, 10000.00, 10000, 'USD'),

-- Currencies
('6E', 'Euro FX', 'futures', 'quarterly', 'CME', '6E', 0.00005, 6.25, 125000.00, 125000, 'USD'),
('6J', 'Japanese Yen', 'futures', 'quarterly', 'CME', '6J', 0.0000005, 6.25, 12500000.00, 12500000, 'USD'),
('6B', 'British Pound', 'futures', 'quarterly', 'CME', '6B', 0.0001, 6.25, 62500.00, 62500, 'USD'),

-- Treasuries
('ZB', '30-Year Treasury Bond', 'futures', 'quarterly', 'CBOT', 'ZB', 0.03125, 31.25, 1000.00, 1000, 'USD'),
('ZN', '10-Year Treasury Note', 'futures', 'quarterly', 'CBOT', 'ZN', 0.015625, 15.625, 1000.00, 1000, 'USD'),
('ZF', '5-Year Treasury Note', 'futures', 'quarterly', 'CBOT', 'ZF', 0.0078125, 7.8125, 1000.00, 1000, 'USD')

ON CONFLICT (symbol, exchange) DO UPDATE SET
    name = EXCLUDED.name,
    tick_size = EXCLUDED.tick_size,
    tick_value = EXCLUDED.tick_value,
    point_value = EXCLUDED.point_value,
    contract_size = EXCLUDED.contract_size,
    updated_at = NOW();

-- ============================================================================
-- STEP 10: ROW LEVEL SECURITY (RLS) POLICIES
-- ============================================================================

-- Enable RLS on all tables
ALTER TABLE broker_definitions ENABLE ROW LEVEL SECURITY;
ALTER TABLE broker_connections ENABLE ROW LEVEL SECURITY;
ALTER TABLE broker_accounts ENABLE ROW LEVEL SECURITY;
ALTER TABLE broker_sync_logs ENABLE ROW LEVEL SECURITY;
ALTER TABLE broker_raw_data ENABLE ROW LEVEL SECURITY;
ALTER TABLE instrument_definitions ENABLE ROW LEVEL SECURITY;

-- Broker Definitions - Public read access
DROP POLICY IF EXISTS "Anyone can view active broker definitions" ON broker_definitions;
CREATE POLICY "Anyone can view active broker definitions"
    ON broker_definitions FOR SELECT
    USING (is_active = true);

-- Broker Connections Policies
DROP POLICY IF EXISTS "Users can view their own broker connections" ON broker_connections;
DROP POLICY IF EXISTS "Users can insert their own broker connections" ON broker_connections;
DROP POLICY IF EXISTS "Users can update their own broker connections" ON broker_connections;
DROP POLICY IF EXISTS "Users can delete their own broker connections" ON broker_connections;

CREATE POLICY "Users can view their own broker connections"
    ON broker_connections FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert their own broker connections"
    ON broker_connections FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update their own broker connections"
    ON broker_connections FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete their own broker connections"
    ON broker_connections FOR DELETE
    USING (auth.uid() = user_id);

-- Broker Accounts Policies
DROP POLICY IF EXISTS "Users can view their own broker accounts" ON broker_accounts;
DROP POLICY IF EXISTS "Users can insert their own broker accounts" ON broker_accounts;
DROP POLICY IF EXISTS "Users can update their own broker accounts" ON broker_accounts;
DROP POLICY IF EXISTS "Users can delete their own broker accounts" ON broker_accounts;

CREATE POLICY "Users can view their own broker accounts"
    ON broker_accounts FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert their own broker accounts"
    ON broker_accounts FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update their own broker accounts"
    ON broker_accounts FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete their own broker accounts"
    ON broker_accounts FOR DELETE
    USING (auth.uid() = user_id);

-- Broker Sync Logs Policies
DROP POLICY IF EXISTS "Users can view their own sync logs" ON broker_sync_logs;
DROP POLICY IF EXISTS "Users can insert their own sync logs" ON broker_sync_logs;
DROP POLICY IF EXISTS "Users can update their own sync logs" ON broker_sync_logs;

CREATE POLICY "Users can view their own sync logs"
    ON broker_sync_logs FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert their own sync logs"
    ON broker_sync_logs FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update their own sync logs"
    ON broker_sync_logs FOR UPDATE
    USING (auth.uid() = user_id);

-- Broker Raw Data Policies
DROP POLICY IF EXISTS "Users can view their own raw data" ON broker_raw_data;
DROP POLICY IF EXISTS "Users can insert their own raw data" ON broker_raw_data;

CREATE POLICY "Users can view their own raw data"
    ON broker_raw_data FOR SELECT
    USING (
        EXISTS (
            SELECT 1 FROM broker_connections bc
            WHERE bc.id = broker_raw_data.connection_id
            AND bc.user_id = auth.uid()
        )
    );

CREATE POLICY "Users can insert their own raw data"
    ON broker_raw_data FOR INSERT
    WITH CHECK (
        EXISTS (
            SELECT 1 FROM broker_connections bc
            WHERE bc.id = broker_raw_data.connection_id
            AND bc.user_id = auth.uid()
        )
    );

-- Instrument Definitions - Public read access
DROP POLICY IF EXISTS "Anyone can view instrument definitions" ON instrument_definitions;
CREATE POLICY "Anyone can view instrument definitions"
    ON instrument_definitions FOR SELECT
    USING (is_active = true);

-- ============================================================================
-- STEP 11: HELPER FUNCTIONS (OPTIMIZED)
-- ============================================================================

-- Function to get user's active broker connections with broker details
CREATE OR REPLACE FUNCTION get_user_broker_connections(p_user_id UUID)
RETURNS TABLE (
    connection_id UUID,
    broker_name VARCHAR,
    broker_slug VARCHAR,
    broker_logo TEXT,
    connection_name VARCHAR,
    environment VARCHAR,
    status VARCHAR,
    accounts_count BIGINT,
    last_sync_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        bc.id as connection_id,
        COALESCE(bd.display_name, bc.broker::VARCHAR) as broker_name,
        COALESCE(bd.slug, bc.broker::VARCHAR) as broker_slug,
        bd.logo_url as broker_logo,
        bc.connection_name,
        bc.environment,
        bc.status,
        COUNT(ba.id) as accounts_count,
        bc.last_sync_at,
        bc.created_at
    FROM broker_connections bc
    LEFT JOIN broker_definitions bd ON bc.broker_id = bd.id
    LEFT JOIN broker_accounts ba ON ba.connection_id = bc.id AND ba.is_active = true
    WHERE bc.user_id = p_user_id
    AND bc.is_active = true
    GROUP BY bc.id, bd.display_name, bd.slug, bd.logo_url
    ORDER BY bc.created_at DESC;
END;
$$ LANGUAGE plpgsql STABLE SECURITY DEFINER;

-- Function to update connection status
CREATE OR REPLACE FUNCTION update_connection_status(
    p_connection_id UUID,
    p_status VARCHAR,
    p_message TEXT DEFAULT NULL
) RETURNS VOID AS $$
BEGIN
    UPDATE broker_connections
    SET 
        status = p_status,
        status_message = p_message,
        updated_at = NOW(),
        connected_at = CASE WHEN p_status = 'connected' THEN NOW() ELSE connected_at END,
        disconnected_at = CASE WHEN p_status IN ('disconnected', 'expired', 'revoked', 'error') THEN NOW() ELSE disconnected_at END
    WHERE id = p_connection_id;
END;
$$ LANGUAGE plpgsql VOLATILE SECURITY DEFINER;

-- Function to log sync operation
CREATE OR REPLACE FUNCTION log_sync_operation(
    p_connection_id UUID,
    p_account_id UUID,
    p_user_id UUID,
    p_sync_type VARCHAR,
    p_trigger VARCHAR DEFAULT 'manual'
) RETURNS UUID AS $$
DECLARE
    v_log_id UUID;
BEGIN
    INSERT INTO broker_sync_logs (
        connection_id, account_id, user_id, sync_type, sync_trigger, status
    ) VALUES (
        p_connection_id, p_account_id, p_user_id, p_sync_type, p_trigger, 'started'
    ) RETURNING id INTO v_log_id;
    
    RETURN v_log_id;
END;
$$ LANGUAGE plpgsql VOLATILE SECURITY DEFINER;

-- Function to complete sync operation
CREATE OR REPLACE FUNCTION complete_sync_operation(
    p_log_id UUID,
    p_status VARCHAR,
    p_records_fetched INTEGER DEFAULT 0,
    p_records_created INTEGER DEFAULT 0,
    p_records_updated INTEGER DEFAULT 0,
    p_records_skipped INTEGER DEFAULT 0,
    p_records_failed INTEGER DEFAULT 0,
    p_error_message TEXT DEFAULT NULL,
    p_sync_details JSONB DEFAULT '{}'
) RETURNS VOID AS $$
DECLARE
    v_started_at TIMESTAMPTZ;
    v_duration INTEGER;
    v_connection_id UUID;
BEGIN
    SELECT started_at, connection_id INTO v_started_at, v_connection_id 
    FROM broker_sync_logs WHERE id = p_log_id;
    
    v_duration := EXTRACT(MILLISECONDS FROM (NOW() - v_started_at))::INTEGER;
    
    UPDATE broker_sync_logs
    SET 
        status = p_status,
        records_fetched = p_records_fetched,
        records_created = p_records_created,
        records_updated = p_records_updated,
        records_skipped = p_records_skipped,
        records_failed = p_records_failed,
        error_message = p_error_message,
        sync_details = p_sync_details,
        completed_at = NOW(),
        duration_ms = v_duration
    WHERE id = p_log_id;
    
    -- Update last sync on connection
    UPDATE broker_connections
    SET 
        last_sync_at = NOW(),
        last_successful_sync_at = CASE WHEN p_status = 'completed' THEN NOW() ELSE last_successful_sync_at END,
        last_error = CASE WHEN p_status = 'failed' THEN p_error_message ELSE last_error END,
        last_error_at = CASE WHEN p_status = 'failed' THEN NOW() ELSE last_error_at END,
        error_count = CASE WHEN p_status = 'failed' THEN COALESCE(error_count, 0) + 1 ELSE 0 END
    WHERE id = v_connection_id;
END;
$$ LANGUAGE plpgsql VOLATILE SECURITY DEFINER;

-- Function to get broker definition by slug (with caching hint)
CREATE OR REPLACE FUNCTION get_broker_by_slug(p_slug VARCHAR)
RETURNS broker_definitions AS $$
DECLARE
    v_broker broker_definitions;
BEGIN
    SELECT * INTO v_broker
    FROM broker_definitions
    WHERE slug = p_slug AND is_active = true;
    
    RETURN v_broker;
END;
$$ LANGUAGE plpgsql STABLE SECURITY DEFINER;

-- Function to get instrument by symbol
CREATE OR REPLACE FUNCTION get_instrument_by_symbol(p_symbol VARCHAR, p_exchange VARCHAR DEFAULT NULL)
RETURNS instrument_definitions AS $$
DECLARE
    v_instrument instrument_definitions;
BEGIN
    IF p_exchange IS NOT NULL THEN
        SELECT * INTO v_instrument
        FROM instrument_definitions
        WHERE symbol = p_symbol AND exchange = p_exchange AND is_active = true;
    ELSE
        SELECT * INTO v_instrument
        FROM instrument_definitions
        WHERE symbol = p_symbol AND is_active = true
        LIMIT 1;
    END IF;
    
    RETURN v_instrument;
END;
$$ LANGUAGE plpgsql STABLE SECURITY DEFINER;

-- Optimized function for checking duplicate trades during sync
CREATE OR REPLACE FUNCTION get_existing_trade_external_ids(
    p_user_id UUID,
    p_broker VARCHAR,
    p_external_ids TEXT[]
) RETURNS TABLE(external_id TEXT) AS $$
BEGIN
    RETURN QUERY
    SELECT t.external_id
    FROM trades t
    WHERE t.user_id = p_user_id
    AND t.broker = p_broker
    AND t.external_id = ANY(p_external_ids);
END;
$$ LANGUAGE plpgsql STABLE SECURITY DEFINER;

-- Bulk insert trades function for better performance
CREATE OR REPLACE FUNCTION bulk_insert_trades(
    p_trades JSONB
) RETURNS TABLE(inserted_count INTEGER, skipped_count INTEGER) AS $$
DECLARE
    v_inserted INTEGER := 0;
    v_skipped INTEGER := 0;
    v_trade JSONB;
BEGIN
    FOR v_trade IN SELECT * FROM jsonb_array_elements(p_trades)
    LOOP
        BEGIN
            INSERT INTO trades (
                user_id, symbol, asset_class, side, quantity,
                entry_price, exit_price, stop_price, fees, fees_mode,
                open_at, close_at, pnl, broker, external_id,
                multiplier, import_source, broker_connection_id,
                broker_account_id, broker_trade_id, synced_at, raw_data
            ) VALUES (
                (v_trade->>'user_id')::UUID,
                v_trade->>'symbol',
                v_trade->>'asset_class',
                v_trade->>'side',
                (v_trade->>'quantity')::NUMERIC,
                (v_trade->>'entry_price')::NUMERIC,
                (v_trade->>'exit_price')::NUMERIC,
                (v_trade->>'stop_price')::NUMERIC,
                COALESCE((v_trade->>'fees')::NUMERIC, 0),
                COALESCE(v_trade->>'fees_mode', 'auto'),
                (v_trade->>'open_at')::TIMESTAMPTZ,
                (v_trade->>'close_at')::TIMESTAMPTZ,
                (v_trade->>'pnl')::NUMERIC,
                v_trade->>'broker',
                v_trade->>'external_id',
                (v_trade->>'multiplier')::NUMERIC,
                v_trade->>'import_source',
                (v_trade->>'broker_connection_id')::UUID,
                (v_trade->>'broker_account_id')::UUID,
                v_trade->>'broker_trade_id',
                COALESCE((v_trade->>'synced_at')::TIMESTAMPTZ, NOW()),
                v_trade->'raw_data'
            );
            v_inserted := v_inserted + 1;
        EXCEPTION WHEN unique_violation THEN
            v_skipped := v_skipped + 1;
        END;
    END LOOP;
    
    RETURN QUERY SELECT v_inserted, v_skipped;
END;
$$ LANGUAGE plpgsql VOLATILE SECURITY DEFINER;

-- ============================================================================
-- STEP 12: TRIGGERS FOR UPDATED_AT
-- ============================================================================

CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE 'plpgsql';

DROP TRIGGER IF EXISTS update_broker_definitions_updated_at ON broker_definitions;
CREATE TRIGGER update_broker_definitions_updated_at
    BEFORE UPDATE ON broker_definitions
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

DROP TRIGGER IF EXISTS update_broker_connections_updated_at ON broker_connections;
CREATE TRIGGER update_broker_connections_updated_at
    BEFORE UPDATE ON broker_connections
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

DROP TRIGGER IF EXISTS update_broker_accounts_updated_at ON broker_accounts;
CREATE TRIGGER update_broker_accounts_updated_at
    BEFORE UPDATE ON broker_accounts
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

DROP TRIGGER IF EXISTS update_instrument_definitions_updated_at ON instrument_definitions;
CREATE TRIGGER update_instrument_definitions_updated_at
    BEFORE UPDATE ON instrument_definitions
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- ============================================================================
-- STEP 13: LINK EXISTING BROKER_CONNECTIONS TO BROKER_DEFINITIONS
-- ============================================================================

UPDATE broker_connections 
SET broker_id = (SELECT id FROM broker_definitions WHERE slug = 'tradovate')
WHERE broker = 'tradovate' AND broker_id IS NULL;

UPDATE broker_connections 
SET broker_id = (SELECT id FROM broker_definitions WHERE slug = 'ninjatrader')
WHERE broker = 'ninja_trader' AND broker_id IS NULL;

UPDATE broker_connections 
SET broker_id = (SELECT id FROM broker_definitions WHERE slug = 'interactive-brokers')
WHERE broker = 'interactive_brokers' AND broker_id IS NULL;

UPDATE broker_connections 
SET broker_id = (SELECT id FROM broker_definitions WHERE slug = 'tradingview')
WHERE broker = 'tradingview' AND broker_id IS NULL;

UPDATE broker_connections 
SET broker_id = (SELECT id FROM broker_definitions WHERE slug = 'metatrader5')
WHERE broker IN ('mt4', 'mt5') AND broker_id IS NULL;

UPDATE broker_connections 
SET broker_id = (SELECT id FROM broker_definitions WHERE slug = 'snaptrade')
WHERE broker = 'snaptrade' AND broker_id IS NULL;

-- ============================================================================
-- STEP 14: ANALYZE TABLES FOR QUERY PLANNER OPTIMIZATION
-- ============================================================================

ANALYZE broker_definitions;
ANALYZE broker_connections;
ANALYZE broker_accounts;
ANALYZE broker_sync_logs;
ANALYZE broker_raw_data;
ANALYZE instrument_definitions;
ANALYZE trades;

-- ============================================================================
-- STEP 15: SNAPTRADE USERS TABLE (Credentials Storage)
-- ============================================================================

CREATE TABLE IF NOT EXISTS public.snaptrade_users (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    snaptrade_user_id TEXT NOT NULL,
    snaptrade_user_secret TEXT NOT NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    CONSTRAINT snaptrade_users_user_id_key UNIQUE (user_id)
);

-- Index
CREATE INDEX IF NOT EXISTS idx_snaptrade_users_user_id 
ON public.snaptrade_users(user_id);

-- RLS
ALTER TABLE public.snaptrade_users ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Users can view own snaptrade" ON public.snaptrade_users;
CREATE POLICY "Users can view own snaptrade" 
ON public.snaptrade_users FOR SELECT 
USING (auth.uid() = user_id);

DROP POLICY IF EXISTS "Users can insert own snaptrade" ON public.snaptrade_users;
CREATE POLICY "Users can insert own snaptrade" 
ON public.snaptrade_users FOR INSERT 
WITH CHECK (auth.uid() = user_id);

DROP POLICY IF EXISTS "Users can update own snaptrade" ON public.snaptrade_users;
CREATE POLICY "Users can update own snaptrade" 
ON public.snaptrade_users FOR UPDATE 
USING (auth.uid() = user_id);

DROP POLICY IF EXISTS "Users can delete own snaptrade" ON public.snaptrade_users;
CREATE POLICY "Users can delete own snaptrade" 
ON public.snaptrade_users FOR DELETE 
USING (auth.uid() = user_id);

-- Updated at trigger (reuse existing function)
DROP TRIGGER IF EXISTS update_snaptrade_users_updated_at ON public.snaptrade_users;
CREATE TRIGGER update_snaptrade_users_updated_at
    BEFORE UPDATE ON public.snaptrade_users
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- ============================================================================
-- STEP 16: SNAPTRADE ACTIVITY TABLE (Activity Tracking)
-- ============================================================================

CREATE TABLE IF NOT EXISTS public.snaptrade_activity (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    last_activity_at TIMESTAMPTZ DEFAULT NOW(),
    connection_status TEXT DEFAULT 'disconnected',
    brokerage_connection_id TEXT,
    brokerage_name TEXT,
    connected_at TIMESTAMPTZ,
    disconnected_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    CONSTRAINT snaptrade_activity_user_id_key UNIQUE (user_id),
    CONSTRAINT snaptrade_activity_connection_status_check 
        CHECK (connection_status IN ('connected', 'disconnected'))
);

-- Indexes
CREATE INDEX IF NOT EXISTS idx_snaptrade_activity_user_id 
ON public.snaptrade_activity(user_id);

CREATE INDEX IF NOT EXISTS idx_snaptrade_activity_last_activity 
ON public.snaptrade_activity(last_activity_at);

CREATE INDEX IF NOT EXISTS idx_snaptrade_activity_status 
ON public.snaptrade_activity(connection_status);

-- RLS
ALTER TABLE public.snaptrade_activity ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Users can view own activity" ON public.snaptrade_activity;
CREATE POLICY "Users can view own activity" 
ON public.snaptrade_activity FOR SELECT 
USING (auth.uid() = user_id);

DROP POLICY IF EXISTS "Users can insert own activity" ON public.snaptrade_activity;
CREATE POLICY "Users can insert own activity" 
ON public.snaptrade_activity FOR INSERT 
WITH CHECK (auth.uid() = user_id);

DROP POLICY IF EXISTS "Users can update own activity" ON public.snaptrade_activity;
CREATE POLICY "Users can update own activity" 
ON public.snaptrade_activity FOR UPDATE 
USING (auth.uid() = user_id);

-- Updated at trigger (reuse existing function)
DROP TRIGGER IF EXISTS update_snaptrade_activity_updated_at ON public.snaptrade_activity;
CREATE TRIGGER update_snaptrade_activity_updated_at
    BEFORE UPDATE ON public.snaptrade_activity
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- ============================================================================
-- STEP 17: ADD SNAPTRADE COLUMNS TO TRADES TABLE
-- ============================================================================

ALTER TABLE public.trades 
ADD COLUMN IF NOT EXISTS snaptrade_activity_id TEXT UNIQUE;

ALTER TABLE public.trades 
ADD COLUMN IF NOT EXISTS snaptrade_account_id TEXT;

-- Index for deduplication
CREATE INDEX IF NOT EXISTS idx_trades_snaptrade_activity_id 
ON public.trades(snaptrade_activity_id) 
WHERE snaptrade_activity_id IS NOT NULL;

-- ============================================================================
-- STEP 18: FINAL ANALYZE
-- ============================================================================

ANALYZE snaptrade_users;
ANALYZE snaptrade_activity;
ANALYZE trades;

-- ============================================================================
-- VERIFICATION QUERIES (run these after migration to verify)
-- ============================================================================
/*
-- Check all tables exist
SELECT table_name FROM information_schema.tables 
WHERE table_schema = 'public' 
AND table_name IN ('broker_definitions', 'broker_connections', 'broker_accounts', 
                   'broker_sync_logs', 'broker_raw_data', 'instrument_definitions',
                   'snaptrade_users', 'snaptrade_activity');

-- Check broker_definitions has data (including snaptrade)
SELECT slug, display_name, broker_type, is_active FROM broker_definitions ORDER BY display_name;

-- Check instrument_definitions has data
SELECT symbol, name, point_value, tick_value FROM instrument_definitions ORDER BY symbol;

-- Check trades constraints include all brokers
SELECT conname, pg_get_constraintdef(oid) 
FROM pg_constraint 
WHERE conrelid = 'trades'::regclass 
AND (conname LIKE '%broker%' OR conname LIKE '%import%');

-- Check broker_connections columns
SELECT column_name, data_type 
FROM information_schema.columns 
WHERE table_name = 'broker_connections'
ORDER BY ordinal_position;

-- Check snaptrade columns on trades
SELECT column_name, data_type 
FROM information_schema.columns 
WHERE table_name = 'trades' 
AND column_name LIKE 'snaptrade%';

-- Check RLS policies
SELECT schemaname, tablename, policyname, cmd, qual 
FROM pg_policies 
WHERE tablename IN ('broker_definitions', 'broker_connections', 'broker_accounts', 
                    'broker_sync_logs', 'broker_raw_data', 'instrument_definitions',
                    'snaptrade_users', 'snaptrade_activity');

-- Check index sizes
SELECT 
    schemaname,
    tablename,
    indexname,
    pg_size_pretty(pg_relation_size(indexrelid)) as index_size
FROM pg_stat_user_indexes
WHERE schemaname = 'public'
ORDER BY pg_relation_size(indexrelid) DESC;
*/

-- ============================================================================
-- END OF UNIFIED MIGRATION ✅
-- ============================================================================