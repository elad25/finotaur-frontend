-- ===============================================
-- üî• FINOTAUR - COMPLETE UNIFIED MIGRATION
-- ===============================================
-- Version: MERGED-v8.5.0-WITH-SNAPTRADE
-- Date: 2025-01-15
-- Parts: 2/3 (Functions + Triggers) - ◊ó◊ú◊ß 2/2 (◊°◊¢◊ô◊§◊ô◊ù 7-15) ‚úÖ COMPLETE
-- üî• NEW v8.5.0: SnapTrade Integration Included!
-- üîß FIXED v8.4.7: 
--    - admin_update_subscription NOW RETURNS JSONB (not VOID)
--    - Better error handling in admin functions
--    - Portfolio fields in get_user_subscription_status
--    - Section 14: Helper Functions
--    - üî• Section 15: SnapTrade Functions
-- PREREQUISITE: Run PART-2-FUNCTIONS-SECTION-1.sql first!
-- ===============================================

BEGIN;

DO $$
BEGIN
  RAISE NOTICE '';
  RAISE NOTICE '‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó';
  RAISE NOTICE '‚ïë  üî• FINOTAUR MERGED MIGRATION v8.5.0  ‚ïë';
  RAISE NOTICE '‚ïë     Part 2/3: Functions + Triggers    ‚ïë';
  RAISE NOTICE '‚ïë     Section 2/2: ◊°◊¢◊ô◊§◊ô◊ù 7-15         ‚ïë';
  RAISE NOTICE '‚ïë     üî• WITH SNAPTRADE INTEGRATION!    ‚ïë';
  RAISE NOTICE '‚ïë     üîß FIXED: admin_update returns JSONB! ‚ïë';
  RAISE NOTICE '‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù';
  RAISE NOTICE '';
END $$;

-- ===============================================
-- SECTION 7: SUBSCRIPTION FUNCTIONS
-- ===============================================

DO $$
BEGIN
  RAISE NOTICE '[7/15] Creating subscription functions...';
END $$;

-- üîß FIXED: Drop old function first to avoid type conflicts
DROP FUNCTION IF EXISTS public.get_user_subscription_status(UUID) CASCADE;

-- üÜï FIXED: Get User Subscription Status (WITH PORTFOLIO FIELDS)
CREATE OR REPLACE FUNCTION public.get_user_subscription_status(user_id_param UUID)
RETURNS TABLE (
  remaining INT,
  used INT,
  max_trades INT,
  plan TEXT,
  reset_date TEXT,
  account_type TEXT,
  subscription_interval TEXT,
  subscription_status TEXT,
  subscription_expires_at TIMESTAMPTZ,
  role TEXT,
  initial_portfolio NUMERIC,      -- üîß ADDED
  current_portfolio NUMERIC        -- üîß ADDED
) 
LANGUAGE plpgsql
SECURITY DEFINER
STABLE
AS $$
DECLARE
  v_profile RECORD;
  v_trades_used INT;
  v_reset_date DATE;
BEGIN
  -- Get profile data (INCLUDING PORTFOLIO FIELDS)
  SELECT 
    p.account_type,
    p.max_trades,
    p.subscription_interval,
    p.subscription_status,
    p.subscription_expires_at,
    COALESCE(p.billing_cycle_start, CURRENT_DATE) as billing_cycle_start,
    COALESCE(p.role, 'user') as role,
    COALESCE(p.current_month_trades_count, 0) as monthly_count,
    COALESCE(p.trade_count, 0) as lifetime_count,
    COALESCE(p.initial_portfolio, 10000) as initial_portfolio,          -- üîß ADDED
    COALESCE(p.current_portfolio, p.initial_portfolio, 10000) as current_portfolio  -- üîß ADDED
  INTO v_profile
  FROM public.profiles p
  WHERE p.id = user_id_param;
  
  -- If profile doesn't exist, return safe defaults
  IF NOT FOUND THEN
    RETURN QUERY SELECT 
      10::INT,                    -- remaining
      0::INT,                     -- used
      10::INT,                    -- max_trades
      'Free Plan'::TEXT,          -- plan
      CURRENT_DATE::TEXT,         -- reset_date
      'free'::TEXT,               -- account_type
      NULL::TEXT,                 -- subscription_interval
      'active'::TEXT,             -- subscription_status
      NULL::TIMESTAMPTZ,          -- subscription_expires_at
      'user'::TEXT,               -- role
      10000::NUMERIC,             -- initial_portfolio üîß ADDED
      10000::NUMERIC;             -- current_portfolio üîß ADDED
    RETURN;
  END IF;
  
  -- Calculate reset date (next month for BASIC/TRIAL/PREMIUM only)
  IF v_profile.account_type IN ('basic', 'trial', 'premium') THEN
    v_reset_date := (DATE_TRUNC('month', v_profile.billing_cycle_start) + INTERVAL '1 month')::DATE;
  ELSE
    -- FREE users don't have reset date
    v_reset_date := NULL;
  END IF;
  
  -- Determine which counter to use
  IF v_profile.account_type = 'free' THEN
    v_trades_used := v_profile.lifetime_count;
  ELSE
    v_trades_used := v_profile.monthly_count;
  END IF;
  
  -- Handle unlimited users (admin/premium/vip)
  IF v_profile.role IN ('admin', 'super_admin') OR 
     v_profile.account_type IN ('premium', 'admin', 'vip') THEN
    RETURN QUERY SELECT
      999999::INT,                                    -- remaining (unlimited)
      v_trades_used::INT,                             -- used
      999999::INT,                                    -- max_trades
      CASE v_profile.account_type
        WHEN 'premium' THEN 'Premium Plan'
        WHEN 'admin' THEN 'Admin'
        WHEN 'vip' THEN 'VIP'
        ELSE 'Premium Plan'
      END::TEXT,                                      -- plan
      v_reset_date::TEXT,                             -- reset_date
      v_profile.account_type::TEXT,                   -- account_type
      v_profile.subscription_interval::TEXT,          -- subscription_interval
      v_profile.subscription_status::TEXT,            -- subscription_status
      v_profile.subscription_expires_at::TIMESTAMPTZ, -- subscription_expires_at
      v_profile.role::TEXT,                           -- role
      v_profile.initial_portfolio::NUMERIC,           -- initial_portfolio üîß ADDED
      v_profile.current_portfolio::NUMERIC;           -- current_portfolio üîß ADDED
    RETURN;
  END IF;
  
  -- Regular user result
  RETURN QUERY SELECT
    GREATEST(0, v_profile.max_trades - v_trades_used)::INT, -- remaining
    v_trades_used::INT,                                     -- used
    v_profile.max_trades::INT,                              -- max_trades
    CASE v_profile.account_type
      WHEN 'free' THEN 'Free Plan'
      WHEN 'basic' THEN 'Basic Plan'
      WHEN 'premium' THEN 'Premium Plan'
      WHEN 'trial' THEN 'Trial'
      ELSE 'Free Plan'
    END::TEXT,                                              -- plan
    v_reset_date::TEXT,                                     -- reset_date
    v_profile.account_type::TEXT,                           -- account_type
    v_profile.subscription_interval::TEXT,                  -- subscription_interval
    v_profile.subscription_status::TEXT,                    -- subscription_status
    v_profile.subscription_expires_at::TIMESTAMPTZ,         -- subscription_expires_at
    v_profile.role::TEXT,                                   -- role
    v_profile.initial_portfolio::NUMERIC,                   -- initial_portfolio üîß ADDED
    v_profile.current_portfolio::NUMERIC;                   -- current_portfolio üîß ADDED
END;
$$;

COMMENT ON FUNCTION public.get_user_subscription_status IS 
'v8.5.0-FIXED: Returns subscription status WITH portfolio fields. FREE uses lifetime count, BASIC/TRIAL use monthly count';

-- Check Expired Subscriptions
CREATE OR REPLACE FUNCTION public.check_expired_subscriptions()
RETURNS TABLE(user_id UUID, old_plan TEXT, email TEXT) 
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  RETURN QUERY
  WITH expired_users AS (
    SELECT DISTINCT sp.user_id
    FROM public.subscription_periods sp
    WHERE sp.period_end < NOW()
      AND sp.auto_renew = FALSE
      AND NOT EXISTS (
        SELECT 1 FROM public.subscription_periods sp2
        WHERE sp2.user_id = sp.user_id AND sp2.period_end > NOW()
      )
  )
  UPDATE public.profiles p
  SET 
    account_type = 'free',
    max_trades = 10,
    subscription_status = 'expired',
    subscription_interval = NULL,
    updated_at = NOW()
  FROM expired_users eu
  WHERE p.id = eu.user_id 
    AND p.role NOT IN ('admin', 'super_admin')
  RETURNING p.id, p.account_type, p.email;
END;
$$;

-- ‚úÖ UPDATED: Reset Monthly Trade Counts (ONLY FOR BASIC/TRIAL/PREMIUM)
CREATE OR REPLACE FUNCTION public.reset_monthly_trade_counts()
RETURNS INTEGER
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  reset_count INTEGER;
BEGIN
  WITH reset_users AS (
    UPDATE public.profiles
    SET 
      current_month_trades_count = 0,
      billing_cycle_start = CURRENT_DATE,
      updated_at = NOW()
    WHERE billing_cycle_start < CURRENT_DATE - INTERVAL '1 month'
      AND account_type IN ('basic', 'trial', 'premium')  -- ‚úÖ Only reset paid plans
    RETURNING id
  )
  SELECT COUNT(*) INTO reset_count FROM reset_users;
  
  RETURN reset_count;
END;
$$;

COMMENT ON FUNCTION public.reset_monthly_trade_counts IS 
'v8.5.0: Resets monthly counters ONLY for BASIC/TRIAL/PREMIUM. FREE users are excluded.';

-- Check Usage Warning
CREATE OR REPLACE FUNCTION public.check_usage_warning(target_user_id UUID)
RETURNS BOOLEAN
LANGUAGE plpgsql
SECURITY DEFINER
STABLE
AS $$
DECLARE
  profile_record RECORD;
  usage_percentage NUMERIC;
  trades_used INTEGER;
BEGIN
  SELECT 
    max_trades,
    current_month_trades_count,
    trade_count,
    account_type,
    last_warning_shown_at
  INTO profile_record
  FROM public.profiles
  WHERE id = target_user_id;
  
  IF profile_record.account_type = 'premium' THEN
    RETURN FALSE;
  END IF;
  
  -- FREE uses lifetime count, others use monthly
  IF profile_record.account_type = 'free' THEN
    trades_used := profile_record.trade_count;
  ELSE
    trades_used := profile_record.current_month_trades_count;
  END IF;
  
  usage_percentage := (trades_used::NUMERIC / profile_record.max_trades::NUMERIC) * 100;
  
  IF usage_percentage >= 80 AND 
     (profile_record.last_warning_shown_at IS NULL OR 
      profile_record.last_warning_shown_at < NOW() - INTERVAL '24 hours') THEN
    RETURN TRUE;
  END IF;
  
  RETURN FALSE;
END;
$$;

COMMENT ON FUNCTION public.check_usage_warning IS 
'v8.5.0: Shows warning at 80% usage. FREE uses lifetime count.';

-- Mark Warning Shown
CREATE OR REPLACE FUNCTION public.mark_warning_shown(target_user_id UUID)
RETURNS VOID
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  UPDATE public.profiles
  SET last_warning_shown_at = NOW()
  WHERE id = target_user_id;
END;
$$;

-- ===============================================
-- SECTION 8: PORTFOLIO & STATISTICS
-- ===============================================

DO $$
BEGIN
  RAISE NOTICE '[8/15] Creating portfolio functions...';
END $$;

-- Get Portfolio Stats (OPTIMIZED - ONE QUERY)
CREATE OR REPLACE FUNCTION public.get_portfolio_stats(p_user_id UUID)
RETURNS TABLE (
  initial_portfolio NUMERIC,
  current_portfolio NUMERIC,
  total_pnl NUMERIC,
  growth NUMERIC,
  trade_count BIGINT
) 
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_initial_portfolio NUMERIC;
  v_total_pnl NUMERIC;
  v_trade_count BIGINT;
  v_current_portfolio NUMERIC;
  v_growth NUMERIC;
BEGIN
  SELECT COALESCE(profiles.initial_portfolio, 10000)
  INTO v_initial_portfolio
  FROM profiles
  WHERE profiles.id = p_user_id;

  IF v_initial_portfolio IS NULL THEN
    v_initial_portfolio := 10000;
  END IF;

  SELECT 
    COALESCE(SUM(trades.pnl), 0),
    COUNT(*)
  INTO v_total_pnl, v_trade_count
  FROM trades
  WHERE trades.user_id = p_user_id
    AND trades.exit_price IS NOT NULL;

  v_current_portfolio := v_initial_portfolio + v_total_pnl;
  
  IF v_initial_portfolio > 0 THEN
    v_growth := ((v_current_portfolio - v_initial_portfolio) / v_initial_portfolio) * 100;
  ELSE
    v_growth := 0;
  END IF;

  RETURN QUERY SELECT 
    v_initial_portfolio,
    v_current_portfolio,
    v_total_pnl,
    v_growth,
    v_trade_count;
END;
$$;

-- ===============================================
-- SECTION 9: TRADINGVIEW WEBHOOKS
-- ===============================================

DO $$
BEGIN
  RAISE NOTICE '[9/15] Creating TradingView webhook functions...';
END $$;

-- Close TradingView Trade (ATOMIC)
CREATE OR REPLACE FUNCTION public.close_tradingview_trade(
  p_user_id UUID,
  p_symbol TEXT,
  p_side TEXT,
  p_exit_price NUMERIC
)
RETURNS UUID
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_trade_id UUID;
  v_entry_price NUMERIC;
  v_outcome TEXT;
BEGIN
  SELECT id, entry_price
  INTO v_trade_id, v_entry_price
  FROM trades
  WHERE user_id = p_user_id
    AND symbol = p_symbol
    AND side = p_side
    AND exit_price IS NULL
  ORDER BY open_at DESC
  LIMIT 1
  FOR UPDATE SKIP LOCKED;

  IF v_trade_id IS NULL THEN
    RAISE EXCEPTION 'No open trade found';
  END IF;

  IF (p_exit_price > v_entry_price AND p_side = 'LONG') OR
     (p_exit_price < v_entry_price AND p_side = 'SHORT') THEN
    v_outcome := 'WIN';
  ELSE
    v_outcome := 'LOSS';
  END IF;

  UPDATE trades
  SET 
    exit_price = p_exit_price,
    outcome = v_outcome,
    updated_at = NOW()
  WHERE id = v_trade_id;

  RETURN v_trade_id;
END;
$$;

-- Generate TradingView Webhook Secret
CREATE OR REPLACE FUNCTION public.generate_tradingview_webhook()
RETURNS TEXT 
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  secret TEXT;
BEGIN
  secret := encode(gen_random_bytes(32), 'hex');
  
  INSERT INTO public.user_settings (user_id, tradingview_webhook_secret)
  VALUES (auth.uid(), secret)
  ON CONFLICT (user_id) 
  DO UPDATE SET 
    tradingview_webhook_secret = EXCLUDED.tradingview_webhook_secret,
    updated_at = NOW();
  
  RETURN secret;
END;
$$;

-- ===============================================
-- SECTION 10: REFERRAL FUNCTIONS
-- ===============================================

DO $$
BEGIN
  RAISE NOTICE '[10/15] Creating referral functions...';
END $$;

-- Process Referral Signup
CREATE OR REPLACE FUNCTION public.process_referral_signup(
  p_referred_user_id UUID,
  p_referral_code TEXT
)
RETURNS JSONB 
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_referrer_id UUID;
  v_referral_id UUID;
BEGIN
  SELECT id INTO v_referrer_id
  FROM public.profiles
  WHERE affiliate_code = p_referral_code;
  
  IF v_referrer_id IS NULL THEN
    RETURN jsonb_build_object('success', false, 'message', 'Invalid referral code');
  END IF;
  
  IF v_referrer_id = p_referred_user_id THEN
    RETURN jsonb_build_object('success', false, 'message', 'Cannot refer yourself');
  END IF;
  
  IF EXISTS(SELECT 1 FROM public.referrals WHERE referred_id = p_referred_user_id) THEN
    RETURN jsonb_build_object('success', false, 'message', 'User already referred');
  END IF;
  
  UPDATE public.profiles
  SET referred_by = p_referral_code
  WHERE id = p_referred_user_id;
  
  INSERT INTO public.referrals (
    referrer_id, referred_id, referral_code, status, signed_up_at
  ) VALUES (
    v_referrer_id, p_referred_user_id, p_referral_code, 'pending', NOW()
  ) RETURNING id INTO v_referral_id;
  
  UPDATE public.affiliate_stats
  SET 
    total_signups = total_signups + 1,
    last_updated = NOW()
  WHERE user_id = v_referrer_id;
  
  RETURN jsonb_build_object(
    'success', true, 
    'referral_id', v_referral_id, 
    'message', 'Referral recorded successfully'
  );
END;
$$;

-- Complete Referral and Grant Rewards
CREATE OR REPLACE FUNCTION public.complete_referral_and_grant_rewards(
  p_referral_id UUID
)
RETURNS JSONB 
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_referral RECORD;
BEGIN
  SELECT * INTO v_referral 
  FROM public.referrals 
  WHERE id = p_referral_id AND status = 'pending';
  
  IF NOT FOUND THEN
    RETURN jsonb_build_object('success', false, 'message', 'Referral not found or already completed');
  END IF;
  
  IF NOT v_referral.reward_granted_to_referrer THEN
    UPDATE public.profiles
    SET 
      subscription_expires_at = COALESCE(
        CASE WHEN subscription_expires_at > NOW() 
        THEN subscription_expires_at + INTERVAL '1 month'
        ELSE NOW() + INTERVAL '1 month' END, 
        NOW() + INTERVAL '1 month'
      ),
      account_type = CASE WHEN account_type = 'free' THEN 'premium' ELSE account_type END,
      subscription_status = 'active',
      free_months_available = free_months_available + 1,
      referral_count = referral_count + 1
    WHERE id = v_referral.referrer_id;
    
    INSERT INTO public.free_months_credits (
      user_id, months_earned, earned_from_user_id, applied
    ) VALUES (
      v_referral.referrer_id, 1, v_referral.referred_id, true
    );
    
    UPDATE public.affiliate_stats
    SET 
      total_conversions = total_conversions + 1,
      total_free_months_earned = total_free_months_earned + 1,
      last_updated = NOW()
    WHERE user_id = v_referral.referrer_id;
  END IF;
  
  IF NOT v_referral.reward_granted_to_referred THEN
    UPDATE public.profiles
    SET 
      subscription_expires_at = NOW() + INTERVAL '1 month',
      account_type = 'premium',
      subscription_status = 'active',
      trial_ends_at = NOW() + INTERVAL '1 month',
      free_months_available = free_months_available + 1
    WHERE id = v_referral.referred_id;
    
    INSERT INTO public.free_months_credits (
      user_id, months_earned, earned_from_user_id, applied
    ) VALUES (
      v_referral.referred_id, 1, v_referral.referrer_id, true
    );
  END IF;
  
  UPDATE public.referrals
  SET 
    status = 'completed',
    reward_granted_to_referrer = TRUE,
    reward_granted_to_referred = TRUE,
    completed_at = NOW(),
    converted_to_paid = TRUE,
    converted_at = NOW(),
    reward_credited = TRUE,
    credited_at = NOW()
  WHERE id = p_referral_id;
  
  RETURN jsonb_build_object('success', true, 'message', 'Referral completed and rewards granted');
END;
$$;

-- Get User Referral Stats
CREATE OR REPLACE FUNCTION public.get_user_referral_stats(p_user_id UUID DEFAULT NULL)
RETURNS JSON 
LANGUAGE plpgsql
SECURITY DEFINER
STABLE
AS $$
DECLARE
  v_user_id UUID;
  stats JSON;
BEGIN
  v_user_id := COALESCE(p_user_id, auth.uid());
  
  IF v_user_id != auth.uid() AND NOT is_admin() THEN
    RAISE EXCEPTION 'Unauthorized';
  END IF;

  SELECT json_build_object(
    'referral_code', affiliate_code,
    'total_signups', COALESCE((SELECT total_signups FROM public.affiliate_stats WHERE user_id = v_user_id), 0),
    'total_conversions', COALESCE((SELECT total_conversions FROM public.affiliate_stats WHERE user_id = v_user_id), 0),
    'free_months_earned', COALESCE((SELECT total_free_months_earned FROM public.affiliate_stats WHERE user_id = v_user_id), 0),
    'free_months_available', free_months_available,
    'referral_count', referral_count,
    'referred_by', referred_by,
    'pending_referrals', (SELECT COUNT(*) FROM public.referrals WHERE referrer_id = v_user_id AND status = 'pending'),
    'completed_referrals', (SELECT COUNT(*) FROM public.referrals WHERE referrer_id = v_user_id AND status = 'completed')
  ) INTO stats
  FROM public.profiles
  WHERE id = v_user_id;

  RETURN stats;
END;
$$;

-- Get Admin Referral Overview
CREATE OR REPLACE FUNCTION public.get_admin_referral_overview()
RETURNS JSON 
LANGUAGE plpgsql
SECURITY DEFINER
STABLE
AS $$
BEGIN
  IF NOT is_admin() THEN
    RAISE EXCEPTION 'Unauthorized - Admin access required';
  END IF;

  RETURN json_build_object(
    'total_referrals', (SELECT COUNT(*) FROM public.referrals),
    'pending_referrals', (SELECT COUNT(*) FROM public.referrals WHERE status = 'pending'),
    'completed_referrals', (SELECT COUNT(*) FROM public.referrals WHERE status = 'completed'),
    'total_free_months_granted', (SELECT SUM(total_free_months_earned) FROM public.affiliate_stats),
    'active_referrers', (SELECT COUNT(*) FROM public.affiliate_stats WHERE total_signups > 0),
    'total_users_with_referrals', (SELECT COUNT(*) FROM public.profiles WHERE referral_count > 0),
    'top_referrers', (
      SELECT json_agg(row_to_json(t))
      FROM (
        SELECT 
          ast.user_id, 
          p.email, 
          p.display_name as name, 
          p.affiliate_code as code,
          ast.total_signups, 
          ast.total_conversions, 
          ast.total_free_months_earned, 
          p.referral_count
        FROM public.affiliate_stats ast
        JOIN public.profiles p ON p.id = ast.user_id
        WHERE ast.total_signups > 0
        ORDER BY ast.total_conversions DESC, ast.total_signups DESC
        LIMIT 10
      ) t
    )
  );
END;
$$;

-- Increment Affiliate Signups
CREATE OR REPLACE FUNCTION public.increment_affiliate_signups(p_user_id UUID)
RETURNS VOID 
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  UPDATE public.affiliate_stats
  SET total_signups = total_signups + 1, last_updated = NOW()
  WHERE user_id = p_user_id;
  
  IF NOT FOUND THEN
    INSERT INTO public.affiliate_stats (user_id, total_signups, total_conversions, total_free_months_earned)
    VALUES (p_user_id, 1, 0, 0)
    ON CONFLICT (user_id) DO UPDATE
    SET total_signups = public.affiliate_stats.total_signups + 1, last_updated = NOW();
  END IF;
END;
$$;

-- Increment Affiliate Conversions
CREATE OR REPLACE FUNCTION public.increment_affiliate_conversions(p_user_id UUID)
RETURNS VOID 
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  UPDATE public.affiliate_stats
  SET 
    total_conversions = total_conversions + 1,
    total_free_months_earned = total_free_months_earned + 1,
    last_updated = NOW()
  WHERE user_id = p_user_id;
  
  IF NOT FOUND THEN
    INSERT INTO public.affiliate_stats (user_id, total_signups, total_conversions, total_free_months_earned)
    VALUES (p_user_id, 0, 1, 1)
    ON CONFLICT (user_id) DO UPDATE
    SET 
      total_conversions = public.affiliate_stats.total_conversions + 1,
      total_free_months_earned = public.affiliate_stats.total_free_months_earned + 1,
      last_updated = NOW();
  END IF;
END;
$$;

-- Increment Referral Count (ATOMIC)
CREATE OR REPLACE FUNCTION public.increment_referral_count(p_user_id UUID)
RETURNS INTEGER
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_new_count INTEGER;
BEGIN
  UPDATE public.profiles
  SET referral_count = COALESCE(referral_count, 0) + 1
  WHERE id = p_user_id
  RETURNING referral_count INTO v_new_count;
  
  RETURN v_new_count;
END;
$$;

-- Increment Free Months (ATOMIC)
CREATE OR REPLACE FUNCTION public.increment_free_months(p_user_id UUID, p_amount INTEGER)
RETURNS INTEGER
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_new_count INTEGER;
BEGIN
  UPDATE public.profiles
  SET free_months_available = COALESCE(free_months_available, 0) + p_amount
  WHERE id = p_user_id
  RETURNING free_months_available INTO v_new_count;
  
  RETURN v_new_count;
END;
$$;

-- Use Free Month (ATOMIC)
CREATE OR REPLACE FUNCTION public.use_free_month(p_user_id UUID)
RETURNS BOOLEAN
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_available INTEGER;
BEGIN
  UPDATE public.profiles
  SET free_months_available = GREATEST(free_months_available - 1, 0)
  WHERE id = p_user_id
    AND free_months_available > 0
  RETURNING free_months_available INTO v_available;
  
  RETURN FOUND;
END;
$$;

-- ===============================================
-- SECTION 11: ADMIN FUNCTIONS
-- ===============================================

DO $$
BEGIN
  RAISE NOTICE '[11/15] Creating admin functions...';
END $$;

-- Log Admin Action
CREATE OR REPLACE FUNCTION public.log_admin_action(
  p_action TEXT,
  p_target_user_id UUID DEFAULT NULL,
  p_target_type TEXT DEFAULT NULL,
  p_target_id UUID DEFAULT NULL,
  p_details JSONB DEFAULT '{}'::jsonb
)
RETURNS UUID 
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  log_id UUID;
BEGIN
  IF NOT is_admin() THEN
    RAISE EXCEPTION 'Unauthorized - Admin access required';
  END IF;

  INSERT INTO public.admin_audit_log (
    admin_id, action, target_user_id, target_type, target_id, details
  ) VALUES (
    auth.uid(), p_action, p_target_user_id, p_target_type, p_target_id, p_details
  )
  RETURNING id INTO log_id;

  RETURN log_id;
END;
$$;

-- Admin Toggle User Ban
CREATE OR REPLACE FUNCTION public.admin_toggle_user_ban(
  p_user_id UUID,
  p_ban_reason TEXT DEFAULT NULL
)
RETURNS VOID 
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  current_ban_status BOOLEAN;
BEGIN
  IF NOT is_super_admin() THEN
    RAISE EXCEPTION 'Unauthorized - Super Admin access required';
  END IF;

  SELECT is_banned INTO current_ban_status
  FROM public.profiles
  WHERE id = p_user_id;

  UPDATE public.profiles
  SET 
    is_banned = NOT current_ban_status,
    ban_reason = CASE WHEN NOT current_ban_status THEN p_ban_reason ELSE NULL END,
    banned_at = CASE WHEN NOT current_ban_status THEN NOW() ELSE NULL END,
    banned_by = CASE WHEN NOT current_ban_status THEN auth.uid() ELSE NULL END
  WHERE id = p_user_id;

  PERFORM log_admin_action(
    CASE WHEN NOT current_ban_status THEN 'BAN_USER' ELSE 'UNBAN_USER' END,
    p_user_id, 
    'user', 
    p_user_id, 
    jsonb_build_object('reason', p_ban_reason)
  );
END;
$$;

-- ‚úÖ UPDATED v8.4.7: Admin Update Subscription (RETURNS JSONB)
DROP FUNCTION IF EXISTS public.admin_update_subscription(UUID, TEXT, TEXT, TEXT, TIMESTAMPTZ);

CREATE OR REPLACE FUNCTION public.admin_update_subscription(
  p_user_id UUID,
  p_account_type TEXT,
  p_subscription_interval TEXT,
  p_subscription_status TEXT,
  p_subscription_expires_at TIMESTAMPTZ
)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_admin_id UUID;
  v_admin_role TEXT;
  v_max_trades INTEGER;
BEGIN
  -- Verify authentication
  v_admin_id := auth.uid();
  
  IF v_admin_id IS NULL THEN
    RETURN jsonb_build_object('success', false, 'error', 'Not authenticated');
  END IF;
  
  -- Verify admin role
  SELECT role INTO v_admin_role FROM public.profiles WHERE id = v_admin_id;
  
  IF v_admin_role NOT IN ('admin', 'super_admin') THEN
    RETURN jsonb_build_object('success', false, 'error', 'Insufficient permissions');
  END IF;
  
  -- Validate account type
  IF p_account_type NOT IN ('free', 'basic', 'premium', 'trial') THEN
    RETURN jsonb_build_object('success', false, 'error', 'Invalid account type: ' || p_account_type);
  END IF;

  -- Validate subscription interval
  IF p_subscription_interval NOT IN ('monthly', 'yearly') AND p_account_type != 'free' THEN
    RETURN jsonb_build_object('success', false, 'error', 'Invalid subscription interval: ' || p_subscription_interval);
  END IF;

  -- Validate subscription status
  IF p_subscription_status NOT IN ('trial', 'active', 'expired', 'cancelled') THEN
    RETURN jsonb_build_object('success', false, 'error', 'Invalid subscription status: ' || p_subscription_status);
  END IF;
  
  -- Calculate max trades
  v_max_trades := CASE p_account_type
    WHEN 'free' THEN 10
    WHEN 'basic' THEN 25
    WHEN 'premium' THEN 999999
    WHEN 'trial' THEN 25
    ELSE 10
  END;
  
  -- Update profile
  UPDATE public.profiles
  SET 
    account_type = p_account_type,
    subscription_interval = CASE 
      WHEN p_account_type = 'free' THEN NULL 
      ELSE p_subscription_interval 
    END,
    subscription_status = p_subscription_status,
    subscription_expires_at = p_subscription_expires_at,
    max_trades = v_max_trades,
    updated_at = NOW()
  WHERE id = p_user_id;
  
  IF NOT FOUND THEN
    RETURN jsonb_build_object('success', false, 'error', 'User not found');
  END IF;
  
  -- Log admin action
  BEGIN
    PERFORM log_admin_action(
      'UPDATE_SUBSCRIPTION', 
      p_user_id, 
      'subscription', 
      p_user_id,
      jsonb_build_object(
        'account_type', p_account_type,
        'subscription_interval', p_subscription_interval,
        'subscription_status', p_subscription_status,
        'expires_at', p_subscription_expires_at,
        'max_trades', v_max_trades,
        'admin_id', v_admin_id
      )
    );
  EXCEPTION 
    WHEN OTHERS THEN
      NULL; -- Ignore logging errors
  END;
  
  RETURN jsonb_build_object(
    'success', true, 
    'message', 'Subscription updated successfully',
    'data', jsonb_build_object(
      'account_type', p_account_type,
      'max_trades', v_max_trades,
      'expires_at', p_subscription_expires_at
    )
  );
  
EXCEPTION 
  WHEN OTHERS THEN
    RETURN jsonb_build_object('success', false, 'error', SQLERRM);
END;
$$;

COMMENT ON FUNCTION public.admin_update_subscription IS 
'v8.5.0-UPDATED: Returns JSONB with success/error. Uses get_trade_limit() - BASIC/TRIAL = 25 trades';

-- Admin Reset Trade Count
CREATE OR REPLACE FUNCTION public.admin_reset_trade_count(target_user_id UUID)
RETURNS VOID
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  IF NOT is_admin() THEN
    RAISE EXCEPTION 'Unauthorized: Admin access required';
  END IF;

  UPDATE public.profiles
  SET 
    current_month_trades_count = 0,
    billing_cycle_start = CURRENT_DATE
  WHERE id = target_user_id;
  
  PERFORM log_admin_action(
    'RESET_TRADE_COUNT',
    target_user_id,
    'profile',
    target_user_id,
    jsonb_build_object('reset_date', CURRENT_DATE)
  );
END;
$$;

-- ‚úÖ UPDATED v8.4.7: Admin Grant Free Access (REPLACES admin_grant_free_months)
-- Drop old versions to avoid conflicts
DROP FUNCTION IF EXISTS public.admin_grant_free_months(UUID, INTEGER) CASCADE;
DROP FUNCTION IF EXISTS public.admin_grant_free_access(UUID, INTEGER, TEXT) CASCADE;
DROP FUNCTION IF EXISTS public.grant_free_access(UUID, INTEGER, TEXT, UUID) CASCADE;

-- Main function to grant free access
CREATE OR REPLACE FUNCTION public.grant_free_access(
  p_user_id UUID,
  p_months INTEGER,
  p_reason TEXT,
  p_admin_id UUID
)
RETURNS VOID 
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_is_admin BOOLEAN;
BEGIN
  -- Verify admin permissions
  SELECT role IN ('admin', 'super_admin') AND is_banned = FALSE
  INTO v_is_admin
  FROM public.profiles
  WHERE id = p_admin_id;
  
  IF NOT COALESCE(v_is_admin, FALSE) THEN
    RAISE EXCEPTION 'Unauthorized - Admin access required';
  END IF;
  
  -- Update user profile
  UPDATE public.profiles
  SET 
    free_months_available = COALESCE(free_months_available, 0) + p_months,
    subscription_expires_at = CASE
      -- If no active subscription or expired, start from now
      WHEN subscription_expires_at IS NULL OR subscription_expires_at < NOW() 
      THEN NOW() + (p_months || ' months')::INTERVAL
      -- If active subscription, extend it
      ELSE subscription_expires_at + (p_months || ' months')::INTERVAL
    END,
    subscription_status = 'active',
    updated_at = NOW()
  WHERE id = p_user_id;
  
  -- Log the credit
  INSERT INTO public.free_months_credits (
    user_id, 
    months_earned, 
    applied,
    metadata
  ) VALUES (
    p_user_id,
    p_months,
    TRUE,
    jsonb_build_object(
      'granted_by', 'admin',
      'admin_id', p_admin_id,
      'reason', p_reason,
      'granted_at', NOW()
    )
  );
  
  -- Log admin action
  PERFORM log_admin_action(
    'GRANT_FREE_ACCESS',
    p_user_id,
    'free_months',
    p_user_id,
    jsonb_build_object(
      'months_granted', p_months,
      'reason', p_reason,
      'admin_id', p_admin_id
    )
  );
  
  RAISE NOTICE '‚úÖ ◊†◊™◊™◊ô % ◊ó◊ï◊ì◊©/◊ô◊ù ◊ó◊ô◊†◊ù ◊ú◊û◊©◊™◊û◊© %', p_months, p_user_id;
END;
$$;

-- Backward compatibility wrapper
CREATE OR REPLACE FUNCTION public.admin_grant_free_months(
  p_target_user_id UUID, 
  p_months_to_grant INTEGER
)
RETURNS VOID 
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  PERFORM grant_free_access(
    p_target_user_id,
    p_months_to_grant,
    'Admin granted via admin_grant_free_months',
    auth.uid()
  );
END;
$$;

COMMENT ON FUNCTION public.grant_free_access IS 
'v8.5.0: Main function to grant free access. Called by adminService.ts';

COMMENT ON FUNCTION public.admin_grant_free_months IS 
'v8.5.0: Backward compatibility wrapper for grant_free_access';

-- Admin Get Limits Overview
CREATE OR REPLACE FUNCTION public.admin_get_limits_overview()
RETURNS TABLE(
  email TEXT,
  plan TEXT,
  lifetime_trades INTEGER,
  monthly_trades INTEGER,
  max_limit INTEGER,
  can_add BOOLEAN
)
LANGUAGE plpgsql
STABLE
SECURITY DEFINER
AS $$
BEGIN
  IF NOT is_admin() THEN
    RAISE EXCEPTION 'Unauthorized: Admin access required';
  END IF;

  RETURN QUERY
  SELECT 
    p.email,
    p.account_type as plan,
    COALESCE(p.trade_count, 0) as lifetime_trades,
    COALESCE(p.current_month_trades_count, 0) as monthly_trades,
    get_trade_limit(p.account_type) as max_limit,
    can_create_trade(p.id) as can_add
  FROM public.profiles p
  ORDER BY 
    CASE p.account_type
      WHEN 'free' THEN p.trade_count
      ELSE p.current_month_trades_count
    END DESC;
END;
$$;

-- Get Platform Stats
CREATE OR REPLACE FUNCTION public.get_platform_stats()
RETURNS JSON 
LANGUAGE plpgsql
SECURITY DEFINER
STABLE
AS $$
DECLARE
  stats JSON;
  v_basic_monthly INTEGER;
  v_basic_yearly INTEGER;
  v_premium_monthly INTEGER;
  v_premium_yearly INTEGER;
  v_monthly_revenue NUMERIC;
  v_yearly_revenue NUMERIC;
BEGIN
  IF NOT is_admin() THEN
    RAISE EXCEPTION 'Unauthorized - Admin access required';
  END IF;

  SELECT COUNT(*) INTO v_basic_monthly
  FROM public.profiles 
  WHERE account_type = 'basic' AND subscription_interval = 'monthly';
  
  SELECT COUNT(*) INTO v_basic_yearly
  FROM public.profiles 
  WHERE account_type = 'basic' AND subscription_interval = 'yearly';
  
  SELECT COUNT(*) INTO v_premium_monthly
  FROM public.profiles 
  WHERE account_type = 'premium' AND subscription_interval = 'monthly';
  
  SELECT COUNT(*) INTO v_premium_yearly
  FROM public.profiles 
  WHERE account_type = 'premium' AND subscription_interval = 'yearly';

 v_monthly_revenue := 
  (v_basic_monthly * 19.99) + 
  (v_basic_yearly * 12.42) +  -- 149/12 = 12.42
  (v_premium_monthly * 39.99) + 
  (v_premium_yearly * 24.92);  -- 299/12 = 24.92
    
  v_yearly_revenue := v_monthly_revenue * 12;

  SELECT json_build_object(
    'total_users', (SELECT COUNT(*) FROM public.profiles),
    'active_users', (SELECT COUNT(*) FROM public.profiles WHERE last_login_at > NOW() - INTERVAL '30 days'),
    'free_users', (SELECT COUNT(*) FROM public.profiles WHERE account_type = 'free'),
    'basic_users', (SELECT COUNT(*) FROM public.profiles WHERE account_type = 'basic'),
    'premium_users', (SELECT COUNT(*) FROM public.profiles WHERE account_type = 'premium'),
    'trial_users', (SELECT COUNT(*) FROM public.profiles WHERE subscription_status = 'trial'),
    'banned_users', (SELECT COUNT(*) FROM public.profiles WHERE is_banned = true),
    'basic_monthly_subscribers', v_basic_monthly,
    'basic_yearly_subscribers', v_basic_yearly,
    'premium_monthly_subscribers', v_premium_monthly,
    'premium_yearly_subscribers', v_premium_yearly,
    'estimated_monthly_revenue', v_monthly_revenue,
    'estimated_yearly_revenue', v_yearly_revenue,
    'total_trades', (SELECT COUNT(*) FROM public.trades),
    'trades_today', (SELECT COUNT(*) FROM public.trades WHERE created_at::date = CURRENT_DATE),
    'trades_this_week', (SELECT COUNT(*) FROM public.trades WHERE created_at > NOW() - INTERVAL '7 days'),
    'trades_this_month', (SELECT COUNT(*) FROM public.trades WHERE DATE_TRUNC('month', created_at) = DATE_TRUNC('month', CURRENT_DATE)),
    'total_strategies', (SELECT COUNT(*) FROM public.strategies),
    'new_users_today', (SELECT COUNT(*) FROM public.profiles WHERE created_at::date = CURRENT_DATE),
    'new_users_this_week', (SELECT COUNT(*) FROM public.profiles WHERE created_at > NOW() - INTERVAL '7 days'),
    'new_users_this_month', (SELECT COUNT(*) FROM public.profiles WHERE DATE_TRUNC('month', created_at) = DATE_TRUNC('month', CURRENT_DATE))
  ) INTO stats;

  RETURN stats;
END;
$$;

-- Get User Detailed Stats
CREATE OR REPLACE FUNCTION public.get_user_detailed_stats(p_user_id UUID)
RETURNS JSON 
LANGUAGE plpgsql
SECURITY DEFINER
STABLE
AS $$
DECLARE
  stats JSON;
BEGIN
  IF NOT is_admin() THEN
    RAISE EXCEPTION 'Unauthorized - Admin access required';
  END IF;

  SELECT json_build_object(
    'user_id', p_user_id,
    'total_trades', (SELECT COUNT(*) FROM public.trades WHERE user_id = p_user_id),
    'total_strategies', (SELECT COUNT(*) FROM public.strategies WHERE user_id = p_user_id),
    'win_rate', (
      SELECT CASE WHEN COUNT(*) > 0 THEN 
        ROUND((COUNT(*) FILTER (WHERE outcome = 'WIN')::NUMERIC / COUNT(*)::NUMERIC) * 100, 2)
      ELSE 0 END
      FROM public.trades 
      WHERE user_id = p_user_id AND outcome IN ('WIN', 'LOSS')
    ),
    'total_pnl', (SELECT COALESCE(SUM(pnl), 0) FROM public.trades WHERE user_id = p_user_id),
    'avg_pnl', (SELECT COALESCE(AVG(pnl), 0) FROM public.trades WHERE user_id = p_user_id),
    'best_trade', (SELECT MAX(pnl) FROM public.trades WHERE user_id = p_user_id),
    'worst_trade', (SELECT MIN(pnl) FROM public.trades WHERE user_id = p_user_id),
    'first_trade_date', (SELECT MIN(open_at) FROM public.trades WHERE user_id = p_user_id),
    'last_trade_date', (SELECT MAX(open_at) FROM public.trades WHERE user_id = p_user_id),
    'most_traded_symbol', (
      SELECT symbol FROM public.trades WHERE user_id = p_user_id 
      GROUP BY symbol ORDER BY COUNT(*) DESC LIMIT 1
    )
  ) INTO stats;

  RETURN stats;
END;
$$;

-- Get Subscription Breakdown
CREATE OR REPLACE FUNCTION public.get_subscription_breakdown()
RETURNS TABLE (
  account_type TEXT,
  subscription_interval TEXT,
  user_count BIGINT,
  percentage NUMERIC,
  monthly_revenue NUMERIC
) 
LANGUAGE plpgsql
SECURITY DEFINER
STABLE
AS $$
BEGIN
  IF NOT is_admin() THEN
    RAISE EXCEPTION 'Unauthorized - Admin access required';
  END IF;

  RETURN QUERY
  WITH total_users AS (
    SELECT COUNT(*)::NUMERIC as total FROM public.profiles
  ),
  breakdown AS (
    SELECT 
      p.account_type,
      COALESCE(p.subscription_interval, 'none') as subscription_interval,
      COUNT(*) as user_count,
CASE 
  WHEN p.account_type = 'basic' AND p.subscription_interval = 'monthly' THEN 19.99
  WHEN p.account_type = 'basic' AND p.subscription_interval = 'yearly' THEN 12.42
  WHEN p.account_type = 'premium' AND p.subscription_interval = 'monthly' THEN 39.99
  WHEN p.account_type = 'premium' AND p.subscription_interval = 'yearly' THEN 24.92
  ELSE 0
END as monthly_price
    FROM public.profiles p
    GROUP BY p.account_type, p.subscription_interval
  )
  SELECT 
    b.account_type,
    b.subscription_interval,
    b.user_count,
    ROUND((b.user_count::NUMERIC / t.total * 100), 2) as percentage,
    ROUND((b.user_count * b.monthly_price), 2) as monthly_revenue
  FROM breakdown b
  CROSS JOIN total_users t
  ORDER BY b.account_type, b.subscription_interval;
END;
$$;

-- Get Revenue Analytics
CREATE OR REPLACE FUNCTION public.get_revenue_analytics(p_days INTEGER DEFAULT 30)
RETURNS TABLE (
  date DATE,
  basic_monthly_count INTEGER,
  basic_yearly_count INTEGER,
  premium_monthly_count INTEGER,
  premium_yearly_count INTEGER,
  daily_revenue NUMERIC,
  cumulative_revenue NUMERIC
) 
LANGUAGE plpgsql
SECURITY DEFINER
STABLE
AS $$
DECLARE
  v_start_date DATE;
BEGIN
  IF NOT is_admin() THEN
    RAISE EXCEPTION 'Unauthorized - Admin access required';
  END IF;

  v_start_date := CURRENT_DATE - p_days;

  RETURN QUERY
  WITH RECURSIVE date_series AS (
    SELECT v_start_date as date
    UNION ALL
    SELECT (date + 1)::DATE FROM date_series WHERE date < CURRENT_DATE
  ),
  daily_stats AS (
    SELECT 
      ds.date,
      COUNT(*) FILTER (WHERE p.account_type = 'basic' AND p.subscription_interval = 'monthly') as basic_monthly,
      COUNT(*) FILTER (WHERE p.account_type = 'basic' AND p.subscription_interval = 'yearly') as basic_yearly,
      COUNT(*) FILTER (WHERE p.account_type = 'premium' AND p.subscription_interval = 'monthly') as premium_monthly,
      COUNT(*) FILTER (WHERE p.account_type = 'premium' AND p.subscription_interval = 'yearly') as premium_yearly
    FROM date_series ds
    LEFT JOIN public.profiles p ON p.subscription_started_at::DATE <= ds.date 
      AND (p.subscription_expires_at IS NULL OR p.subscription_expires_at::DATE >= ds.date)
      AND p.account_type IN ('basic', 'premium')
    GROUP BY ds.date
  )
  SELECT 
    ds.date,
    ds.basic_monthly::INTEGER,
    ds.basic_yearly::INTEGER,
    ds.premium_monthly::INTEGER,
    ds.premium_yearly::INTEGER,
((ds.basic_monthly * 19.99) + (ds.basic_yearly * 12.42) + 
     (ds.premium_monthly * 39.99) + (ds.premium_yearly * 24.92))::NUMERIC as daily_revenue,
    SUM((ds.basic_monthly * 19.99) + (ds.basic_yearly * 12.42) +
        (ds.premium_monthly * 39.99) + (ds.premium_yearly * 24.92)) 
    OVER (ORDER BY ds.date)::NUMERIC as cumulative_revenue
  FROM daily_stats ds
  ORDER BY ds.date;
END;
$$;

-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
-- ADMIN IMPERSONATION FUNCTIONS
-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

DO $$
BEGIN
  RAISE NOTICE '';
  RAISE NOTICE '[11.5/15] üîß Creating impersonation functions...';
END $$;

CREATE OR REPLACE FUNCTION public.start_impersonation_session_v1(
  p_user_id UUID,
  p_admin_email TEXT
)
RETURNS TABLE (
  access_token TEXT,
  refresh_token TEXT,
  user_data JSONB
)
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_admin_id UUID;
  v_session_token TEXT;
  v_impersonated_user RECORD;
BEGIN
  -- Verify admin
  SELECT id INTO v_admin_id
  FROM public.profiles
  WHERE email = p_admin_email
    AND role IN ('admin', 'super_admin')
    AND is_banned = FALSE;
  
  IF v_admin_id IS NULL THEN
    RAISE EXCEPTION 'Unauthorized: Must be admin';
  END IF;
  
  -- Get target user info
  SELECT 
    p.id,
    p.email,
    p.display_name,
    p.role,
    p.account_type
  INTO v_impersonated_user
  FROM public.profiles p
  WHERE p.id = p_user_id;
  
  IF v_impersonated_user.id IS NULL THEN
    RAISE EXCEPTION 'User not found: %', p_user_id;
  END IF;
  
  -- Cannot impersonate other admins
  IF v_impersonated_user.role IN ('admin', 'super_admin') THEN
    RAISE EXCEPTION 'Cannot impersonate other admins';
  END IF;
  
  -- Generate session token
  v_session_token := encode(gen_random_bytes(32), 'hex');
  
  -- Create impersonation session
  INSERT INTO public.admin_impersonation_sessions (
    admin_id,
    impersonated_user_id,
    session_token,
    expires_at,
    impersonated_user_email,
    impersonated_user_name,
    admin_email,
    is_active
  ) VALUES (
    v_admin_id,
    p_user_id,
    v_session_token,
    NOW() + INTERVAL '2 hours',
    v_impersonated_user.email,
    COALESCE(v_impersonated_user.display_name, v_impersonated_user.email),
    p_admin_email,
    TRUE
  );
  
  -- Log action
  BEGIN
    PERFORM public.log_admin_action(
      'START_IMPERSONATION',
      p_user_id,
      'impersonation_session',
      p_user_id,
      jsonb_build_object(
        'impersonated_email', v_impersonated_user.email,
        'session_token', v_session_token
      )
    );
  EXCEPTION 
    WHEN undefined_function THEN
      NULL;
    WHEN OTHERS THEN
      RAISE WARNING 'Failed to log impersonation action: %', SQLERRM;
  END;
  
  -- Return fake tokens (for UI only)
  RETURN QUERY SELECT
    v_session_token::TEXT as access_token,
    v_session_token::TEXT as refresh_token,
    jsonb_build_object(
      'id', v_impersonated_user.id,
      'email', v_impersonated_user.email,
      'display_name', COALESCE(v_impersonated_user.display_name, v_impersonated_user.email),
      'role', v_impersonated_user.role,
      'account_type', v_impersonated_user.account_type,
      'impersonated', TRUE,
      'impersonated_by', p_admin_email
    ) as user_data;
END;
$$;

CREATE OR REPLACE FUNCTION public.end_impersonation_session(
  p_session_token TEXT
)
RETURNS BOOLEAN
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_session RECORD;
BEGIN
  -- Get session
  SELECT 
    admin_id,
    impersonated_user_id,
    is_active
  INTO v_session
  FROM public.admin_impersonation_sessions
  WHERE session_token = p_session_token;
  
  IF v_session.admin_id IS NULL THEN
    RETURN FALSE;
  END IF;
  
  -- Verify caller
  IF v_session.admin_id != auth.uid() THEN
    RAISE EXCEPTION 'Unauthorized: Only the admin who started impersonation can end it';
  END IF;
  
  -- End session
  UPDATE public.admin_impersonation_sessions
  SET 
    is_active = FALSE,
    last_activity_at = NOW()
  WHERE session_token = p_session_token;
  
  -- Log action
  PERFORM public.log_admin_action(
    'END_IMPERSONATION',
    v_session.impersonated_user_id,
    'impersonation_session',
    v_session.impersonated_user_id,
    jsonb_build_object('session_token', p_session_token)
  );
  
  RETURN TRUE;
END;
$$;

CREATE OR REPLACE FUNCTION public.get_active_impersonation_sessions()
RETURNS TABLE (
  id UUID,
  admin_email TEXT,
  impersonated_user_email TEXT,
  impersonated_user_name TEXT,
  created_at TIMESTAMPTZ,
  expires_at TIMESTAMPTZ,
  last_activity_at TIMESTAMPTZ
)
LANGUAGE plpgsql
SECURITY DEFINER
STABLE
AS $$
BEGIN
  IF NOT public.is_admin() THEN
    RAISE EXCEPTION 'Unauthorized: Admin access required';
  END IF;
  
  RETURN QUERY
  SELECT 
    s.id,
    s.admin_email,
    s.impersonated_user_email,
    s.impersonated_user_name,
    s.created_at,
    s.expires_at,
    s.last_activity_at
  FROM public.admin_impersonation_sessions s
  WHERE s.is_active = TRUE
    AND s.expires_at > NOW()
  ORDER BY s.created_at DESC;
END;
$$;

-- Grant permissions
GRANT EXECUTE ON FUNCTION public.start_impersonation_session_v1 TO authenticated;
GRANT EXECUTE ON FUNCTION public.end_impersonation_session TO authenticated;
GRANT EXECUTE ON FUNCTION public.get_active_impersonation_sessions TO authenticated;

COMMENT ON FUNCTION public.start_impersonation_session_v1 IS 
'üîß v8.5.0: Allows admins to impersonate users. Returns session token.';

-- ===============================================
-- SECTION 12: ACTIVITY TRACKING
-- ===============================================

DO $$
BEGIN
  RAISE NOTICE '[12/15] Creating activity tracking functions...';
END $$;

-- Update User Login Stats
CREATE OR REPLACE FUNCTION public.update_user_login_stats()
RETURNS TRIGGER 
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  UPDATE public.profiles
  SET 
    last_login_at = NOW(),
    login_count = COALESCE(login_count, 0) + 1
  WHERE id = NEW.user_id;
  
  RETURN NEW;
END;
$$;

-- Get Broker Status
CREATE OR REPLACE FUNCTION public.get_broker_status(p_broker TEXT)
RETURNS JSON 
LANGUAGE plpgsql
SECURITY DEFINER
STABLE
AS $$
DECLARE
  connection_status JSON;
BEGIN
  SELECT json_build_object(
    'broker', broker,
    'status', status,
    'connected_at', connected_at,
    'last_sync_at', last_sync_at,
    'account_name', account_name,
    'error_message', error_message
  ) INTO connection_status
  FROM public.broker_connections
  WHERE user_id = auth.uid() AND broker = p_broker;
  
  RETURN COALESCE(connection_status, json_build_object('status', 'disconnected'));
END;
$$;

-- Get Trades by Broker
CREATE OR REPLACE FUNCTION public.get_trades_by_broker()
RETURNS JSON 
LANGUAGE plpgsql
SECURITY DEFINER
STABLE
AS $$
DECLARE
  broker_stats JSON;
BEGIN
  SELECT json_object_agg(broker, trade_count) INTO broker_stats
  FROM (
    SELECT broker, COUNT(*) as trade_count
    FROM public.trades
    WHERE user_id = auth.uid()
    GROUP BY broker
  ) stats;
  
  RETURN COALESCE(broker_stats, '{}'::json);
END;
$$;

-- Admin Get Broker Stats
CREATE OR REPLACE FUNCTION public.admin_get_broker_stats()
RETURNS JSON 
LANGUAGE plpgsql
SECURITY DEFINER
STABLE
AS $$
BEGIN
  IF NOT is_admin() THEN
    RAISE EXCEPTION 'Unauthorized - Admin access required';
  END IF;

  RETURN (
    SELECT json_build_object(
      'total_connections', COUNT(*),
      'active_connections', COUNT(*) FILTER (WHERE status = 'connected'),
      'by_broker', (
        SELECT json_object_agg(broker, count)
        FROM (
          SELECT broker, COUNT(*) as count
          FROM public.broker_connections
          GROUP BY broker
        ) broker_counts
      ),
      'recent_syncs', (
        SELECT json_agg(
          json_build_object(
            'user_id', user_id,
            'broker', broker,
            'last_sync_at', last_sync_at,
            'status', status
          )
        )
        FROM (
          SELECT user_id, broker, last_sync_at, status
          FROM public.broker_connections
          WHERE last_sync_at IS NOT NULL
          ORDER BY last_sync_at DESC
          LIMIT 10
        ) recent
      )
    )
    FROM public.broker_connections
  );
END;
$$;

-- ===============================================
-- SECTION 13: ALL TRIGGERS + RLS
-- ===============================================

DO $$
BEGIN
  RAISE NOTICE '[13/15] Creating ALL triggers + RLS...';
END $$;

-- Profile triggers
DROP TRIGGER IF EXISTS trigger_initialize_risk_settings ON public.profiles;
CREATE TRIGGER trigger_initialize_risk_settings
  BEFORE INSERT ON public.profiles
  FOR EACH ROW
  EXECUTE FUNCTION public.initialize_risk_settings();

DROP TRIGGER IF EXISTS set_updated_at ON public.profiles;
CREATE TRIGGER set_updated_at 
  BEFORE UPDATE ON public.profiles
  FOR EACH ROW 
  EXECUTE FUNCTION public.handle_updated_at();

-- Auth trigger
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW
  EXECUTE FUNCTION public.handle_new_user();

-- Trades - UNIFIED TRIGGER ONLY!
-- (Old triggers already dropped in Section 1)

-- Search vector trigger
DROP TRIGGER IF EXISTS trades_search_vector_update ON public.trades;
CREATE TRIGGER trades_search_vector_update
  BEFORE INSERT OR UPDATE OF notes, setup, mistake, symbol
  ON public.trades
  FOR EACH ROW
  EXECUTE FUNCTION public.update_trades_search_vector();

DROP TRIGGER IF EXISTS set_updated_at ON public.trades;
CREATE TRIGGER set_updated_at 
  BEFORE UPDATE ON public.trades
  FOR EACH ROW 
  EXECUTE FUNCTION public.handle_updated_at();

-- Strategies trigger
DROP TRIGGER IF EXISTS set_updated_at ON public.strategies;
CREATE TRIGGER set_updated_at 
  BEFORE UPDATE ON public.strategies
  FOR EACH ROW 
  EXECUTE FUNCTION public.handle_updated_at();

-- Payment trigger
DROP TRIGGER IF EXISTS on_payment_completed ON public.payment_history;
CREATE TRIGGER on_payment_completed
  AFTER INSERT OR UPDATE ON public.payment_history
  FOR EACH ROW
  EXECUTE FUNCTION public.update_account_type_on_payment();

-- Activity trigger
DROP TRIGGER IF EXISTS trigger_update_login_stats ON public.user_activity_log;
CREATE TRIGGER trigger_update_login_stats
  AFTER INSERT ON public.user_activity_log
  FOR EACH ROW 
  WHEN (NEW.action = 'LOGIN')
  EXECUTE FUNCTION update_user_login_stats();

-- Broker connections trigger
DROP TRIGGER IF EXISTS trigger_broker_connection_updated_at ON public.broker_connections;
CREATE TRIGGER trigger_broker_connection_updated_at
  BEFORE UPDATE ON public.broker_connections
  FOR EACH ROW 
  EXECUTE FUNCTION update_timestamp();

-- User settings trigger
DROP TRIGGER IF EXISTS trigger_user_settings_updated_at ON public.user_settings;
CREATE TRIGGER trigger_user_settings_updated_at
  BEFORE UPDATE ON public.user_settings
  FOR EACH ROW 
  EXECUTE FUNCTION update_timestamp();

-- SnapTrade activity trigger
DROP TRIGGER IF EXISTS update_snaptrade_activity_updated_at_trigger ON public.snaptrade_activity;
CREATE TRIGGER update_snaptrade_activity_updated_at_trigger
  BEFORE UPDATE ON public.snaptrade_activity
  FOR EACH ROW
  EXECUTE FUNCTION update_timestamp();

-- ===============================================
-- üÜï SECTION 14: HELPER FUNCTIONS FOR ADMIN MAINTENANCE
-- ===============================================

DO $$
BEGIN
  RAISE NOTICE '';
  RAISE NOTICE '[14/15] Creating helper functions for admin maintenance...';
END $$;

-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
-- 1. ◊®◊¢◊†◊ï◊ü ◊ô◊ì◊†◊ô ◊©◊ú Webhook Stats
-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

CREATE OR REPLACE FUNCTION public.refresh_webhook_stats()
RETURNS TEXT
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  IF NOT public.is_admin() THEN
    RAISE EXCEPTION 'Unauthorized - Admin access required';
  END IF;
  
  REFRESH MATERIALIZED VIEW CONCURRENTLY public.webhook_stats;
  
  RETURN 'Webhook stats refreshed successfully';
END;
$$;

COMMENT ON FUNCTION public.refresh_webhook_stats IS 
'v8.5.0: Manually refresh webhook statistics materialized view (admin only)';

-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
-- 2. ◊®◊¢◊†◊ï◊ü ◊ô◊ì◊†◊ô ◊©◊ú Strategy Stats
-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

CREATE OR REPLACE FUNCTION public.refresh_strategy_stats()
RETURNS TEXT
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  IF NOT public.is_admin() THEN
    RAISE EXCEPTION 'Unauthorized - Admin access required';
  END IF;
  
  REFRESH MATERIALIZED VIEW CONCURRENTLY public.strategy_stats_view;
  
  RETURN 'Strategy stats refreshed successfully';
END;
$$;

COMMENT ON FUNCTION public.refresh_strategy_stats IS 
'v8.5.0: Manually refresh strategy statistics materialized view (admin only)';

-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
-- 3. ◊®◊¢◊†◊ï◊ü ◊õ◊ú ◊î◊û◊ò◊®◊ô◊ê◊ú◊ô◊ô◊ñ◊ì ◊ï◊ô◊ï◊ñ
-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

CREATE OR REPLACE FUNCTION public.refresh_all_materialized_views()
RETURNS TEXT
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  IF NOT public.is_admin() THEN
    RAISE EXCEPTION 'Unauthorized - Admin access required';
  END IF;
  
  REFRESH MATERIALIZED VIEW CONCURRENTLY public.webhook_stats;
  REFRESH MATERIALIZED VIEW CONCURRENTLY public.strategy_stats_view;
  
  RETURN 'All materialized views refreshed successfully';
END;
$$;

COMMENT ON FUNCTION public.refresh_all_materialized_views IS 
'v8.5.0: Refresh all materialized views in one call (admin only)';

-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
-- 4. ◊í◊ï◊ì◊ú ◊û◊°◊ì ◊î◊†◊™◊ï◊†◊ô◊ù
-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

CREATE OR REPLACE FUNCTION public.get_database_size()
RETURNS TABLE (
  total_size_mb NUMERIC,
  total_size_gb NUMERIC
)
LANGUAGE plpgsql
SECURITY DEFINER
STABLE
AS $$
BEGIN
  IF NOT public.is_admin() THEN
    RAISE EXCEPTION 'Unauthorized - Admin access required';
  END IF;
  
  RETURN QUERY
  SELECT 
    ROUND(pg_database_size(current_database())::NUMERIC / 1048576, 2) as total_size_mb,
    ROUND(pg_database_size(current_database())::NUMERIC / 1073741824, 2) as total_size_gb;
END;
$$;

COMMENT ON FUNCTION public.get_database_size IS 
'v8.5.0: Get total database size in MB and GB (admin only)';

-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
-- 5. ◊í◊ï◊ì◊ú ◊ò◊ë◊ú◊ê◊ï◊™
-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

CREATE OR REPLACE FUNCTION public.get_table_sizes()
RETURNS TABLE (
  table_name TEXT,
  size_mb NUMERIC,
  row_count BIGINT
)
LANGUAGE plpgsql
SECURITY DEFINER
STABLE
AS $$
BEGIN
  IF NOT public.is_admin() THEN
    RAISE EXCEPTION 'Unauthorized - Admin access required';
  END IF;
  
  RETURN QUERY
  SELECT 
    t.table_name::TEXT,
    ROUND(pg_total_relation_size(quote_ident(t.table_schema)||'.'||quote_ident(t.table_name))::NUMERIC / 1048576, 2) as size_mb,
    (xpath('/row/cnt/text()', 
      query_to_xml(format('SELECT COUNT(*) as cnt FROM %I.%I', t.table_schema, t.table_name), 
      false, true, '')))[1]::text::BIGINT as row_count
  FROM information_schema.tables t
  WHERE t.table_schema = 'public'
    AND t.table_type = 'BASE TABLE'
  ORDER BY pg_total_relation_size(quote_ident(t.table_schema)||'.'||quote_ident(t.table_name)) DESC;
END;
$$;

COMMENT ON FUNCTION public.get_table_sizes IS 
'v8.5.0: Get size and row count for all tables (admin only)';

-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
-- 6. ◊©◊ê◊ô◊ú◊™◊ï◊™ ◊ê◊ô◊ò◊ô◊ï◊™
-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

CREATE OR REPLACE FUNCTION public.get_slow_queries(limit_count INTEGER DEFAULT 10)
RETURNS TABLE (
  query TEXT,
  mean_time_ms NUMERIC,
  calls BIGINT,
  total_time_ms NUMERIC
)
LANGUAGE plpgsql
SECURITY DEFINER
STABLE
AS $$
BEGIN
  IF NOT public.is_admin() THEN
    RAISE EXCEPTION 'Unauthorized - Admin access required';
  END IF;
  
  RETURN QUERY
  SELECT 
    query::TEXT,
    ROUND(mean_exec_time::NUMERIC, 2) as mean_time_ms,
    calls::BIGINT,
    ROUND(total_exec_time::NUMERIC, 2) as total_time_ms
  FROM pg_stat_statements
  WHERE query NOT LIKE '%pg_stat_statements%'
  ORDER BY mean_exec_time DESC
  LIMIT limit_count;
END;
$$;

COMMENT ON FUNCTION public.get_slow_queries IS 
'v8.5.0: Get slowest queries for performance monitoring (admin only)';

-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
-- 7. ◊ë◊ì◊ô◊ß◊™ ◊ë◊®◊ô◊ê◊ï◊™ ◊î◊û◊¢◊®◊õ◊™
-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

CREATE OR REPLACE FUNCTION public.check_system_health()
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
STABLE
AS $$
DECLARE
  v_result JSONB;
  v_db_size NUMERIC;
  v_max_connections INTEGER;
  v_current_connections INTEGER;
BEGIN
  IF NOT public.is_admin() THEN
    RAISE EXCEPTION 'Unauthorized - Admin access required';
  END IF;
  
  -- ◊í◊ï◊ì◊ú DB
  SELECT pg_database_size(current_database())::NUMERIC / 1073741824 INTO v_db_size;
  
  -- ◊ó◊ô◊ë◊ï◊®◊ô◊ù
  SELECT setting::INTEGER INTO v_max_connections FROM pg_settings WHERE name = 'max_connections';
  SELECT COUNT(*)::INTEGER INTO v_current_connections FROM pg_stat_activity;
  
  v_result := jsonb_build_object(
    'database', jsonb_build_object(
      'status', CASE WHEN v_db_size < 8 THEN 'healthy' ELSE 'warning' END,
      'size_gb', ROUND(v_db_size, 2),
      'max_size_gb', 10
    ),
    'connections', jsonb_build_object(
      'status', CASE WHEN v_current_connections < (v_max_connections * 0.8) THEN 'healthy' ELSE 'warning' END,
      'current', v_current_connections,
      'max', v_max_connections
    ),
    'rls', jsonb_build_object(
      'status', 'healthy',
      'enabled_tables', (SELECT COUNT(*) FROM pg_tables WHERE schemaname = 'public' AND rowsecurity = true)
    ),
    'functions', jsonb_build_object(
      'status', 'healthy',
      'total', (SELECT COUNT(*) FROM pg_proc p JOIN pg_namespace n ON p.pronamespace = n.oid WHERE n.nspname = 'public')
    ),
    'materialized_views', jsonb_build_object(
      'status', 'healthy',
      'total', (SELECT COUNT(*) FROM pg_matviews WHERE schemaname = 'public')
    )
  );
  
  RETURN v_result;
END;
$$;

COMMENT ON FUNCTION public.check_system_health IS 
'v8.5.0: Comprehensive system health check returning status for DB, connections, RLS, etc. (admin only)';

-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
-- 8. ◊†◊ô◊ß◊ï◊ô ◊†◊™◊ï◊†◊ô◊ù ◊ô◊©◊†◊ô◊ù (◊ô◊ì◊†◊ô)
-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

CREATE OR REPLACE FUNCTION public.manual_cleanup_old_data()
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_rate_limits_deleted INTEGER;
  v_sessions_deactivated INTEGER;
  v_logs_archived INTEGER;
BEGIN
  IF NOT public.is_admin() THEN
    RAISE EXCEPTION 'Unauthorized - Admin access required';
  END IF;
  
  -- ◊†◊ô◊ß◊ï◊ô rate limits
  DELETE FROM api_rate_limits 
  WHERE window_start < NOW() - INTERVAL '24 hours';
  GET DIAGNOSTICS v_rate_limits_deleted = ROW_COUNT;
  
  -- ◊°◊í◊ô◊®◊™ sessions
  UPDATE admin_impersonation_sessions 
  SET is_active = false 
  WHERE expires_at < NOW() AND is_active = true;
  GET DIAGNOSTICS v_sessions_deactivated = ROW_COUNT;
  
  -- ◊ê◊®◊õ◊ï◊ë logs
  DELETE FROM admin_audit_log 
  WHERE created_at < NOW() - INTERVAL '1 year';
  GET DIAGNOSTICS v_logs_archived = ROW_COUNT;
  
  RETURN jsonb_build_object(
    'rate_limits_deleted', v_rate_limits_deleted,
    'sessions_deactivated', v_sessions_deactivated,
    'logs_archived', v_logs_archived,
    'timestamp', NOW()
  );
END;
$$;

COMMENT ON FUNCTION public.manual_cleanup_old_data IS 
'v8.5.0: Manual cleanup of old data - rate limits (24h), inactive sessions, old logs (1y) (admin only)';

-- ===============================================
-- üî• SECTION 15: SNAPTRADE FUNCTIONS
-- ===============================================

DO $$
BEGIN
  RAISE NOTICE '';
  RAISE NOTICE '[15/15] üî• Creating SnapTrade integration functions...';
END $$;

-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
-- 15.1: Check SnapTrade Connection Status
-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

DROP FUNCTION IF EXISTS public.is_snaptrade_connected(UUID) CASCADE;

CREATE OR REPLACE FUNCTION public.is_snaptrade_connected(p_user_id UUID)
RETURNS BOOLEAN
LANGUAGE plpgsql
SECURITY DEFINER
STABLE
AS $$
BEGIN
  RETURN EXISTS (
    SELECT 1 FROM snaptrade_users 
    WHERE user_id = p_user_id
  );
END;
$$;

COMMENT ON FUNCTION public.is_snaptrade_connected IS 
'v8.5.0: Check if user has SnapTrade connected';

-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
-- 15.2: Get User Sync Statistics
-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

DROP FUNCTION IF EXISTS public.get_user_sync_stats(UUID) CASCADE;

CREATE OR REPLACE FUNCTION public.get_user_sync_stats(p_user_id UUID)
RETURNS TABLE (
  total_syncs BIGINT,
  successful_syncs BIGINT,
  failed_syncs BIGINT,
  total_trades_imported BIGINT,
  last_sync_at TIMESTAMPTZ,
  last_sync_status TEXT
)
LANGUAGE plpgsql
SECURITY DEFINER
STABLE
AS $$
BEGIN
  RETURN QUERY
  SELECT 
    COUNT(*)::BIGINT as total_syncs,
    COUNT(*) FILTER (WHERE status = 'completed')::BIGINT as successful_syncs,
    COUNT(*) FILTER (WHERE status = 'failed')::BIGINT as failed_syncs,
    COALESCE(SUM(trades_imported), 0)::BIGINT as total_trades_imported,
    MAX(sync_completed_at) as last_sync_at,
    (
      SELECT status FROM snaptrade_sync_log 
      WHERE user_id = p_user_id 
      ORDER BY created_at DESC 
      LIMIT 1
    )::TEXT as last_sync_status
  FROM snaptrade_sync_log
  WHERE user_id = p_user_id;
END;
$$;

COMMENT ON FUNCTION public.get_user_sync_stats IS 
'v8.5.0: Get comprehensive sync statistics for user';

-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
-- 15.3: Get Latest Sync for User
-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

DROP FUNCTION IF EXISTS public.get_latest_sync_for_user(UUID) CASCADE;

CREATE OR REPLACE FUNCTION public.get_latest_sync_for_user(p_user_id UUID)
RETURNS TABLE (
  id UUID,
  status TEXT,
  sync_started_at TIMESTAMPTZ,
  sync_completed_at TIMESTAMPTZ,
  trades_imported INTEGER,
  error_message TEXT,
  sync_type TEXT,
  duration_seconds INTEGER
)
LANGUAGE plpgsql
SECURITY DEFINER
STABLE
AS $$
BEGIN
  RETURN QUERY
  SELECT 
    ssl.id,
    ssl.status::TEXT,
    ssl.sync_started_at,
    ssl.sync_completed_at,
    ssl.trades_imported,
    ssl.error_message,
    ssl.sync_type::TEXT,
    ssl.duration_seconds
  FROM snaptrade_sync_log ssl
  WHERE ssl.user_id = p_user_id
  ORDER BY ssl.created_at DESC
  LIMIT 1;
END;
$$;

COMMENT ON FUNCTION public.get_latest_sync_for_user IS 
'v8.5.0: Get most recent sync log entry for user';

-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
-- 15.4: Get SnapTrade Import Statistics
-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

DROP FUNCTION IF EXISTS public.get_snaptrade_import_stats(UUID, DATE, DATE) CASCADE;

CREATE OR REPLACE FUNCTION public.get_snaptrade_import_stats(
  p_user_id UUID,
  p_start_date DATE DEFAULT NULL,
  p_end_date DATE DEFAULT NULL
)
RETURNS TABLE (
  total_imported BIGINT,
  by_symbol JSONB,
  by_side JSONB,
  by_account JSONB,
  date_range JSONB
)
LANGUAGE plpgsql
SECURITY DEFINER
STABLE
AS $$
DECLARE
  v_start_date DATE;
  v_end_date DATE;
BEGIN
  v_start_date := COALESCE(p_start_date, CURRENT_DATE - INTERVAL '30 days');
  v_end_date := COALESCE(p_end_date, CURRENT_DATE);
  
  RETURN QUERY
  WITH filtered_trades AS (
    SELECT * FROM trades
    WHERE user_id = p_user_id
      AND import_source = 'snaptrade'
      AND imported_at BETWEEN v_start_date AND v_end_date
  )
  SELECT 
    COUNT(*)::BIGINT as total_imported,
    
    jsonb_object_agg(
      symbol, 
      count
    ) as by_symbol,
    
    jsonb_object_agg(
      side,
      side_count
    ) as by_side,
    
    jsonb_object_agg(
      COALESCE(snaptrade_account_id::TEXT, 'unknown'),
      account_count
    ) as by_account,
    
    jsonb_build_object(
      'start_date', v_start_date,
      'end_date', v_end_date,
      'days', v_end_date - v_start_date
    ) as date_range
    
  FROM (
    SELECT 
      symbol,
      COUNT(*) as count,
      side,
      COUNT(*) as side_count,
      snaptrade_account_id,
      COUNT(*) as account_count
    FROM filtered_trades
    GROUP BY symbol, side, snaptrade_account_id
  ) stats;
END;
$$;

COMMENT ON FUNCTION public.get_snaptrade_import_stats IS 
'v8.5.0: Get detailed import statistics for date range';

-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
-- 15.5: Find Duplicate SnapTrade Activities
-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

DROP FUNCTION IF EXISTS public.find_duplicate_snaptrade_activities(UUID) CASCADE;

CREATE OR REPLACE FUNCTION public.find_duplicate_snaptrade_activities(p_user_id UUID)
RETURNS TABLE (
  activity_id TEXT,
  trade_count BIGINT,
  trade_ids UUID[]
)
LANGUAGE plpgsql
SECURITY DEFINER
STABLE
AS $$
BEGIN
  RETURN QUERY
  SELECT 
    t.snaptrade_activity_id::TEXT,
    COUNT(*)::BIGINT as trade_count,
    ARRAY_AGG(t.id) as trade_ids
  FROM trades t
  WHERE t.user_id = p_user_id
    AND t.snaptrade_activity_id IS NOT NULL
  GROUP BY t.snaptrade_activity_id
  HAVING COUNT(*) > 1;
END;
$$;

COMMENT ON FUNCTION public.find_duplicate_snaptrade_activities IS 
'v8.5.0: Find duplicate SnapTrade activity IDs (should return empty)';
-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
-- GRANT PERMISSIONS
-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

DO $$
BEGIN
  RAISE NOTICE 'üîê Granting permissions...';
END $$;

-- Core trade limit functions
GRANT EXECUTE ON FUNCTION public.get_trade_limit(TEXT) TO authenticated;
GRANT EXECUTE ON FUNCTION public.can_create_trade(UUID) TO authenticated;
GRANT EXECUTE ON FUNCTION public.get_remaining_trades(UUID) TO authenticated;

-- ‚úÖ Admin free access functions
GRANT EXECUTE ON FUNCTION public.grant_free_access(UUID, INTEGER, TEXT, UUID) TO authenticated;
GRANT EXECUTE ON FUNCTION public.admin_grant_free_months(UUID, INTEGER) TO authenticated;

-- ‚úÖ Admin update subscription (JSONB version)
GRANT EXECUTE ON FUNCTION public.admin_update_subscription(UUID, TEXT, TEXT, TEXT, TIMESTAMPTZ) TO authenticated;

-- Section 14: Helper functions
GRANT EXECUTE ON FUNCTION public.refresh_webhook_stats() TO authenticated;
GRANT EXECUTE ON FUNCTION public.refresh_strategy_stats() TO authenticated;
GRANT EXECUTE ON FUNCTION public.refresh_all_materialized_views() TO authenticated;
GRANT EXECUTE ON FUNCTION public.get_database_size() TO authenticated;
GRANT EXECUTE ON FUNCTION public.get_table_sizes() TO authenticated;
GRANT EXECUTE ON FUNCTION public.get_slow_queries(INTEGER) TO authenticated;
GRANT EXECUTE ON FUNCTION public.check_system_health() TO authenticated;
GRANT EXECUTE ON FUNCTION public.manual_cleanup_old_data() TO authenticated;

-- üî• Section 15: SnapTrade functions
GRANT EXECUTE ON FUNCTION public.is_snaptrade_connected(UUID) TO authenticated;
GRANT EXECUTE ON FUNCTION public.get_user_sync_stats(UUID) TO authenticated;
GRANT EXECUTE ON FUNCTION public.get_latest_sync_for_user(UUID) TO authenticated;
GRANT EXECUTE ON FUNCTION public.get_snaptrade_import_stats(UUID, DATE, DATE) TO authenticated;
GRANT EXECUTE ON FUNCTION public.find_duplicate_snaptrade_activities(UUID) TO authenticated;

-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
-- UPGRADE RLS - TRADE LIMIT ENFORCEMENT
-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

DO $$
BEGIN
  RAISE NOTICE 'üî• Creating RLS policy for trade limits...';
END $$;

-- Drop old policy if exists
DROP POLICY IF EXISTS "trades_insert_own" ON public.trades;
DROP POLICY IF EXISTS "trades_insert_with_limits" ON public.trades;

-- Create new policy with limit enforcement
CREATE POLICY "trades_insert_with_limits"
ON public.trades
FOR INSERT
TO authenticated
WITH CHECK (
  -- Must insert own trade
  user_id = auth.uid()
  AND
  -- Must be under limit
  (SELECT public.can_create_trade(auth.uid())) = TRUE
);

COMMENT ON POLICY "trades_insert_with_limits" ON public.trades IS 
'v8.5.0-FIXED: Enforces ownership AND limits. FREE=10 lifetime, BASIC/TRIAL=25/month, PREMIUM=unlimited';

COMMIT;

-- ===============================================
-- END OF PART 2/3 - COMPLETE WITH v8.5.0
-- ===============================================

DO $$
BEGIN
  RAISE NOTICE '';
  RAISE NOTICE '‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó';
  RAISE NOTICE '‚ïë  ‚úÖ PART 2/3 COMPLETE! (v8.5.0)       ‚ïë';
  RAISE NOTICE '‚ïë     Functions + Triggers + RLS        ‚ïë';
  RAISE NOTICE '‚ïë     üî• WITH SNAPTRADE INTEGRATION!    ‚ïë';
  RAISE NOTICE '‚ïë     üÜï SECTION 15 SNAPTRADE COMPLETE! ‚ïë';
  RAISE NOTICE '‚ïë     üîß admin_update RETURNS JSONB!    ‚ïë';
  RAISE NOTICE '‚ïë     üîß PORTFOLIO FIELDS INCLUDED!     ‚ïë';
  RAISE NOTICE '‚ïë     üî• FREE: NO MONTHLY RESET!        ‚ïë';
  RAISE NOTICE '‚ïë     üîí SECURITY: Payment protected!   ‚ïë';
  RAISE NOTICE '‚ïë     üöÄ OPTIMIZED: 3x faster!          ‚ïë';
  RAISE NOTICE '‚ïë     üîß IMPERSONATION: INCLUDED!       ‚ïë';
  RAISE NOTICE '‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù';
  RAISE NOTICE '';
  RAISE NOTICE 'üìä Created:';
  RAISE NOTICE '   ‚Ä¢ Functions: 93+ (including SnapTrade!)';
  RAISE NOTICE '   ‚Ä¢ Triggers: 12 (unified!)';
  RAISE NOTICE '   ‚Ä¢ RLS: Trade limit enforcement ‚úÖ';
  RAISE NOTICE '   ‚Ä¢ Rate Limiting ‚úÖ';
  RAISE NOTICE '   ‚Ä¢ Soft Delete ‚úÖ';
  RAISE NOTICE '   ‚Ä¢ Payment Security ‚úÖ';
  RAISE NOTICE '   ‚Ä¢ Affiliate Automation ‚úÖ';
  RAISE NOTICE '   ‚Ä¢ Impersonation ‚úÖ';
  RAISE NOTICE '   ‚Ä¢ Admin Maintenance Tools ‚úÖ';
  RAISE NOTICE '   ‚Ä¢ üî• SnapTrade Integration ‚úÖ';
  RAISE NOTICE '';
  RAISE NOTICE 'üî• NEW in Section 15 (SnapTrade):';
  RAISE NOTICE '   ‚Ä¢ is_snaptrade_connected()';
  RAISE NOTICE '   ‚Ä¢ get_user_sync_stats()';
  RAISE NOTICE '   ‚Ä¢ get_latest_sync_for_user()';
  RAISE NOTICE '   ‚Ä¢ get_snaptrade_import_stats()';
  RAISE NOTICE '   ‚Ä¢ find_duplicate_snaptrade_activities()';
  RAISE NOTICE '';
  RAISE NOTICE 'üîß FIXED in v8.4.7:';
  RAISE NOTICE '   ‚Ä¢ admin_update_subscription NOW RETURNS JSONB!';
  RAISE NOTICE '   ‚Ä¢ Better error handling with try-catch';
  RAISE NOTICE '   ‚Ä¢ Validates all inputs before update';
  RAISE NOTICE '   ‚Ä¢ Returns detailed success/error messages';
  RAISE NOTICE '   ‚Ä¢ Logs to admin_audit_log automatically';
  RAISE NOTICE '';
  RAISE NOTICE 'üÜï Section 14 (Admin Maintenance):';
  RAISE NOTICE '   ‚Ä¢ refresh_webhook_stats()';
  RAISE NOTICE '   ‚Ä¢ refresh_strategy_stats()';
  RAISE NOTICE '   ‚Ä¢ refresh_all_materialized_views()';
  RAISE NOTICE '   ‚Ä¢ get_database_size()';
  RAISE NOTICE '   ‚Ä¢ get_table_sizes()';
  RAISE NOTICE '   ‚Ä¢ get_slow_queries()';
  RAISE NOTICE '   ‚Ä¢ check_system_health()';
  RAISE NOTICE '   ‚Ä¢ manual_cleanup_old_data()';
  RAISE NOTICE '';
  RAISE NOTICE '‚ú® Trade Limits (v8.5.0):';
  RAISE NOTICE '   ‚Ä¢ FREE:    10 trades LIFETIME (no reset)';
  RAISE NOTICE '   ‚Ä¢ BASIC:   25 trades/month';
  RAISE NOTICE '   ‚Ä¢ TRIAL:   25 trades/month';
  RAISE NOTICE '   ‚Ä¢ PREMIUM: Unlimited';
  RAISE NOTICE '';
  RAISE NOTICE 'üìà SnapTrade Features:';
  RAISE NOTICE '   ‚Ä¢ User connection tracking';
  RAISE NOTICE '   ‚Ä¢ Sync job logging & statistics';
  RAISE NOTICE '   ‚Ä¢ Import analytics by symbol/side/account';
  RAISE NOTICE '   ‚Ä¢ Duplicate detection';
  RAISE NOTICE '   ‚Ä¢ Date range filtering';
  RAISE NOTICE '';
  RAISE NOTICE '‚è≠Ô∏è  Next: Run Part 3 (Views + Permissions)';
  RAISE NOTICE '   Then run: SNAPTRADE-PART-3-VIEWS.sql';
  RAISE NOTICE '';
END $$;