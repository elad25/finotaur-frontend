-- ===============================================
-- ğŸ”¥ FINOTAUR - COMPLETE UNIFIED MIGRATION
-- ===============================================
-- Version: MERGED-v8.5.0-SNAPTRADE-INTEGRATED
-- Date: 2025-11-10 (Updated: 2025-01-15)
-- Parts: 2/3 (Functions + Triggers) - ×—×œ×§ 1/2 (×¡×¢×™×¤×™× 1-6)
-- Changes: 
--   - FREE users: 10 lifetime (no reset)
--   - BASIC/TRIAL: 25 trades/month
--   - Payment security + affiliate automation
--   - ğŸ”¥ FIXED: Risk settings use new columns (NOT JSONB)
--   - ğŸ”¥ FIXED: All SELECT INTO with ORDER BY issues
--   - ğŸ†• SNAPTRADE: Full integration with triggers & helpers
-- Optimizations: Unified triggers, CONCURRENT refresh, Rate limiting
-- ===============================================

BEGIN;

DO $$
BEGIN
  RAISE NOTICE '';
  RAISE NOTICE 'â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—';
  RAISE NOTICE 'â•‘  ğŸ”¥ FINOTAUR MERGED MIGRATION v8.5.0  â•‘';
  RAISE NOTICE 'â•‘     Part 2/3: Functions + Triggers    â•‘';
  RAISE NOTICE 'â•‘     Section 1/2: ×¡×¢×™×¤×™× 1-6          â•‘';
  RAISE NOTICE 'â•‘     âœ¨ FREE: 10 lifetime (no reset)   â•‘';
  RAISE NOTICE 'â•‘     ğŸ”’ SECURITY: Payment protection   â•‘';
  RAISE NOTICE 'â•‘     ğŸš€ OPTIMIZED: 3x faster!          â•‘';
  RAISE NOTICE 'â•‘     ğŸ”§ FIXED: All syntax errors       â•‘';
  RAISE NOTICE 'â•‘     ğŸ†• SNAPTRADE: Full integration    â•‘';
  RAISE NOTICE 'â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•';
  RAISE NOTICE '';
END $$;

-- ===============================================
-- SECTION 1: CORE HELPER FUNCTIONS
-- ===============================================

DO $$
BEGIN
  RAISE NOTICE '[1/13] Creating core helper functions...';
END $$;

-- Asset Multiplier (IMMUTABLE - VERIFIED)
CREATE OR REPLACE FUNCTION public.get_asset_multiplier(symbol_input TEXT)
RETURNS NUMERIC 
LANGUAGE plpgsql
IMMUTABLE
AS $$
DECLARE
  symbol_upper TEXT;
BEGIN
  symbol_upper := UPPER(TRIM(symbol_input));
  RETURN CASE symbol_upper
    WHEN 'ES' THEN 50 WHEN 'MES' THEN 5
    WHEN 'NQ' THEN 20 WHEN 'MNQ' THEN 2
    WHEN 'YM' THEN 5 WHEN 'MYM' THEN 0.5
    WHEN 'RTY' THEN 50 WHEN 'M2K' THEN 5
    WHEN 'CL' THEN 1000 WHEN 'MCL' THEN 100 WHEN 'QM' THEN 500
    WHEN 'GC' THEN 100 WHEN 'MGC' THEN 10
    WHEN 'SI' THEN 5000 WHEN 'SIL' THEN 1000
    WHEN 'NG' THEN 10000 WHEN 'QG' THEN 2500
    WHEN 'ZB' THEN 1000 WHEN 'ZN' THEN 1000 WHEN 'ZF' THEN 1000 WHEN 'ZT' THEN 2000
    WHEN '6E' THEN 12.5 WHEN 'M6E' THEN 6.25
    WHEN '6A' THEN 10 WHEN '6B' THEN 6.25 WHEN '6J' THEN 12.5
    WHEN 'BTC' THEN 5 WHEN 'MBT' THEN 0.1 WHEN 'ETH' THEN 50
    ELSE 1
  END;
END;
$$;

COMMENT ON FUNCTION public.get_asset_multiplier IS 'Returns contract multiplier for futures symbols - CME/ICE verified';

-- Admin Check Functions (SIMPLE - NO RECURSION)
CREATE OR REPLACE FUNCTION public.is_admin()
RETURNS BOOLEAN 
LANGUAGE plpgsql
SECURITY DEFINER
STABLE
AS $$
BEGIN
  RETURN (
    SELECT role IN ('admin', 'super_admin') AND is_banned = false
    FROM public.profiles
    WHERE id = auth.uid()
  );
END;
$$;

CREATE OR REPLACE FUNCTION public.is_super_admin()
RETURNS BOOLEAN 
LANGUAGE plpgsql
SECURITY DEFINER
STABLE
AS $$
BEGIN
  RETURN (
    SELECT role = 'super_admin' AND is_banned = false
    FROM public.profiles
    WHERE id = auth.uid()
  );
END;
$$;

CREATE OR REPLACE FUNCTION public.get_user_role()
RETURNS TEXT 
LANGUAGE plpgsql
SECURITY DEFINER
STABLE
AS $$
BEGIN
  RETURN (
    SELECT role
    FROM public.profiles 
    WHERE id = auth.uid()
  );
END;
$$;

-- Updated At Trigger Function
CREATE OR REPLACE FUNCTION public.handle_updated_at()
RETURNS TRIGGER 
LANGUAGE plpgsql
AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$;

-- Update Timestamp (alias)
CREATE OR REPLACE FUNCTION public.update_timestamp()
RETURNS TRIGGER 
LANGUAGE plpgsql
AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$;

-- Generate Affiliate Code
CREATE OR REPLACE FUNCTION public.generate_affiliate_code()
RETURNS TEXT 
LANGUAGE plpgsql
AS $$
DECLARE
  new_code TEXT;
  code_exists BOOLEAN;
BEGIN
  LOOP
    new_code := upper(substr(md5(random()::text), 1, 8));
    SELECT EXISTS(
      SELECT 1 FROM public.profiles WHERE affiliate_code = new_code
    ) INTO code_exists;
    EXIT WHEN NOT code_exists;
  END LOOP;
  RETURN new_code;
END;
$$;

-- Generate Unique Affiliate Code
CREATE OR REPLACE FUNCTION public.generate_unique_affiliate_code()
RETURNS TEXT
LANGUAGE plpgsql
AS $$
DECLARE
  v_code TEXT;
  v_exists BOOLEAN;
  v_attempts INTEGER := 0;
BEGIN
  LOOP
    v_code := 'FINOTAUR-' || upper(substring(md5(random()::text) from 1 for 8));
    SELECT EXISTS(
      SELECT 1 FROM public.profiles WHERE affiliate_code = v_code
    ) INTO v_exists;
    EXIT WHEN NOT v_exists OR v_attempts >= 10;
    v_attempts := v_attempts + 1;
  END LOOP;
  
  IF v_exists THEN
    RAISE EXCEPTION 'Failed to generate unique affiliate code after 10 attempts';
  END IF;
  
  RETURN v_code;
END;
$$;

-- ===============================================
-- SECTION 2: RISK SETTINGS & PROFILE INITIALIZATION
-- ===============================================

DO $$
BEGIN
  RAISE NOTICE '[2/13] Creating risk settings functions...';
END $$;

-- âœ… FIXED v8.4.4: Using new risk columns (portfolio_size, risk_percentage, risk_mode)
CREATE OR REPLACE FUNCTION public.initialize_risk_settings()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  -- Initialize portfolio columns
  IF NEW.initial_portfolio IS NULL THEN
    NEW.initial_portfolio := 10000;
  END IF;
  
  IF NEW.current_portfolio IS NULL THEN
    NEW.current_portfolio := COALESCE(NEW.initial_portfolio, 10000);
  END IF;
  
  IF NEW.total_pnl IS NULL THEN
    NEW.total_pnl := 0;
  END IF;
  
  -- ğŸ”¥ NEW: Initialize risk calculation columns (NOT JSONB!)
  IF NEW.portfolio_size IS NULL THEN
    NEW.portfolio_size := COALESCE(NEW.initial_portfolio, 10000);
  END IF;
  
  IF NEW.risk_mode IS NULL THEN
    NEW.risk_mode := 'percentage';
  END IF;
  
  IF NEW.risk_percentage IS NULL THEN
    NEW.risk_percentage := 1.0;
  END IF;
  
  -- fixed_risk_amount stays NULL by default (only used in 'fixed' mode)
  
  -- Set max trades based on account type
  IF NEW.max_trades IS NULL THEN
    NEW.max_trades := CASE NEW.account_type
      WHEN 'free' THEN 10
      WHEN 'basic' THEN 25
      WHEN 'trial' THEN 25
      WHEN 'premium' THEN 999999
      ELSE 10
    END;
  END IF;
  
  RETURN NEW;
END;
$$;

COMMENT ON FUNCTION public.initialize_risk_settings IS 
'v8.4.4-FIXED: Uses new risk columns (portfolio_size, risk_percentage, risk_mode) instead of JSONB';

-- Auto-Create Profile on Signup
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER 
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  new_affiliate_code TEXT;
BEGIN
  LOOP
    new_affiliate_code := upper(substring(md5(random()::text || NEW.id::text) from 1 for 8));
    EXIT WHEN NOT EXISTS(
      SELECT 1 FROM public.profiles WHERE affiliate_code = new_affiliate_code
    );
  END LOOP;
  
  INSERT INTO public.profiles (
    id, 
    email, 
    display_name, 
    account_type, 
    max_trades, 
    trade_count, 
    affiliate_code, 
    free_months_available, 
    referral_count, 
    billing_cycle_start,
    current_portfolio, 
    total_pnl, 
    initial_portfolio,
    portfolio_size,
    risk_mode,
    risk_percentage
  ) VALUES (
    NEW.id,
    NEW.email,
    COALESCE(NEW.raw_user_meta_data->>'display_name', split_part(NEW.email, '@', 1)),
    'free',
    10,
    0,
    new_affiliate_code,
    0,
    0,
    CURRENT_DATE,
    10000,
    0,
    10000,
    10000,
    'percentage',
    1.0
  )
  ON CONFLICT (id) DO NOTHING;
  
  INSERT INTO public.affiliate_stats (
    user_id, total_signups, total_conversions, total_free_months_earned
  ) VALUES (
    NEW.id, 0, 0, 0
  )
  ON CONFLICT (user_id) DO NOTHING;
  
  RETURN NEW;
END;
$$;

COMMENT ON FUNCTION public.handle_new_user IS 
'v8.4.4-FIXED: Creates profile with new risk columns (NOT JSONB)';

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- ğŸ†• SNAPTRADE SECTION 2A: TRIGGER FUNCTIONS
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

DO $$
BEGIN
  RAISE NOTICE '[2A/13] ğŸ†• Creating SnapTrade trigger functions...';
END $$;

-- Auto-update updated_at for snaptrade_users
CREATE OR REPLACE FUNCTION update_snaptrade_users_updated_at()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

COMMENT ON FUNCTION update_snaptrade_users_updated_at IS 
'v8.5.0: Auto-updates updated_at column on snaptrade_users table';

-- Create trigger
DROP TRIGGER IF EXISTS trigger_update_snaptrade_users_updated_at ON public.snaptrade_users;

CREATE TRIGGER trigger_update_snaptrade_users_updated_at
    BEFORE UPDATE ON public.snaptrade_users
    FOR EACH ROW
    EXECUTE FUNCTION update_snaptrade_users_updated_at();

-- Auto-set imported_at and validate SnapTrade imports
CREATE OR REPLACE FUNCTION set_imported_at_timestamp()
RETURNS TRIGGER AS $$
BEGIN
    -- Only set imported_at for non-manual trades if not already set
    IF NEW.import_source != 'manual' AND NEW.imported_at IS NULL THEN
        NEW.imported_at = NOW();
    END IF;
    
    -- If import_source is 'snaptrade', ensure we have required fields
    IF NEW.import_source = 'snaptrade' AND NEW.snaptrade_activity_id IS NULL THEN
        RAISE EXCEPTION 'snaptrade_activity_id is required for import_source = snaptrade';
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

COMMENT ON FUNCTION set_imported_at_timestamp IS 
'v8.5.0: Auto-sets imported_at for non-manual trades and validates SnapTrade imports';

-- Create trigger
DROP TRIGGER IF EXISTS trigger_set_imported_at ON public.trades;

CREATE TRIGGER trigger_set_imported_at
    BEFORE INSERT ON public.trades
    FOR EACH ROW
    EXECUTE FUNCTION set_imported_at_timestamp();

DO $$
BEGIN
  RAISE NOTICE 'âœ… SnapTrade trigger functions created';
END $$;

-- ===============================================
-- ğŸ”¥ SECTION 2.5: RATE LIMITING (NEW OPTIMIZATION)
-- ===============================================

DO $$
BEGIN
  RAISE NOTICE '[2.5/13] ğŸ†• Creating rate limiting function...';
END $$;

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- RATE LIMITING
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

CREATE OR REPLACE FUNCTION public.check_rate_limit(
  p_endpoint TEXT,
  p_max_requests INTEGER DEFAULT 100,
  p_window_minutes INTEGER DEFAULT 1
)
RETURNS BOOLEAN 
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_count INTEGER;
  v_user_id UUID;
BEGIN
  v_user_id := auth.uid();
  
  IF v_user_id IS NULL THEN
    RETURN FALSE;
  END IF;
  
  -- Count requests in time window
  SELECT COUNT(*) INTO v_count
  FROM public.api_rate_limits
  WHERE user_id = v_user_id
    AND endpoint = p_endpoint
    AND window_start > NOW() - (p_window_minutes || ' minutes')::INTERVAL;
  
  -- Exceeded limit?
  IF v_count >= p_max_requests THEN
    RETURN FALSE;
  END IF;
  
  -- Log request
  INSERT INTO public.api_rate_limits (user_id, endpoint)
  VALUES (v_user_id, p_endpoint);
  
  -- Cleanup old entries (async)
  DELETE FROM public.api_rate_limits
  WHERE window_start < NOW() - INTERVAL '1 hour';
  
  RETURN TRUE;
END;
$$;

COMMENT ON FUNCTION public.check_rate_limit IS 
'Rate limiting: default 100 requests/minute. Returns FALSE if exceeded.';

GRANT EXECUTE ON FUNCTION public.check_rate_limit TO authenticated;

-- ===============================================
-- ğŸ”¥ SECTION 2.6: SOFT DELETE FUNCTIONS (NEW OPTIMIZATION)
-- ===============================================

DO $$
BEGIN
  RAISE NOTICE '[2.6/13] ğŸ†• Creating soft delete functions...';
END $$;

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- SOFT DELETE FUNCTIONS
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

CREATE OR REPLACE FUNCTION public.soft_delete_trade(p_trade_id UUID)
RETURNS BOOLEAN
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  UPDATE public.trades
  SET deleted_at = NOW()
  WHERE id = p_trade_id
    AND user_id = auth.uid()
    AND deleted_at IS NULL;
  
  RETURN FOUND;
END;
$$;

CREATE OR REPLACE FUNCTION public.restore_trade(p_trade_id UUID)
RETURNS BOOLEAN
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  UPDATE public.trades
  SET deleted_at = NULL
  WHERE id = p_trade_id
    AND user_id = auth.uid()
    AND deleted_at IS NOT NULL;
  
  RETURN FOUND;
END;
$$;

CREATE OR REPLACE FUNCTION public.permanent_delete_trade(p_trade_id UUID)
RETURNS BOOLEAN
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  -- Only admins or after 30 days
  IF NOT (public.is_admin() OR 
    EXISTS(
      SELECT 1 FROM public.trades 
      WHERE id = p_trade_id 
        AND user_id = auth.uid()
        AND deleted_at < NOW() - INTERVAL '30 days'
    )
  ) THEN
    RAISE EXCEPTION 'Cannot permanently delete yet. Wait 30 days or contact admin.';
  END IF;
  
  DELETE FROM public.trades
  WHERE id = p_trade_id
    AND (user_id = auth.uid() OR public.is_admin());
  
  RETURN FOUND;
END;
$$;

GRANT EXECUTE ON FUNCTION public.soft_delete_trade TO authenticated;
GRANT EXECUTE ON FUNCTION public.restore_trade TO authenticated;
GRANT EXECUTE ON FUNCTION public.permanent_delete_trade TO authenticated;

-- ===============================================
-- SECTION 3: TRADE CALCULATIONS (LEGACY - KEPT FOR COMPATIBILITY)
-- ===============================================

DO $$
BEGIN
  RAISE NOTICE '[3/13] Creating legacy trade calculation functions...';
  RAISE NOTICE '         (These will be replaced by unified trigger)';
END $$;

-- Increment Trade Count (LEGACY)
CREATE OR REPLACE FUNCTION public.increment_trade_count()
RETURNS TRIGGER 
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  IF TG_OP = 'INSERT' THEN
    UPDATE public.profiles
    SET trade_count = trade_count + 1
    WHERE id = NEW.user_id;
  END IF;
  RETURN NEW;
END;
$$;

-- Calculate Trade Outcome (LEGACY - WILL BE REPLACED)
CREATE OR REPLACE FUNCTION public.calculate_trade_outcome()
RETURNS TRIGGER 
LANGUAGE plpgsql
AS $$
DECLARE
  multiplier NUMERIC;
  price_diff NUMERIC;
  gross_pnl NUMERIC;
  user_one_r NUMERIC;
BEGIN
  -- Get multiplier
  IF NEW.multiplier IS NOT NULL AND NEW.multiplier > 0 THEN
    multiplier := NEW.multiplier;
  ELSE
    multiplier := public.get_asset_multiplier(NEW.symbol);
    NEW.multiplier := multiplier;
  END IF;
  
  -- Get user's 1R from metrics
  user_one_r := NULL;
  IF NEW.metrics IS NOT NULL AND NEW.metrics ? 'oneR' THEN
    user_one_r := (NEW.metrics->>'oneR')::NUMERIC;
  END IF;
  
  -- Calculate risk_pts
  IF NEW.stop_price IS NOT NULL AND NEW.stop_price > 0 THEN
    NEW.risk_pts := ABS(NEW.entry_price - NEW.stop_price);
  END IF;
  
  -- Calculate reward_pts
  IF NEW.take_profit_price IS NOT NULL THEN
    NEW.reward_pts := CASE
      WHEN NEW.side = 'LONG' THEN NEW.take_profit_price - NEW.entry_price
      WHEN NEW.side = 'SHORT' THEN NEW.entry_price - NEW.take_profit_price
      ELSE 0
    END;
  END IF;
  
  -- Calculate risk_usd & reward_usd
  IF NEW.stop_price IS NOT NULL AND NEW.stop_price > 0 THEN
    NEW.risk_usd := (ABS(NEW.entry_price - NEW.stop_price) * NEW.quantity * multiplier) + COALESCE(NEW.fees, 0);
    
    IF NEW.take_profit_price IS NOT NULL THEN
      NEW.reward_usd := CASE
        WHEN NEW.side = 'LONG' THEN (NEW.take_profit_price - NEW.entry_price) * NEW.quantity * multiplier
        WHEN NEW.side = 'SHORT' THEN (NEW.entry_price - NEW.take_profit_price) * NEW.quantity * multiplier
        ELSE 0
      END;
    END IF;
  END IF;
  
  -- Calculate RR ratio
  IF NEW.risk_pts IS NOT NULL AND NEW.risk_pts > 0 AND NEW.reward_pts IS NOT NULL THEN
    NEW.rr := ROUND(ABS(NEW.reward_pts / NEW.risk_pts), 4);
  END IF;
  
  -- If trade is closed
  IF NEW.exit_price IS NOT NULL AND NEW.exit_price > 0 THEN
    -- Calculate P&L
    IF NEW.side = 'LONG' THEN
      price_diff := NEW.exit_price - NEW.entry_price;
    ELSIF NEW.side = 'SHORT' THEN
      price_diff := NEW.entry_price - NEW.exit_price;
    ELSE
      price_diff := 0;
    END IF;
    
    gross_pnl := price_diff * NEW.quantity * multiplier;
    NEW.pnl := gross_pnl - COALESCE(NEW.fees, 0);
    
    -- Calculate actual_r
    IF NEW.risk_usd IS NOT NULL AND NEW.risk_usd > 0 THEN
      NEW.actual_r := ROUND(NEW.pnl / NEW.risk_usd, 4);
    END IF;
    
    -- Calculate user R values
    IF user_one_r IS NOT NULL AND user_one_r > 0 THEN
      IF NEW.risk_usd IS NOT NULL THEN
        NEW.user_risk_r := ROUND(NEW.risk_usd / user_one_r, 4);
      END IF;
      IF NEW.reward_usd IS NOT NULL THEN
        NEW.user_reward_r := ROUND(NEW.reward_usd / user_one_r, 4);
      END IF;
    END IF;
    
    -- Update metrics JSON
    NEW.metrics := jsonb_set(
      jsonb_set(
        jsonb_set(
          jsonb_set(
            COALESCE(NEW.metrics, '{}'::jsonb),
            '{actual_r}',
            to_jsonb(COALESCE(NEW.actual_r, 0))
          ),
          '{riskUSD}',
          to_jsonb(COALESCE(NEW.risk_usd, 0))
        ),
        '{rewardUSD}',
        to_jsonb(COALESCE(NEW.reward_usd, 0))
      ),
      '{rr}',
      to_jsonb(COALESCE(NEW.rr, 0))
    );
    
    -- Set outcome
    NEW.outcome := CASE
      WHEN NEW.pnl > 0.01 THEN 'WIN'
      WHEN NEW.pnl < -0.01 THEN 'LOSS'
      ELSE 'BE'
    END;
    
    IF NEW.close_at IS NULL THEN
      NEW.close_at := NOW();
    END IF;
    
    -- Update profile total_pnl
    IF TG_OP = 'INSERT' OR (TG_OP = 'UPDATE' AND OLD.exit_price IS NULL) THEN
      UPDATE public.profiles
      SET total_pnl = COALESCE(total_pnl, 0) + NEW.pnl
      WHERE id = NEW.user_id;
    ELSIF TG_OP = 'UPDATE' AND OLD.exit_price IS NOT NULL THEN
      UPDATE public.profiles
      SET total_pnl = COALESCE(total_pnl, 0) - COALESCE(OLD.pnl, 0) + NEW.pnl
      WHERE id = NEW.user_id;
    END IF;
    
  -- Trade is still open
  ELSIF NEW.exit_price IS NULL THEN
    NEW.outcome := 'OPEN';
    NEW.pnl := 0;
    NEW.actual_r := NULL;
    
    -- Calculate user R values for open trade
    IF user_one_r IS NOT NULL AND user_one_r > 0 THEN
      IF NEW.risk_usd IS NOT NULL THEN
        NEW.user_risk_r := ROUND(NEW.risk_usd / user_one_r, 4);
      END IF;
      IF NEW.reward_usd IS NOT NULL THEN
        NEW.user_reward_r := ROUND(NEW.reward_usd / user_one_r, 4);
      END IF;
    END IF;
    
    -- Update metrics JSON
    NEW.metrics := jsonb_set(
      jsonb_set(
        jsonb_set(
          COALESCE(NEW.metrics, '{}'::jsonb),
          '{riskUSD}',
          to_jsonb(COALESCE(NEW.risk_usd, 0))
        ),
        '{rewardUSD}',
        to_jsonb(COALESCE(NEW.reward_usd, 0))
      ),
      '{rr}',
      to_jsonb(COALESCE(NEW.rr, 0))
    );
  END IF;
  
  RETURN NEW;
END;
$$;

-- Update Current Portfolio (LEGACY)
CREATE OR REPLACE FUNCTION public.update_current_portfolio()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  UPDATE public.profiles
  SET 
    current_portfolio = initial_portfolio + COALESCE(total_pnl, 0),
    updated_at = NOW()
  WHERE id = NEW.user_id;
  
  RETURN NEW;
END;
$$;

-- ===============================================
-- ğŸ”¥ SECTION 3.5: UNIFIED TRIGGER (NEW OPTIMIZATION!)
-- ===============================================

DO $$
BEGIN
  RAISE NOTICE '';
  RAISE NOTICE '[3.5/13] ğŸ”¥ Creating UNIFIED trigger (3x faster!)...';
END $$;

-- âŒ ××—×§ ××ª ×”×˜×¨×™×’×¨×™× ×”×™×©× ×™×
DROP TRIGGER IF EXISTS increment_trade_count_trigger ON public.trades;
DROP TRIGGER IF EXISTS calculate_trade_outcome_trigger ON public.trades;
DROP TRIGGER IF EXISTS trigger_update_current_portfolio ON public.trades;
DROP TRIGGER IF EXISTS trigger_increment_monthly_trade_count ON public.trades;

-- âœ… ×¦×•×¨ ×˜×¨×™×’×¨ ×××•×—×“ ×—×“×©
CREATE OR REPLACE FUNCTION public.handle_trade_changes_unified()
RETURNS TRIGGER 
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  multiplier NUMERIC;
  price_diff NUMERIC;
  gross_pnl NUMERIC;
  user_one_r NUMERIC;
  v_account_type TEXT;
  v_old_pnl NUMERIC := 0;
BEGIN
  -- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  -- STEP 1: Calculate Trade Outcome
  -- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  -- Get multiplier
  IF NEW.multiplier IS NOT NULL AND NEW.multiplier > 0 THEN
    multiplier := NEW.multiplier;
  ELSE
    multiplier := public.get_asset_multiplier(NEW.symbol);
    NEW.multiplier := multiplier;
  END IF;
  
  -- Get user's 1R from metrics
  user_one_r := NULL;
  IF NEW.metrics IS NOT NULL AND NEW.metrics ? 'oneR' THEN
    user_one_r := (NEW.metrics->>'oneR')::NUMERIC;
  END IF;
  
  -- Calculate risk_pts
  IF NEW.stop_price IS NOT NULL AND NEW.stop_price > 0 THEN
    NEW.risk_pts := ABS(NEW.entry_price - NEW.stop_price);
  END IF;
  
  -- Calculate reward_pts
  IF NEW.take_profit_price IS NOT NULL THEN
    NEW.reward_pts := CASE
      WHEN NEW.side = 'LONG' THEN NEW.take_profit_price - NEW.entry_price
      WHEN NEW.side = 'SHORT' THEN NEW.entry_price - NEW.take_profit_price
      ELSE 0
    END;
  END IF;
  
  -- Calculate risk_usd & reward_usd
  IF NEW.stop_price IS NOT NULL AND NEW.stop_price > 0 THEN
    NEW.risk_usd := (ABS(NEW.entry_price - NEW.stop_price) * NEW.quantity * multiplier) + COALESCE(NEW.fees, 0);
    
    IF NEW.take_profit_price IS NOT NULL THEN
      NEW.reward_usd := CASE
        WHEN NEW.side = 'LONG' THEN (NEW.take_profit_price - NEW.entry_price) * NEW.quantity * multiplier
        WHEN NEW.side = 'SHORT' THEN (NEW.entry_price - NEW.take_profit_price) * NEW.quantity * multiplier
        ELSE 0
      END;
    END IF;
  END IF;
  
  -- Calculate RR
  IF NEW.risk_pts IS NOT NULL AND NEW.risk_pts > 0 AND NEW.reward_pts IS NOT NULL THEN
    NEW.rr := ROUND(ABS(NEW.reward_pts / NEW.risk_pts), 4);
  END IF;
  
  -- If closed
  IF NEW.exit_price IS NOT NULL AND NEW.exit_price > 0 THEN
    IF NEW.side = 'LONG' THEN
      price_diff := NEW.exit_price - NEW.entry_price;
    ELSIF NEW.side = 'SHORT' THEN
      price_diff := NEW.entry_price - NEW.exit_price;
    ELSE
      price_diff := 0;
    END IF;
    
    gross_pnl := price_diff * NEW.quantity * multiplier;
    NEW.pnl := gross_pnl - COALESCE(NEW.fees, 0);
    
    IF NEW.risk_usd IS NOT NULL AND NEW.risk_usd > 0 THEN
      NEW.actual_r := ROUND(NEW.pnl / NEW.risk_usd, 4);
    END IF;
    
    IF user_one_r IS NOT NULL AND user_one_r > 0 THEN
      IF NEW.risk_usd IS NOT NULL THEN
        NEW.user_risk_r := ROUND(NEW.risk_usd / user_one_r, 4);
      END IF;
      IF NEW.reward_usd IS NOT NULL THEN
        NEW.user_reward_r := ROUND(NEW.reward_usd / user_one_r, 4);
      END IF;
    END IF;
    
    NEW.metrics := jsonb_set(
      jsonb_set(
        jsonb_set(
          jsonb_set(
            COALESCE(NEW.metrics, '{}'::jsonb),
            '{actual_r}', to_jsonb(COALESCE(NEW.actual_r, 0))
          ),
          '{riskUSD}', to_jsonb(COALESCE(NEW.risk_usd, 0))
        ),
        '{rewardUSD}', to_jsonb(COALESCE(NEW.reward_usd, 0))
      ),
      '{rr}', to_jsonb(COALESCE(NEW.rr, 0))
    );
    
    NEW.outcome := CASE
      WHEN NEW.pnl > 0.01 THEN 'WIN'
      WHEN NEW.pnl < -0.01 THEN 'LOSS'
      ELSE 'BE'
    END;
    
    IF NEW.close_at IS NULL THEN
      NEW.close_at := NOW();
    END IF;
    
  ELSE
    -- Trade is open
    NEW.outcome := 'OPEN';
    NEW.pnl := 0;
    NEW.actual_r := NULL;
    
    IF user_one_r IS NOT NULL AND user_one_r > 0 THEN
      IF NEW.risk_usd IS NOT NULL THEN
        NEW.user_risk_r := ROUND(NEW.risk_usd / user_one_r, 4);
      END IF;
      IF NEW.reward_usd IS NOT NULL THEN
        NEW.user_reward_r := ROUND(NEW.reward_usd / user_one_r, 4);
      END IF;
    END IF;
    
    NEW.metrics := jsonb_set(
      jsonb_set(
        jsonb_set(
          COALESCE(NEW.metrics, '{}'::jsonb),
          '{riskUSD}', to_jsonb(COALESCE(NEW.risk_usd, 0))
        ),
        '{rewardUSD}', to_jsonb(COALESCE(NEW.reward_usd, 0))
      ),
      '{rr}', to_jsonb(COALESCE(NEW.rr, 0))
    );
  END IF;
  
  -- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  -- STEP 2: Update Portfolio (only on closed trades)
  -- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  IF NEW.exit_price IS NOT NULL THEN
    -- Get old PNL if updating
    IF TG_OP = 'UPDATE' AND OLD.exit_price IS NOT NULL THEN
      v_old_pnl := COALESCE(OLD.pnl, 0);
    END IF;
    
    -- Update profile
    UPDATE public.profiles
    SET 
      total_pnl = COALESCE(total_pnl, 0) - v_old_pnl + NEW.pnl,
      current_portfolio = initial_portfolio + (COALESCE(total_pnl, 0) - v_old_pnl + NEW.pnl),
      updated_at = NOW()
    WHERE id = NEW.user_id;
  END IF;
  
  -- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  -- STEP 3: Increment Trade Count (only on INSERT)
  -- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  IF TG_OP = 'INSERT' THEN
    -- Get account type
    SELECT account_type INTO v_account_type
    FROM public.profiles
    WHERE id = NEW.user_id;
    
    -- Update counters
    UPDATE public.profiles
    SET 
      billing_cycle_start = CASE 
        WHEN v_account_type IN ('basic', 'premium', 'trial') THEN
          CASE 
            WHEN billing_cycle_start IS NULL 
              OR billing_cycle_start < DATE_TRUNC('month', CURRENT_DATE)
            THEN DATE_TRUNC('month', CURRENT_DATE)::DATE
            ELSE billing_cycle_start
          END
        ELSE 
          COALESCE(billing_cycle_start, DATE_TRUNC('month', CURRENT_DATE)::DATE)
      END,
      current_month_trades_count = CASE
        WHEN v_account_type IN ('basic', 'premium', 'trial') THEN
          CASE
            WHEN billing_cycle_start IS NULL 
              OR billing_cycle_start < DATE_TRUNC('month', CURRENT_DATE)
            THEN 1
            ELSE COALESCE(current_month_trades_count, 0) + 1
          END
        ELSE 
          COALESCE(current_month_trades_count, 0) + 1
      END,
      trade_count = COALESCE(trade_count, 0) + 1
    WHERE id = NEW.user_id;
  END IF;
  
  RETURN NEW;
END;
$$;

-- ×™×¦×™×¨×ª ×”×˜×¨×™×’×¨ ×”×××•×—×“
DROP TRIGGER IF EXISTS handle_trade_changes_unified_trigger ON public.trades;

CREATE TRIGGER handle_trade_changes_unified_trigger
  BEFORE INSERT OR UPDATE ON public.trades
  FOR EACH ROW
  EXECUTE FUNCTION public.handle_trade_changes_unified();

COMMENT ON FUNCTION public.handle_trade_changes_unified IS 
'ğŸ”¥ UNIFIED TRIGGER v8.4: Calculates outcome + updates portfolio + increments counters. 3x faster!';

DO $$
BEGIN
  RAISE NOTICE 'âœ… Unified trigger created! Performance: 150ms â†’ 50ms';
END $$;

-- ===============================================
-- SECTION 4: TRADE LIMITS FUNCTIONS
-- ===============================================

DO $$
BEGIN
  RAISE NOTICE '[4/13] Creating trade limits functions...';
END $$;

-- ğŸ”¥ Drop RLS policy first (it depends on can_create_trade)
DROP POLICY IF EXISTS "trades_insert_own" ON public.trades;
DROP POLICY IF EXISTS "trades_insert_with_limits" ON public.trades;

-- âœ… Get Trade Limit
DROP FUNCTION IF EXISTS public.get_trade_limit(TEXT);

CREATE OR REPLACE FUNCTION public.get_trade_limit(plan_type TEXT)
RETURNS INTEGER 
LANGUAGE plpgsql
IMMUTABLE
AS $$
BEGIN
  RETURN CASE plan_type
    WHEN 'free' THEN 10
    WHEN 'basic' THEN 25
    WHEN 'premium' THEN 999999
    WHEN 'trial' THEN 25
    ELSE 10
  END;
END;
$$;

COMMENT ON FUNCTION public.get_trade_limit(TEXT) IS 
'v8.4: Returns trade limit: FREE=10 lifetime, BASIC/TRIAL=25/month, PREMIUM=unlimited';

-- âœ… Can Create Trade
DROP FUNCTION IF EXISTS public.can_create_trade(UUID);

CREATE OR REPLACE FUNCTION public.can_create_trade(user_id_param UUID)
RETURNS BOOLEAN 
LANGUAGE plpgsql
SECURITY DEFINER
STABLE
AS $$
DECLARE
  v_profile RECORD;
  v_limit INTEGER;
  v_trades_used INTEGER;
BEGIN
  SELECT 
    account_type,
    role,
    max_trades,
    COALESCE(current_month_trades_count, 0) as monthly_trades,
    COALESCE(trade_count, 0) as lifetime_trades
  INTO v_profile
  FROM public.profiles
  WHERE id = user_id_param;
  
  IF NOT FOUND THEN
    RETURN FALSE;
  END IF;
  
  -- Admins and Premium = unlimited
  IF v_profile.role IN ('admin', 'super_admin') OR 
     v_profile.account_type = 'premium' THEN
    RETURN TRUE;
  END IF;
  
  v_limit := get_trade_limit(v_profile.account_type);
  
  -- FREE users: check lifetime trades
  IF v_profile.account_type = 'free' THEN
    v_trades_used := v_profile.lifetime_trades;
  -- BASIC/TRIAL: check monthly trades
  ELSE
    v_trades_used := v_profile.monthly_trades;
  END IF;
  
  RETURN v_trades_used < v_limit;
END;
$$;

COMMENT ON FUNCTION public.can_create_trade(UUID) IS 
'v8.4: Checks trade limits: FREE uses lifetime count, BASIC/TRIAL use monthly count';

-- âœ… Get Remaining Trades
DROP FUNCTION IF EXISTS public.get_remaining_trades(UUID);

CREATE OR REPLACE FUNCTION public.get_remaining_trades(user_id_param UUID)
RETURNS TABLE (
  remaining INTEGER,
  used INTEGER,
  max_limit INTEGER,
  can_create BOOLEAN,
  account_type TEXT
)
LANGUAGE plpgsql
SECURITY DEFINER
STABLE
AS $$
DECLARE
  v_profile RECORD;
  v_trades_used INTEGER;
BEGIN
  SELECT 
    p.account_type,
    p.role,
    p.max_trades,
    COALESCE(p.current_month_trades_count, 0) as monthly_count,
    COALESCE(p.trade_count, 0) as lifetime_count
  INTO v_profile
  FROM public.profiles p
  WHERE p.id = user_id_param;
  
  IF NOT FOUND THEN
    RETURN QUERY SELECT 0, 0, 10, FALSE, 'free'::TEXT;
    RETURN;
  END IF;
  
  -- Unlimited for admins and premium
  IF v_profile.role IN ('admin', 'super_admin') OR 
     v_profile.account_type = 'premium' THEN
    v_trades_used := CASE 
      WHEN v_profile.account_type = 'free' THEN v_profile.lifetime_count
      ELSE v_profile.monthly_count
    END;
    
    RETURN QUERY SELECT 
      999999,
      v_trades_used,
      999999,
      TRUE,
      v_profile.account_type;
    RETURN;
  END IF;
  
  -- FREE: use lifetime count
  IF v_profile.account_type = 'free' THEN
    v_trades_used := v_profile.lifetime_count;
  -- BASIC/TRIAL: use monthly count
  ELSE
    v_trades_used := v_profile.monthly_count;
  END IF;
  
  RETURN QUERY SELECT
    GREATEST(0, v_profile.max_trades - v_trades_used),
    v_trades_used,
    v_profile.max_trades,
    (v_trades_used < v_profile.max_trades),
    v_profile.account_type;
END;
$$;

COMMENT ON FUNCTION public.get_remaining_trades(UUID) IS 
'v8.4: Returns trade info: FREE tracks lifetime, BASIC/TRIAL track monthly';

-- âœ… ğŸ”¥ UPDATED: Increment Monthly Trade Count - NO RESET FOR FREE!
DROP FUNCTION IF EXISTS public.increment_monthly_trade_count() CASCADE;

CREATE OR REPLACE FUNCTION public.increment_monthly_trade_count()
RETURNS TRIGGER 
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_account_type TEXT;
BEGIN
  -- Get account type
  SELECT account_type INTO v_account_type
  FROM public.profiles
  WHERE id = NEW.user_id;
  
  -- Update counters
  UPDATE public.profiles
  SET 
    billing_cycle_start = CASE 
      -- Only BASIC/PREMIUM/TRIAL get monthly reset
      WHEN v_account_type IN ('basic', 'premium', 'trial') THEN
        CASE 
          WHEN billing_cycle_start IS NULL 
            OR billing_cycle_start < DATE_TRUNC('month', CURRENT_DATE)
          THEN DATE_TRUNC('month', CURRENT_DATE)::DATE
          ELSE billing_cycle_start
        END
      -- FREE keeps original date (no reset)
      ELSE 
        COALESCE(billing_cycle_start, DATE_TRUNC('month', CURRENT_DATE)::DATE)
    END,
    current_month_trades_count = CASE
      -- Only BASIC/PREMIUM/TRIAL get monthly reset
      WHEN v_account_type IN ('basic', 'premium', 'trial') THEN
        CASE
          WHEN billing_cycle_start IS NULL 
            OR billing_cycle_start < DATE_TRUNC('month', CURRENT_DATE)
          THEN 1  -- Reset counter for new month
          ELSE COALESCE(current_month_trades_count, 0) + 1
        END
      -- FREE just increments (no reset)
      ELSE 
        COALESCE(current_month_trades_count, 0) + 1
    END,
    trade_count = COALESCE(trade_count, 0) + 1  -- Lifetime counter
  WHERE id = NEW.user_id;
  
  RETURN NEW;
END;
$$;

COMMENT ON FUNCTION public.increment_monthly_trade_count() IS 
'v8.4: Auto-resets for BASIC/PREMIUM/TRIAL. FREE gets 10 lifetime (no reset).';

-- ===============================================
-- SECTION 5: SEARCH & NOTES FUNCTIONS
-- ===============================================

DO $$
BEGIN
  RAISE NOTICE '[5/13] Creating search functions...';
END $$;

-- Update Search Vector
CREATE OR REPLACE FUNCTION public.update_trades_search_vector()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
BEGIN
  NEW.notes_search_vector := 
    setweight(to_tsvector('english', COALESCE(NEW.symbol, '')), 'A') ||
    setweight(to_tsvector('english', COALESCE(NEW.notes, '')), 'B') ||
    setweight(to_tsvector('english', COALESCE(NEW.setup, '')), 'C') ||
    setweight(to_tsvector('english', COALESCE(NEW.mistake, '')), 'D');
  RETURN NEW;
END;
$$;

-- Search Trades
CREATE OR REPLACE FUNCTION public.search_trades(
  search_query TEXT,
  target_user_id UUID DEFAULT NULL
)
RETURNS TABLE (
  id UUID,
  symbol TEXT,
  notes TEXT,
  setup TEXT,
  rank REAL
)
LANGUAGE plpgsql
SECURITY DEFINER
STABLE
AS $$
BEGIN
  RETURN QUERY
  SELECT 
    t.id,
    t.symbol,
    t.notes,
    t.setup,
    ts_rank(t.notes_search_vector, plainto_tsquery('english', search_query)) as rank
  FROM public.trades t
  WHERE 
    (target_user_id IS NULL OR t.user_id = target_user_id) AND
    t.notes_search_vector @@ plainto_tsquery('english', search_query)
  ORDER BY rank DESC
  LIMIT 50;
END;
$$;

-- Get Trade Details
CREATE OR REPLACE FUNCTION public.get_trade_details(trade_id UUID)
RETURNS TABLE (
  id UUID,
  user_id UUID,
  symbol TEXT,
  side TEXT,
  entry_price NUMERIC,
  exit_price NUMERIC,
  stop_price NUMERIC,
  take_profit_price NUMERIC,
  quantity NUMERIC,
  fees NUMERIC,
  pnl NUMERIC,
  outcome TEXT,
  multiplier NUMERIC,
  actual_r NUMERIC,
  user_risk_r NUMERIC,
  user_reward_r NUMERIC,
  risk_pts NUMERIC,
  reward_pts NUMERIC,
  rr NUMERIC,
  risk_usd NUMERIC,
  reward_usd NUMERIC,
  open_at TIMESTAMPTZ,
  close_at TIMESTAMPTZ,
  strategy_id UUID,
  strategy_name TEXT,
  notes TEXT,
  screenshot_url TEXT,
  screenshot_exists BOOLEAN,
  setup TEXT,
  mistake TEXT,
  next_time TEXT,
  quality_tag TEXT,
  session TEXT,
  asset_class TEXT,
  created_at TIMESTAMPTZ,
  updated_at TIMESTAMPTZ
)
LANGUAGE plpgsql
SECURITY DEFINER
STABLE
AS $$
BEGIN
  RETURN QUERY
  SELECT 
    t.id,
    t.user_id,
    t.symbol,
    t.side,
    t.entry_price,
    t.exit_price,
    t.stop_price,
    t.take_profit_price,
    t.quantity,
    t.fees,
    t.pnl,
    t.outcome,
    t.multiplier,
    t.actual_r,
    t.user_risk_r,
    t.user_reward_r,
    t.risk_pts,
    t.reward_pts,
    t.rr,
    t.risk_usd,
    t.reward_usd,
    t.open_at,
    t.close_at,
    t.strategy_id,
    s.name as strategy_name,
    t.notes,
    t.screenshot_url,
    (t.screenshot_url IS NOT NULL AND t.screenshot_url != '') as screenshot_exists,
    t.setup,
    t.mistake,
    t.next_time,
    t.quality_tag,
    t.session,
    t.asset_class,
    t.created_at,
    t.updated_at
  FROM public.trades t
  LEFT JOIN public.strategies s ON s.id = t.strategy_id
  WHERE t.id = trade_id
    AND (t.user_id = auth.uid() OR public.is_admin());
END;
$$;

-- Get Storage Usage
CREATE OR REPLACE FUNCTION public.get_user_storage_usage(target_user_id UUID DEFAULT NULL)
RETURNS TABLE (
  total_files BIGINT,
  total_size_bytes BIGINT,
  total_size_mb NUMERIC
)
LANGUAGE plpgsql
SECURITY DEFINER
STABLE
AS $$
DECLARE
  v_user_id UUID;
BEGIN
  v_user_id := COALESCE(target_user_id, auth.uid());
  
  RETURN QUERY
  SELECT 
    COUNT(*)::BIGINT as total_files,
    COALESCE(SUM((metadata->>'size')::BIGINT), 0) as total_size_bytes,
    ROUND(COALESCE(SUM((metadata->>'size')::NUMERIC) / 1048576, 0), 2) as total_size_mb
  FROM storage.objects
  WHERE bucket_id = 'trade-screenshots'
    AND (storage.foldername(name))[1] = v_user_id::text;
END;
$$;

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- ğŸ†• SNAPTRADE SECTION 5A: SYNC LOG HELPER FUNCTIONS
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

DO $$
BEGIN
  RAISE NOTICE '[5A/13] ğŸ†• Creating SnapTrade sync log functions...';
END $$;

-- Get latest sync for a user
CREATE OR REPLACE FUNCTION get_latest_sync_for_user(p_user_id UUID)
RETURNS public.snaptrade_sync_log AS $$
    SELECT * 
    FROM public.snaptrade_sync_log
    WHERE user_id = p_user_id
    ORDER BY created_at DESC
    LIMIT 1;
$$ LANGUAGE sql STABLE SECURITY DEFINER;

COMMENT ON FUNCTION get_latest_sync_for_user IS 
'v8.5.0: Gets the most recent sync log entry for a user';

-- Get sync stats for a user
CREATE OR REPLACE FUNCTION get_user_sync_stats(p_user_id UUID)
RETURNS TABLE (
    total_syncs BIGINT,
    successful_syncs BIGINT,
    failed_syncs BIGINT,
    total_trades_imported BIGINT,
    last_sync_at TIMESTAMPTZ,
    avg_sync_duration_seconds NUMERIC
) AS $$
    SELECT 
        COUNT(*)::BIGINT as total_syncs,
        COUNT(*) FILTER (WHERE status = 'completed')::BIGINT as successful_syncs,
        COUNT(*) FILTER (WHERE status = 'failed')::BIGINT as failed_syncs,
        COALESCE(SUM(trades_imported), 0)::BIGINT as total_trades_imported,
        MAX(created_at) as last_sync_at,
        ROUND(AVG(duration_seconds)::NUMERIC, 2) as avg_sync_duration_seconds
    FROM public.snaptrade_sync_log
    WHERE user_id = p_user_id;
$$ LANGUAGE sql STABLE SECURITY DEFINER;

COMMENT ON FUNCTION get_user_sync_stats IS 
'v8.5.0: Gets aggregated sync statistics for a user';

-- Cleanup old sync logs (keep last 100 per user)
CREATE OR REPLACE FUNCTION cleanup_old_sync_logs()
RETURNS INT AS $$
DECLARE
    deleted_count INT;
BEGIN
    WITH logs_to_keep AS (
        SELECT id
        FROM (
            SELECT id, 
                   ROW_NUMBER() OVER (PARTITION BY user_id ORDER BY created_at DESC) as rn
            FROM public.snaptrade_sync_log
        ) ranked
        WHERE rn <= 100
    )
    DELETE FROM public.snaptrade_sync_log
    WHERE id NOT IN (SELECT id FROM logs_to_keep);
    
    GET DIAGNOSTICS deleted_count = ROW_COUNT;
    RETURN deleted_count;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

COMMENT ON FUNCTION cleanup_old_sync_logs IS 
'v8.5.0: Deletes old sync logs, keeping only the last 100 per user';

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- ğŸ†• SNAPTRADE SECTION 5B: STATUS FUNCTIONS
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

DO $$
BEGIN
  RAISE NOTICE '[5B/13] ğŸ†• Creating SnapTrade status functions...';
END $$;

-- Check if user has SnapTrade connected
CREATE OR REPLACE FUNCTION is_snaptrade_connected(p_user_id UUID)
RETURNS BOOLEAN AS $$
    SELECT EXISTS (
        SELECT 1 
        FROM snaptrade_users 
        WHERE user_id = p_user_id
    );
$$ LANGUAGE sql STABLE SECURITY DEFINER;

COMMENT ON FUNCTION is_snaptrade_connected IS 
'v8.5.0: Returns true if user has SnapTrade connected';

-- Get last successful sync date
CREATE OR REPLACE FUNCTION get_last_successful_sync_date(p_user_id UUID)
RETURNS TIMESTAMPTZ AS $$
    SELECT MAX(sync_completed_at)
    FROM snaptrade_sync_log
    WHERE user_id = p_user_id
    AND status = 'completed';
$$ LANGUAGE sql STABLE SECURITY DEFINER;

COMMENT ON FUNCTION get_last_successful_sync_date IS 
'v8.5.0: Returns the date of the last successful sync';

-- Count pending trades
CREATE OR REPLACE FUNCTION count_pending_snaptrade_trades(p_user_id UUID)
RETURNS INT AS $$
DECLARE
    last_sync_record RECORD;
    imported_count INT;
BEGIN
    -- Get last sync attempt
    SELECT * INTO last_sync_record
    FROM snaptrade_sync_log
    WHERE user_id = p_user_id
    AND status = 'running'
    ORDER BY sync_started_at DESC
    LIMIT 1;
    
    IF last_sync_record IS NULL THEN
        RETURN 0;
    END IF;
    
    -- Count trades imported during this sync
    SELECT COUNT(*) INTO imported_count
    FROM trades
    WHERE user_id = p_user_id
    AND import_source = 'snaptrade'
    AND imported_at >= last_sync_record.sync_started_at;
    
    RETURN imported_count;
END;
$$ LANGUAGE plpgsql STABLE SECURITY DEFINER;

COMMENT ON FUNCTION count_pending_snaptrade_trades IS 
'v8.5.0: Counts trades from current running sync';

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- ğŸ†• SNAPTRADE SECTION 5C: ANALYTICS FUNCTIONS
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

DO $$
BEGIN
  RAISE NOTICE '[5C/13] ğŸ†• Creating SnapTrade analytics functions...';
END $$;

-- Get SnapTrade import statistics for a date range
CREATE OR REPLACE FUNCTION get_snaptrade_import_stats(
    p_user_id UUID,
    p_start_date DATE DEFAULT NULL,
    p_end_date DATE DEFAULT NULL
)
RETURNS TABLE (
    total_imports INT,
    unique_symbols INT,
    total_commission NUMERIC,
    buy_count INT,
    sell_count INT,
    avg_trade_size NUMERIC,
    date_range_start DATE,
    date_range_end DATE
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        COUNT(*)::INT as total_imports,
        COUNT(DISTINCT symbol)::INT as unique_symbols,
        ROUND(SUM(fees)::NUMERIC, 2) as total_commission,
        COUNT(*) FILTER (WHERE side = 'LONG')::INT as buy_count,
        COUNT(*) FILTER (WHERE side = 'SHORT')::INT as sell_count,
        ROUND(AVG(quantity * entry_price)::NUMERIC, 2) as avg_trade_size,
        COALESCE(p_start_date, MIN(open_at::DATE)) as date_range_start,
        COALESCE(p_end_date, MAX(open_at::DATE)) as date_range_end
    FROM trades
    WHERE user_id = p_user_id
    AND import_source = 'snaptrade'
    AND (p_start_date IS NULL OR open_at::DATE >= p_start_date)
    AND (p_end_date IS NULL OR open_at::DATE <= p_end_date);
END;
$$ LANGUAGE plpgsql STABLE SECURITY DEFINER;

COMMENT ON FUNCTION get_snaptrade_import_stats IS 
'v8.5.0: Gets detailed statistics for SnapTrade imports in a date range';

-- Find duplicate SnapTrade activities
CREATE OR REPLACE FUNCTION find_duplicate_snaptrade_activities(p_user_id UUID)
RETURNS TABLE (
    snaptrade_activity_id TEXT,
    duplicate_count BIGINT,
    trade_ids UUID[]
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        t.snaptrade_activity_id,
        COUNT(*)::BIGINT as duplicate_count,
        ARRAY_AGG(t.id) as trade_ids
    FROM trades t
    WHERE t.user_id = p_user_id
    AND t.snaptrade_activity_id IS NOT NULL
    GROUP BY t.snaptrade_activity_id
    HAVING COUNT(*) > 1;
END;
$$ LANGUAGE plpgsql STABLE SECURITY DEFINER;

COMMENT ON FUNCTION find_duplicate_snaptrade_activities IS 
'v8.5.0: Finds any duplicate SnapTrade imports (should be none)';

DO $$
BEGIN
  RAISE NOTICE 'âœ… SnapTrade helper functions created';
END $$;

-- ===============================================
-- ğŸ”’ SECTION 6: PAYMENT SECURITY & AFFILIATE AUTOMATION
-- ===============================================

DO $$
BEGIN
  RAISE NOTICE '';
  RAISE NOTICE '[6/13] ğŸ”’ Creating payment security functions...';
END $$;

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- 1. ×¢×“×›×•×Ÿ ×¤×•× ×§×¦×™×™×ª ×”×ª×©×œ×•× (×¢× ××•×˜×•××¦×™×” ×œ××¤×™×œ×™×™×˜) - FIXED v5
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

CREATE OR REPLACE FUNCTION public.update_account_type_on_payment()
RETURNS TRIGGER 
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_max_trades INTEGER;
  v_subscription_interval TEXT;
  v_referral_record RECORD;
  v_referral_found BOOLEAN := FALSE;
BEGIN
  -- ×¨×§ ×× ×”×ª×©×œ×•× ×”×¦×œ×™×—
  IF NEW.status = 'completed' AND (OLD IS NULL OR OLD.status != 'completed') THEN
    
    v_max_trades := get_trade_limit(NEW.plan);
    v_subscription_interval := CASE 
      WHEN NEW.amount > 100 THEN 'yearly'
      ELSE 'monthly'
    END;
    
    -- ×¢×“×›×Ÿ ××ª ×”×—×©×‘×•×Ÿ
    UPDATE public.profiles
    SET 
      account_type = NEW.plan,
      max_trades = v_max_trades,
      subscription_interval = v_subscription_interval,
      subscription_status = 'active',
      subscription_started_at = NOW(),
      subscription_expires_at = CASE 
        WHEN v_subscription_interval = 'yearly' THEN NOW() + INTERVAL '1 year'
        ELSE NOW() + INTERVAL '1 month'
      END,
      updated_at = NOW()
    WHERE id = NEW.user_id;
    
    -- ×¦×•×¨ ×ª×§×•×¤×ª ×× ×•×™
    INSERT INTO public.subscription_periods (
      user_id, plan, payplus_transaction_id, period_start, period_end, auto_renew
    ) VALUES (
      NEW.user_id, 
      NEW.plan, 
      NEW.payplus_transaction_id, 
      NOW(),
      CASE 
        WHEN v_subscription_interval = 'yearly' THEN NOW() + INTERVAL '1 year'
        ELSE NOW() + INTERVAL '1 month'
      END,
      TRUE
    ) ON CONFLICT DO NOTHING;
    
    -- âœ¨ ×—×“×©: ×‘×“×•×§ ×× ×”××©×ª××© ×”×•×¤× ×” ×•×ª×Ÿ ×¤×¨×¡ ×œ××¤× ×”
    -- ğŸ”¥ FIXED v5: Use FOR loop for ORDER BY
    FOR v_referral_record IN
      SELECT r.* 
      FROM public.referrals r
      WHERE r.referred_id = NEW.user_id 
        AND r.status = 'pending'
        AND r.converted_to_paid = FALSE
      ORDER BY r.created_at DESC
      LIMIT 1
    LOOP
      v_referral_found := TRUE;
      RAISE NOTICE '××©×ª××© % ×”×•×¤× ×” - ××¢× ×™×§ ×¤×¨×¡ ×œ×”×¤× ×™×” %', NEW.user_id, v_referral_record.id;
      
      BEGIN
        PERFORM complete_referral_and_grant_rewards(v_referral_record.id);
        RAISE NOTICE '×”×¤× ×™×” % ×”×•×©×œ××” ×‘×”×¦×œ×—×”', v_referral_record.id;
      EXCEPTION WHEN OTHERS THEN
        RAISE WARNING '×©×’×™××” ×‘×”×©×œ××ª ×”×¤× ×™×” %: %', v_referral_record.id, SQLERRM;
      END;
      
      EXIT;  -- Take only first result
    END LOOP;
    
    IF NOT v_referral_found THEN
      RAISE NOTICE '×œ× × ××¦××” ×”×¤× ×™×” ×¤×¢×™×œ×” ×¢×‘×•×¨ ××©×ª××© %', NEW.user_id;
    END IF;
    
  END IF;
  
  RETURN NEW;
END;
$$;

COMMENT ON FUNCTION public.update_account_type_on_payment IS 
'v8.4.4-FIXED-v5: ××¢×“×›×Ÿ ×—×©×‘×•×Ÿ ×¨×§ ×œ××—×¨ ×ª×©×œ×•× ××•×¦×œ×—. ××¤×¢×™×œ ××•×˜×•××˜×™×ª ×¤×¨×¡×™ ××¤×™×œ×™×™×˜.';

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- 2. ×¤×•× ×§×¦×™×” ×—×“×©×”: ×‘×“×™×§×ª ×’×™×©×” ×œ×ª×©×œ×•×
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

CREATE OR REPLACE FUNCTION public.verify_paid_access(p_user_id UUID)
RETURNS BOOLEAN
LANGUAGE plpgsql
SECURITY DEFINER
STABLE
AS $$
DECLARE
  v_profile RECORD;
  v_has_valid_payment BOOLEAN;
BEGIN
  SELECT 
    account_type,
    role,
    subscription_status,
    subscription_expires_at,
    free_months_available
  INTO v_profile
  FROM public.profiles
  WHERE id = p_user_id;
  
  IF NOT FOUND THEN
    RETURN FALSE;
  END IF;
  
  -- ×ª××™×“ ×œ××¤×©×¨: ××“××™× ×™× ×•××©×ª××©×™ FREE
  IF v_profile.role IN ('admin', 'super_admin') OR v_profile.account_type = 'free' THEN
    RETURN TRUE;
  END IF;
  
  -- ×œ××¤×©×¨: ××©×ª××©×™× ×¢× ×—×•×“×©×™× ×—×™× × ×–××™× ×™×
  IF v_profile.free_months_available > 0 THEN
    RETURN TRUE;
  END IF;
  
  -- ×œ××¤×©×¨: ××©×ª××©×™× ×¢× ×× ×•×™ ×¤×¢×™×œ ×©×œ× ×¤×’
  IF v_profile.subscription_status = 'active' 
     AND v_profile.subscription_expires_at IS NOT NULL 
     AND v_profile.subscription_expires_at > NOW() THEN
    
    -- ×‘×“×™×§×” ×›×¤×•×œ×”: ×—×™×™×‘ ×œ×”×™×•×ª ×œ×¤×—×•×ª ×ª×©×œ×•× ××—×“ ××•×¦×œ×—
    SELECT EXISTS(
      SELECT 1 
      FROM public.payment_history 
      WHERE user_id = p_user_id 
        AND status = 'completed'
    ) INTO v_has_valid_payment;
    
    RETURN v_has_valid_payment;
  END IF;
  
  -- ×œ×“×—×•×ª: ×›×œ ×”×©××¨
  RETURN FALSE;
END;
$$;

COMMENT ON FUNCTION public.verify_paid_access IS 
'v8.4: ××•×•×“× ×©×”××©×ª××© ×©×™×œ× ××• ×©×™×© ×œ×• ×—×•×“×©×™× ×—×™× × ××• ×©×”×•× ××“××™×Ÿ ×œ×¤× ×™ ××ª×Ÿ ×’×™×©×”';

GRANT EXECUTE ON FUNCTION public.verify_paid_access TO authenticated;

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- 3. ×¤×•× ×§×¦×™×” ×œ××“××™×Ÿ: ××ª×Ÿ ×’×™×©×” ×™×“× ×™×ª (×œ×¢×§×•×£ ×ª×©×œ×•×)
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

CREATE OR REPLACE FUNCTION public.admin_grant_free_access(
  p_user_id UUID,
  p_months INTEGER,
  p_reason TEXT DEFAULT 'Admin grant'
)
RETURNS VOID
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  IF NOT is_admin() THEN
    RAISE EXCEPTION 'Unauthorized - Admin access required';
  END IF;
  
  -- ×ª×Ÿ ×—×•×“×©×™× ×—×™× ×
  UPDATE public.profiles
  SET 
    free_months_available = COALESCE(free_months_available, 0) + p_months,
    subscription_expires_at = CASE
      WHEN subscription_expires_at IS NULL OR subscription_expires_at < NOW() 
      THEN NOW() + (p_months || ' months')::INTERVAL
      ELSE subscription_expires_at + (p_months || ' months')::INTERVAL
    END,
    subscription_status = 'active',
    updated_at = NOW()
  WHERE id = p_user_id;
  
  -- ×¨×©×•× ××ª ×”×¤×¢×•×œ×”
  INSERT INTO public.free_months_credits (
    user_id, 
    months_earned, 
    applied,
    metadata
  ) VALUES (
    p_user_id,
    p_months,
    TRUE,
    jsonb_build_object(
      'granted_by', 'admin',
      'admin_id', auth.uid(),
      'reason', p_reason,
      'granted_at', NOW()
    )
  );
  
  PERFORM log_admin_action(
    'GRANT_FREE_ACCESS',
    p_user_id,
    'free_months',
    p_user_id,
    jsonb_build_object(
      'months_granted', p_months,
      'reason', p_reason
    )
  );
END;
$$;

-- ===============================================
-- ğŸ†• SECTION 6.5: ADVANCED SUBSCRIPTION MANAGEMENT
-- ===============================================

DO $$
BEGIN
  RAISE NOTICE '';
  RAISE NOTICE '[6.5/13] ğŸ’ Creating advanced subscription functions...';
  RAISE NOTICE '         ğŸ“Š Proration support';
  RAISE NOTICE '         ğŸ”„ Smart renewals';
  RAISE NOTICE '         â¬†ï¸  Mid-cycle upgrades';
  RAISE NOTICE '         ğŸš« Graceful cancellations';
END $$;

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- 6.5.1: Get Current Pricing - FIXED v5
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

CREATE OR REPLACE FUNCTION public.get_current_price(
  p_plan TEXT,
  p_interval TEXT
)
RETURNS NUMERIC
LANGUAGE plpgsql
STABLE
AS $$
DECLARE
  v_price NUMERIC;
  v_found BOOLEAN := FALSE;
BEGIN
  -- ğŸ”¥ FIXED v5: Use FOR loop for ORDER BY
  FOR v_price IN
    SELECT price
    FROM public.pricing_config
    WHERE plan = p_plan
      AND interval = p_interval
      AND is_active = TRUE
      AND (valid_until IS NULL OR valid_until > NOW())
    ORDER BY valid_from DESC
    LIMIT 1
  LOOP
    v_found := TRUE;
    EXIT;
  END LOOP;
  
  -- Return found price or fallback
  IF v_found THEN
    RETURN v_price;
  END IF;
  
  -- Fallback to hardcoded prices if not found
  RETURN CASE
    WHEN p_plan = 'basic' AND p_interval = 'monthly' THEN 15.99
    WHEN p_plan = 'basic' AND p_interval = 'yearly' THEN 155.88
    WHEN p_plan = 'premium' AND p_interval = 'monthly' THEN 24.99
    WHEN p_plan = 'premium' AND p_interval = 'yearly' THEN 239.88
    ELSE 0
  END;
END;
$$;

COMMENT ON FUNCTION public.get_current_price IS 
'v8.4.4-FIXED-v5: Get current active price for a plan/interval combination';

GRANT EXECUTE ON FUNCTION public.get_current_price TO authenticated;

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- 6.5.2: Calculate Proration for Upgrades
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

CREATE OR REPLACE FUNCTION public.calculate_prorated_upgrade(
  p_user_id UUID,
  p_new_plan TEXT,
  p_new_interval TEXT
)
RETURNS JSONB
LANGUAGE plpgsql
STABLE
SECURITY DEFINER
AS $$
DECLARE
  v_current_profile RECORD;
  v_days_remaining INTEGER;
  v_days_in_period INTEGER;
  v_old_daily_rate NUMERIC;
  v_new_daily_rate NUMERIC;
  v_old_price NUMERIC;
  v_new_price NUMERIC;
  v_unused_credit NUMERIC;
  v_prorated_amount NUMERIC;
  v_discount NUMERIC;
BEGIN
  -- 1. Get current subscription details
  SELECT 
    account_type,
    subscription_interval,
    subscription_expires_at,
    subscription_started_at
  INTO v_current_profile
  FROM public.profiles
  WHERE id = p_user_id;
  
  IF v_current_profile.account_type = 'free' THEN
    -- New subscription, no proration
    v_new_price := public.get_current_price(p_new_plan, p_new_interval);
    
    RETURN jsonb_build_object(
      'is_new_subscription', true,
      'amount_to_charge', v_new_price,
      'prorated', false,
      'new_plan', p_new_plan,
      'new_interval', p_new_interval
    );
  END IF;
  
  -- 2. Check if this is actually an upgrade
  IF (p_new_plan = 'basic' AND v_current_profile.account_type = 'premium') THEN
    RETURN jsonb_build_object(
      'error', 'Downgrade not supported mid-cycle. Cancel and resubscribe at end of period.',
      'is_downgrade', true
    );
  END IF;
  
  -- 3. Calculate days remaining
  v_days_remaining := EXTRACT(DAY FROM (v_current_profile.subscription_expires_at - NOW()));
  
  IF v_days_remaining <= 0 THEN
    -- Subscription expired, treat as new
    v_new_price := public.get_current_price(p_new_plan, p_new_interval);
    
    RETURN jsonb_build_object(
      'is_new_subscription', true,
      'amount_to_charge', v_new_price,
      'prorated', false,
      'reason', 'Previous subscription expired'
    );
  END IF;
  
  -- 4. Calculate days in original period
  v_days_in_period := EXTRACT(DAY FROM (
    v_current_profile.subscription_expires_at - v_current_profile.subscription_started_at
  ));
  
  -- 5. Get prices
  v_old_price := public.get_current_price(
    v_current_profile.account_type,
    v_current_profile.subscription_interval
  );
  
  v_new_price := public.get_current_price(p_new_plan, p_new_interval);
  
  -- 6. Calculate daily rates
  v_old_daily_rate := v_old_price / NULLIF(v_days_in_period, 0);
  v_new_daily_rate := v_new_price / CASE p_new_interval
    WHEN 'monthly' THEN 30
    WHEN 'yearly' THEN 365
  END;
  
  -- 7. Calculate unused credit from old plan
  v_unused_credit := v_old_daily_rate * v_days_remaining;
  
  -- 8. Calculate prorated amount for remaining days at new rate
  v_prorated_amount := v_new_daily_rate * v_days_remaining;
  
  -- 9. Final charge = new period price - unused credit + prorated upgrade
  v_discount := v_unused_credit;
  
  RETURN jsonb_build_object(
    'is_upgrade', true,
    'prorated', true,
    'old_plan', v_current_profile.account_type,
    'new_plan', p_new_plan,
    'old_interval', v_current_profile.subscription_interval,
    'new_interval', p_new_interval,
    'days_remaining', v_days_remaining,
    'old_price', ROUND(v_old_price, 2),
    'new_price', ROUND(v_new_price, 2),
    'unused_credit', ROUND(v_unused_credit, 2),
    'prorated_charge_for_remaining_days', ROUND(v_prorated_amount, 2),
    'discount_applied', ROUND(v_discount, 2),
    'amount_to_charge', ROUND(v_new_price - v_discount + v_prorated_amount, 2),
    'explanation', format(
      '×—×™×©×•×‘: %s ×™××™× × ×•×ª×¨×• ××”×× ×•×™ ×”×§×•×“×. ×–×™×›×•×™: $%s. ××—×™×¨ ×—×“×©: $%s. ×ª×©×œ×•× ×¢×›×©×™×•: $%s',
      v_days_remaining,
      ROUND(v_discount, 2),
      ROUND(v_new_price, 2),
      ROUND(v_new_price - v_discount + v_prorated_amount, 2)
    )
  );
END;
$$;

COMMENT ON FUNCTION public.calculate_prorated_upgrade IS 
'ğŸ”¥ SMART PRORATION: Calculates exact charge for mid-cycle upgrades with credit from unused days';

GRANT EXECUTE ON FUNCTION public.calculate_prorated_upgrade TO authenticated;

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- 6.5.3: Process Upgrade with Proration
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

CREATE OR REPLACE FUNCTION public.process_subscription_upgrade(
  p_user_id UUID,
  p_new_plan TEXT,
  p_new_interval TEXT,
  p_payplus_transaction_id TEXT,
  p_amount_paid NUMERIC
)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_proration_calc JSONB;
  v_old_profile RECORD;
  v_new_expires_at TIMESTAMPTZ;
  v_result JSONB;
BEGIN
  -- 1. Validate inputs
  IF p_new_plan NOT IN ('basic', 'premium') THEN
    RETURN jsonb_build_object('success', false, 'error', 'Invalid plan');
  END IF;
  
  IF p_new_interval NOT IN ('monthly', 'yearly') THEN
    RETURN jsonb_build_object('success', false, 'error', 'Invalid interval');
  END IF;
  
  -- 2. Get current profile state
  SELECT * INTO v_old_profile
  FROM public.profiles
  WHERE id = p_user_id;
  
  IF NOT FOUND THEN
    RETURN jsonb_build_object('success', false, 'error', 'User not found');
  END IF;
  
  -- 3. Calculate proration
  v_proration_calc := public.calculate_prorated_upgrade(p_user_id, p_new_plan, p_new_interval);
  
  IF v_proration_calc->>'error' IS NOT NULL THEN
    RETURN jsonb_build_object('success', false, 'error', v_proration_calc->>'error');
  END IF;
  
  -- 4. Calculate new expiration date
  v_new_expires_at := CASE p_new_interval
    WHEN 'monthly' THEN NOW() + INTERVAL '1 month'
    WHEN 'yearly' THEN NOW() + INTERVAL '1 year'
  END;
  
  -- 5. Update profile
  UPDATE public.profiles
  SET 
    previous_account_type = v_old_profile.account_type,
    account_type = p_new_plan,
    subscription_interval = p_new_interval,
    subscription_status = 'active',
    payment_provider = 'payplus',
    subscription_started_at = NOW(),
    subscription_expires_at = v_new_expires_at,
    upgrade_date = NOW(),
    prorated_credit = (v_proration_calc->>'unused_credit')::NUMERIC,
    max_trades = public.get_trade_limit(p_new_plan),
    billing_cycle_start = CURRENT_DATE,
    current_month_trades_count = 0,  -- Reset for new cycle
    updated_at = NOW()
  WHERE id = p_user_id;
  
  -- 6. Log payment with proration details
  INSERT INTO public.payment_history (
    user_id,
    amount,
    currency,
    status,
    plan,
    payplus_transaction_id,
    payment_type,
    is_prorated,
    prorated_days,
    original_amount,
    discount_amount,
    created_at
  ) VALUES (
    p_user_id,
    p_amount_paid,
    'USD',
    'completed',
    p_new_plan,
    p_payplus_transaction_id,
    'upgrade',
    (v_proration_calc->>'prorated')::BOOLEAN,
    (v_proration_calc->>'days_remaining')::INTEGER,
    (v_proration_calc->>'new_price')::NUMERIC,
    (v_proration_calc->>'discount_applied')::NUMERIC,
    NOW()
  );
  
  -- 7. Create new subscription period
  INSERT INTO public.subscription_periods (
    user_id,
    plan,
    payplus_transaction_id,
    period_start,
    period_end,
    auto_renew,
    created_at
  ) VALUES (
    p_user_id,
    p_new_plan,
    p_payplus_transaction_id,
    NOW(),
    v_new_expires_at,
    TRUE,
    NOW()
  );
  
  -- 8. Log the change
  INSERT INTO public.subscription_changes (
    user_id,
    change_type,
    from_plan,
    to_plan,
    from_interval,
    to_interval,
    effective_date,
    prorated_amount,
    prorated_days,
    metadata
  ) VALUES (
    p_user_id,
    'upgrade',
    v_old_profile.account_type,
    p_new_plan,
    v_old_profile.subscription_interval,
    p_new_interval,
    NOW(),
    p_amount_paid,
    (v_proration_calc->>'days_remaining')::INTEGER,
    v_proration_calc
  );
  
  -- 9. Admin audit log
  PERFORM public.log_admin_action(
    'SUBSCRIPTION_UPGRADE',
    p_user_id,
    'subscription',
    p_user_id,
    jsonb_build_object(
      'from_plan', v_old_profile.account_type,
      'to_plan', p_new_plan,
      'prorated', v_proration_calc->>'prorated',
      'amount_paid', p_amount_paid,
      'transaction_id', p_payplus_transaction_id
    )
  );
  
  -- 10. Return success
  v_result := jsonb_build_object(
    'success', true,
    'message', format('Upgraded to %s (%s) successfully!', p_new_plan, p_new_interval),
    'data', jsonb_build_object(
      'new_plan', p_new_plan,
      'new_interval', p_new_interval,
      'expires_at', v_new_expires_at,
      'amount_paid', p_amount_paid,
      'proration_details', v_proration_calc
    )
  );
  
  RAISE NOTICE 'âœ… Subscription upgraded: % â†’ % (prorated: $%)', 
    v_old_profile.account_type, p_new_plan, p_amount_paid;
  
  RETURN v_result;
END;
$$;

COMMENT ON FUNCTION public.process_subscription_upgrade IS 
'ğŸš€ SMART UPGRADE: Handles mid-cycle upgrades with automatic proration calculation';

GRANT EXECUTE ON FUNCTION public.process_subscription_upgrade TO service_role;

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- 6.5.4: Renew Subscription (Auto-Renewal) - FIXED v5
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

DROP FUNCTION IF EXISTS public.renew_subscription(UUID, TEXT, NUMERIC);

CREATE OR REPLACE FUNCTION public.renew_subscription(
  p_user_id UUID,
  p_payplus_transaction_id TEXT,
  p_amount NUMERIC
)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_current_period RECORD;
  v_profile RECORD;
  v_new_period_end TIMESTAMPTZ;
  v_expected_amount NUMERIC;
  v_period_found BOOLEAN := FALSE;
BEGIN
  -- 1. Get current profile
  SELECT * INTO v_profile
  FROM public.profiles
  WHERE id = p_user_id;
  
  IF NOT FOUND THEN
    RETURN jsonb_build_object('success', false, 'error', 'User not found');
  END IF;
  
  -- 2. Find active subscription period using FOR loop (ğŸ”¥ FIXED v5!)
  FOR v_current_period IN
    SELECT * 
    FROM public.subscription_periods
    WHERE user_id = p_user_id
      AND auto_renew = TRUE
      AND period_end > NOW()
    ORDER BY period_end DESC
    LIMIT 1
  LOOP
    v_period_found := TRUE;
    EXIT;
  END LOOP;
  
  -- 3. Check if period was found
  IF NOT v_period_found THEN
    RETURN jsonb_build_object(
      'success', false,
      'error', 'No active subscription found for renewal'
    );
  END IF;
  
  -- 4. Verify amount matches expected price
  v_expected_amount := public.get_current_price(
    v_profile.account_type,
    v_profile.subscription_interval
  );
  
  IF ABS(p_amount - v_expected_amount) > 0.10 THEN
    RAISE WARNING 'Renewal amount mismatch: expected $%, got $%', 
      v_expected_amount, p_amount;
  END IF;
  
  -- 5. Calculate new period end
  v_new_period_end := CASE v_profile.subscription_interval
    WHEN 'monthly' THEN v_current_period.period_end + INTERVAL '1 month'
    WHEN 'yearly' THEN v_current_period.period_end + INTERVAL '1 year'
    ELSE NOW() + INTERVAL '1 month'
  END;
  
  -- 6. Update profile
  UPDATE public.profiles
  SET 
    subscription_expires_at = v_new_period_end,
    subscription_status = 'active',
    updated_at = NOW()
  WHERE id = p_user_id;
  
  -- 7. Log payment
  INSERT INTO public.payment_history (
    user_id,
    amount,
    currency,
    status,
    plan,
    payplus_transaction_id,
    payment_type,
    created_at
  ) VALUES (
    p_user_id,
    p_amount,
    'USD',
    'completed',
    v_profile.account_type,
    p_payplus_transaction_id,
    'renewal',
    NOW()
  );
  
  -- 8. Create new period
  INSERT INTO public.subscription_periods (
    user_id,
    plan,
    payplus_transaction_id,
    period_start,
    period_end,
    auto_renew,
    created_at
  ) VALUES (
    p_user_id,
    v_profile.account_type,
    p_payplus_transaction_id,
    v_current_period.period_end,
    v_new_period_end,
    TRUE,
    NOW()
  );
  
  -- 9. Log change
  INSERT INTO public.subscription_changes (
    user_id,
    change_type,
    from_plan,
    to_plan,
    effective_date,
    metadata
  ) VALUES (
    p_user_id,
    'renew',
    v_profile.account_type,
    v_profile.account_type,
    NOW(),
    jsonb_build_object(
      'previous_end', v_current_period.period_end,
      'new_end', v_new_period_end,
      'transaction_id', p_payplus_transaction_id
    )
  );
  
  RAISE NOTICE 'âœ… Subscription renewed: % until %', 
    v_profile.account_type, v_new_period_end;
  
  RETURN jsonb_build_object(
    'success', true,
    'message', 'Subscription renewed successfully',
    'data', jsonb_build_object(
      'plan', v_profile.account_type,
      'interval', v_profile.subscription_interval,
      'new_period_end', v_new_period_end,
      'transaction_id', p_payplus_transaction_id
    )
  );
END;
$$;

COMMENT ON FUNCTION public.renew_subscription IS 
'v8.4.4-FIXED-v5: ğŸ”„ AUTO-RENEWAL: Handles automatic subscription renewals from PayPlus webhooks';

GRANT EXECUTE ON FUNCTION public.renew_subscription TO service_role;

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- 6.5.5: Cancel Subscription (Graceful) - FIXED v5
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

CREATE OR REPLACE FUNCTION public.cancel_subscription(
  p_user_id UUID,
  p_reason TEXT DEFAULT NULL,
  p_immediate BOOLEAN DEFAULT FALSE
)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_profile RECORD;
  v_current_period RECORD;
  v_effective_date TIMESTAMPTZ;
  v_days_remaining INTEGER;
  v_period_found BOOLEAN := FALSE;
BEGIN
  -- 1. Get profile
  SELECT * INTO v_profile
  FROM public.profiles
  WHERE id = p_user_id;
  
  IF NOT FOUND THEN
    RETURN jsonb_build_object('success', false, 'error', 'User not found');
  END IF;
  
  IF v_profile.account_type = 'free' THEN
    RETURN jsonb_build_object('success', false, 'error', 'No active subscription to cancel');
  END IF;
  
  -- 2. Find current period (ğŸ”¥ FIXED v5: using FOR loop)
  FOR v_current_period IN
    SELECT *
    FROM public.subscription_periods
    WHERE user_id = p_user_id
      AND period_end > NOW()
      AND canceled_at IS NULL
    ORDER BY period_end DESC
    LIMIT 1
  LOOP
    v_period_found := TRUE;
    EXIT;
  END LOOP;
  
  -- 3. Determine effective date
  IF p_immediate THEN
    v_effective_date := NOW();
  ELSE
    v_effective_date := COALESCE(
      CASE WHEN v_period_found THEN v_current_period.period_end ELSE NULL END,
      v_profile.subscription_expires_at
    );
  END IF;
  
  v_days_remaining := EXTRACT(DAY FROM (v_effective_date - NOW()));
  
  -- 4. Mark period as canceled
  IF v_period_found THEN
    UPDATE public.subscription_periods
    SET 
      canceled_at = NOW(),
      auto_renew = FALSE,
      updated_at = NOW()
    WHERE id = v_current_period.id;
  END IF;
  
  -- 5. Update profile
  UPDATE public.profiles
  SET 
    subscription_status = CASE 
      WHEN p_immediate THEN 'expired'
      ELSE 'cancelled'
    END,
    cancellation_reason = p_reason,
    cancellation_requested_at = NOW(),
    cancellation_effective_date = v_effective_date,
    updated_at = NOW()
  WHERE id = p_user_id;
  
  -- 6. If immediate, downgrade now
  IF p_immediate THEN
    UPDATE public.profiles
    SET 
      previous_account_type = account_type,
      account_type = 'free',
      max_trades = 10,
      subscription_interval = NULL,
      payment_provider = NULL,
      subscription_expires_at = NOW()
    WHERE id = p_user_id;
  END IF;
  
  -- 7. Log change
  INSERT INTO public.subscription_changes (
    user_id,
    change_type,
    from_plan,
    to_plan,
    effective_date,
    reason,
    metadata
  ) VALUES (
    p_user_id,
    'cancel',
    v_profile.account_type,
    CASE WHEN p_immediate THEN 'free' ELSE v_profile.account_type END,
    v_effective_date,
    p_reason,
    jsonb_build_object(
      'immediate', p_immediate,
      'days_remaining', v_days_remaining,
      'will_expire_at', v_effective_date
    )
  );
  
  -- 8. Admin log
  PERFORM public.log_admin_action(
    'SUBSCRIPTION_CANCELLED',
    p_user_id,
    'subscription',
    p_user_id,
    jsonb_build_object(
      'reason', p_reason,
      'immediate', p_immediate,
      'effective_date', v_effective_date,
      'plan', v_profile.account_type
    )
  );
  
  RAISE NOTICE 'âœ… Subscription cancelled: % (effective: %)', 
    v_profile.account_type, v_effective_date;
  
  RETURN jsonb_build_object(
    'success', true,
    'message', CASE 
      WHEN p_immediate THEN 'Subscription cancelled immediately'
      ELSE format('Subscription cancelled. Access continues until %s', v_effective_date::DATE)
    END,
    'data', jsonb_build_object(
      'effective_date', v_effective_date,
      'days_remaining', GREATEST(0, v_days_remaining),
      'immediate', p_immediate,
      'will_downgrade_to', 'free'
    )
  );
END;
$$;

COMMENT ON FUNCTION public.cancel_subscription IS 
'v8.4.4-FIXED-v5: ğŸš« GRACEFUL CANCELLATION: Stops auto-renewal but keeps access until period end (unless immediate=true)';

GRANT EXECUTE ON FUNCTION public.cancel_subscription TO authenticated;

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- 6.5.6: Process Expired Subscriptions (CRON)
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

CREATE OR REPLACE FUNCTION public.process_expired_subscriptions()
RETURNS TABLE(
  downgraded_count INTEGER,
  downgraded_emails TEXT[]
)
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_downgraded_users RECORD;
  v_emails TEXT[] := ARRAY[]::TEXT[];
  v_count INTEGER := 0;
BEGIN
  -- Find and downgrade expired subscriptions
  FOR v_downgraded_users IN
    SELECT 
      p.id,
      p.email,
      p.account_type as old_plan,
      p.subscription_expires_at
    FROM public.profiles p
    WHERE p.subscription_expires_at < NOW()
      AND p.account_type IN ('basic', 'premium')
      AND p.subscription_status IN ('active', 'cancelled')
    ORDER BY p.subscription_expires_at ASC
    LIMIT 1000
  LOOP
    -- Update to free
    UPDATE public.profiles
    SET 
      previous_account_type = v_downgraded_users.old_plan,
      account_type = 'free',
      max_trades = 10,
      subscription_status = 'expired',
      subscription_interval = NULL,
      payment_provider = NULL,
      updated_at = NOW()
    WHERE id = v_downgraded_users.id;
    
    -- Log the expiration
    INSERT INTO public.subscription_changes (
      user_id,
      change_type,
      from_plan,
      to_plan,
      effective_date,
      reason
    ) VALUES (
      v_downgraded_users.id,
      'expire',
      v_downgraded_users.old_plan,
      'free',
      NOW(),
      'Subscription period ended'
    );
    
    v_emails := array_append(v_emails, v_downgraded_users.email);
    v_count := v_count + 1;
    
    RAISE NOTICE 'Downgraded user % (%) from % to free', 
      v_downgraded_users.email, v_downgraded_users.id, v_downgraded_users.old_plan;
  END LOOP;
  
  RETURN QUERY SELECT v_count, v_emails;
END;
$$;

COMMENT ON FUNCTION public.process_expired_subscriptions IS 
'â° CRON JOB: Downgrades expired subscriptions to FREE (runs daily at 2 AM)';

GRANT EXECUTE ON FUNCTION public.process_expired_subscriptions TO service_role;

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- 6.5.7: Reactivate Cancelled Subscription - FIXED v5
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

CREATE OR REPLACE FUNCTION public.reactivate_subscription(
  p_user_id UUID
)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_profile RECORD;
  v_period_id UUID;
  v_period_found BOOLEAN := FALSE;
BEGIN
  SELECT * INTO v_profile
  FROM public.profiles
  WHERE id = p_user_id;
  
  IF v_profile.subscription_status != 'cancelled' THEN
    RETURN jsonb_build_object(
      'success', false,
      'error', 'Can only reactivate cancelled subscriptions'
    );
  END IF;
  
  IF v_profile.subscription_expires_at < NOW() THEN
    RETURN jsonb_build_object(
      'success', false,
      'error', 'Subscription already expired. Please subscribe again.'
    );
  END IF;
  
  -- Reactivate
  UPDATE public.profiles
  SET 
    subscription_status = 'active',
    cancellation_reason = NULL,
    cancellation_requested_at = NULL,
    cancellation_effective_date = NULL,
    updated_at = NOW()
  WHERE id = p_user_id;
  
  -- Update period (ğŸ”¥ FIXED v5: using FOR loop with LIMIT 1)
  FOR v_period_id IN
    SELECT id
    FROM public.subscription_periods
    WHERE user_id = p_user_id
      AND period_end > NOW()
    ORDER BY period_end DESC
    LIMIT 1
  LOOP
    v_period_found := TRUE;
    
    UPDATE public.subscription_periods
    SET 
      auto_renew = TRUE,
      canceled_at = NULL,
      updated_at = NOW()
    WHERE id = v_period_id;
    
    EXIT;
  END LOOP;
  
  -- Log
  INSERT INTO public.subscription_changes (
    user_id,
    change_type,
    from_plan,
    to_plan,
    effective_date,
    reason
  ) VALUES (
    p_user_id,
    'reactivate',
    v_profile.account_type,
    v_profile.account_type,
    NOW(),
    'User reactivated cancelled subscription'
  );
  
  RETURN jsonb_build_object(
    'success', true,
    'message', 'Subscription reactivated successfully',
    'data', jsonb_build_object(
      'plan', v_profile.account_type,
      'expires_at', v_profile.subscription_expires_at
    )
  );
END;
$$;

COMMENT ON FUNCTION public.reactivate_subscription IS 
'v8.4.4-FIXED-v5: ğŸ”„ REACTIVATION: Allows user to undo cancellation before period ends';

GRANT EXECUTE ON FUNCTION public.reactivate_subscription TO authenticated;

DO $$
BEGIN
  RAISE NOTICE '';
  RAISE NOTICE 'âœ… Advanced subscription functions created!';
  RAISE NOTICE '   â€¢ get_current_price() - Dynamic pricing (FIXED v5)';
  RAISE NOTICE '   â€¢ calculate_prorated_upgrade() - Smart proration';
  RAISE NOTICE '   â€¢ process_subscription_upgrade() - Mid-cycle upgrades';
  RAISE NOTICE '   â€¢ renew_subscription() - Auto-renewal (FIXED v5)';
  RAISE NOTICE '   â€¢ cancel_subscription() - Graceful cancellation (FIXED v5)';
  RAISE NOTICE '   â€¢ process_expired_subscriptions() - Auto-downgrade';
  RAISE NOTICE '   â€¢ reactivate_subscription() - Undo cancellation (FIXED v5)';
  RAISE NOTICE '';
END $$;

COMMENT ON FUNCTION public.admin_grant_free_access IS 
'v8.4: ×××¤×©×¨ ×œ××“××™×Ÿ ×œ×ª×ª ×’×™×©×” ×—×™× × ×œ×œ× ×ª×©×œ×•×';

GRANT EXECUTE ON FUNCTION public.admin_grant_free_access TO authenticated;

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- ğŸ†• SNAPTRADE SECTION 6A: GRANT FUNCTION PERMISSIONS
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

DO $$
BEGIN
  RAISE NOTICE '[6A/13] ğŸ”‘ Granting SnapTrade function permissions...';
END $$;

-- Sync log functions
GRANT EXECUTE ON FUNCTION get_latest_sync_for_user(UUID) TO authenticated;
GRANT EXECUTE ON FUNCTION get_user_sync_stats(UUID) TO authenticated;
GRANT EXECUTE ON FUNCTION cleanup_old_sync_logs() TO service_role;

-- Status functions
GRANT EXECUTE ON FUNCTION is_snaptrade_connected(UUID) TO authenticated;
GRANT EXECUTE ON FUNCTION get_last_successful_sync_date(UUID) TO authenticated;
GRANT EXECUTE ON FUNCTION count_pending_snaptrade_trades(UUID) TO authenticated;

-- Analytics functions
GRANT EXECUTE ON FUNCTION get_snaptrade_import_stats(UUID, DATE, DATE) TO authenticated;
GRANT EXECUTE ON FUNCTION find_duplicate_snaptrade_activities(UUID) TO authenticated;

DO $$
BEGIN
  RAISE NOTICE 'âœ… SnapTrade function permissions granted';
END $$;

COMMIT;

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- ×¡×™×›×•× ×—×œ×§ 1
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

DO $$
BEGIN
  RAISE NOTICE '';
  RAISE NOTICE 'âœ… Part 2/3 - Sections 1-6 Complete! (×—×œ×§ 1/2)';
  RAISE NOTICE '';
  RAISE NOTICE 'ğŸ”¥ ×¤×™×¦''×¨×™× ×©× ×•×¡×¤×•:';
  RAISE NOTICE '   âœ… Unified trigger (3x faster!)';
  RAISE NOTICE '   âœ… Rate limiting';
  RAISE NOTICE '   âœ… Soft delete';
  RAISE NOTICE '   âœ… Payment security';
  RAISE NOTICE '   âœ… Affiliate automation (FIXED v5)';
  RAISE NOTICE '   âœ… Trade limits (FREE=10 lifetime)';
  RAISE NOTICE '   âœ… Advanced subscription management (FIXED v5)';
  RAISE NOTICE '   ğŸ”§ FIXED: Risk settings use columns (NOT JSONB)';
  RAISE NOTICE '   ğŸ”§ FIXED v5: ALL SELECT INTO with ORDER BY issues!';
  RAISE NOTICE '';
  RAISE NOTICE 'ğŸ†• SnapTrade Integration Added:';
  RAISE NOTICE '   âœ… Trigger functions (auto-update, validation)';
  RAISE NOTICE '   âœ… Sync log helpers (latest sync, stats, cleanup)';
  RAISE NOTICE '   âœ… Status functions (connected, last sync, pending)';
  RAISE NOTICE '   âœ… Analytics functions (import stats, duplicates)';
  RAISE NOTICE '   âœ… All permissions granted';
  RAISE NOTICE '';
  RAISE NOTICE 'â­ï¸  Continue with ×—×œ×§ 2/2 (Sections 7-13)...';
  RAISE NOTICE '';
END $$;