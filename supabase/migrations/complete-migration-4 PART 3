-- ===============================================
-- ğŸ”¥ FINOTAUR - COMPLETE UNIFIED MIGRATION
-- ===============================================
-- Version: v9.4.2-COMPLETE-WITH-SUBSCRIPTION-VIEWS-AND-CRON
-- Synced with Part 1 v9.4.2 and Part 2 merged
-- Date: 2025-11-10
-- Parts: 4/4 (Views + Data + Permissions + Verification + CRON)
-- ===============================================
-- ğŸ†• INCLUDES: Payment Security & Enhanced RLS
-- ğŸ†• FIXED: BASIC & TRIAL = 25 trades/month
-- ğŸ†• FIXED: ALL 3 MISSING VIEWS ADDED
-- ğŸ†• FIXED: ALL MISSING GRANT PERMISSIONS ADDED
-- ğŸ†• NEW: CRON JOBS SECTION ADDED
-- ğŸ†• NEW: Individual Risk Settings Columns in Views
-- ğŸ†• NEW: Subscription Management Views Added
-- ğŸ”’ RLS POLICIES: Defined in Part 1 - NOT recreated here
-- ğŸ”„ SYNCED: Column names match Part 1 v9.4.2
-- âš ï¸  NOTE: referrals/affiliate tables removed in Part 1
-- ===============================================

BEGIN;

DO $$
BEGIN
  RAISE NOTICE '';
  RAISE NOTICE 'â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—';
  RAISE NOTICE 'â•‘  ğŸ”¥ FINOTAUR MERGED MIGRATION v9.4.2  â•‘';
  RAISE NOTICE 'â•‘     Part 3/3: Views + Data + CRON     â•‘';
  RAISE NOTICE 'â•‘     ğŸ†• FIXED: BASIC/TRIAL = 25 trades â•‘';
  RAISE NOTICE 'â•‘     ğŸ†• FIXED: ALL MISSING VIEWS        â•‘';
  RAISE NOTICE 'â•‘     ğŸ†• FIXED: ALL MISSING GRANTS       â•‘';
  RAISE NOTICE 'â•‘     ğŸ†• NEW: CRON JOBS AUTOMATION       â•‘';
  RAISE NOTICE 'â•‘     ğŸ†• NEW: Risk Settings in Views     â•‘';
  RAISE NOTICE 'â•‘     ğŸ†• NEW: Subscription Mgmt Views    â•‘';
  RAISE NOTICE 'â•‘     ğŸ”’ RLS: Uses Part 1 policies       â•‘';
  RAISE NOTICE 'â•‘     ğŸ”„ SYNCED: Part 1 v9.4.2 columns   â•‘';
  RAISE NOTICE 'â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•';
  RAISE NOTICE '';
END $$;

-- ===============================================
-- SECTION 0: NUCLEAR CLEANUP (DROP ALL VIEWS)
-- ===============================================

DO $$
BEGIN
  RAISE NOTICE '[0/10] ğŸ’£ Nuclear cleanup - dropping all existing views...';
END $$;

DROP MATERIALIZED VIEW IF EXISTS public.webhook_stats CASCADE;
DROP MATERIALIZED VIEW IF EXISTS public.strategy_stats_view CASCADE;
DROP VIEW IF EXISTS public.payment_analytics CASCADE;
DROP VIEW IF EXISTS public.admin_stats_view CASCADE;
DROP VIEW IF EXISTS public.admin_users_list_view CASCADE;
DROP VIEW IF EXISTS public.active_subscriptions CASCADE;
DROP VIEW IF EXISTS public.pricing_info CASCADE;
DROP VIEW IF EXISTS public.archived_users_view CASCADE;
DROP VIEW IF EXISTS public.subscription_health_view CASCADE;
DROP VIEW IF EXISTS public.revenue_analytics_view CASCADE;
DROP VIEW IF EXISTS public.proration_impact_view CASCADE;
DROP VIEW IF EXISTS public.cancellation_analytics_view CASCADE;
DROP VIEW IF EXISTS public.subscription_flow_view CASCADE;

-- ğŸ”´ REMOVED: These views use deleted tables (referrals, affiliate_stats)
DROP VIEW IF EXISTS public.user_referral_info CASCADE;
DROP VIEW IF EXISTS public.affiliate_stats_view CASCADE;

-- ===============================================
-- ğŸ†• v9.4.2: VERIFY ARCHIVE COLUMNS (SHOULD EXIST FROM PART 1)
-- ===============================================

DO $$
BEGIN
  RAISE NOTICE '[0.5/10] ğŸ“¦ Verifying archive columns exist in profiles table...';
END $$;

-- Safe check - only add if missing (Part 1 v9.4.2 should have these)
DO $$
BEGIN
  -- Verify deleted_at column exists
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns 
    WHERE table_schema = 'public' 
      AND table_name = 'profiles' 
      AND column_name = 'deleted_at'
  ) THEN
    RAISE WARNING 'âš ï¸  deleted_at column missing - should be in Part 1! Adding now...';
    ALTER TABLE public.profiles 
    ADD COLUMN deleted_at TIMESTAMPTZ DEFAULT NULL;
    RAISE NOTICE 'âœ… Added deleted_at column to profiles';
  ELSE
    RAISE NOTICE 'â„¹ï¸  deleted_at column exists (from Part 1)';
  END IF;
END $$;

-- Safe check for deleted_by column
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns 
    WHERE table_schema = 'public' 
      AND table_name = 'profiles' 
      AND column_name = 'deleted_by'
  ) THEN
    RAISE WARNING 'âš ï¸  deleted_by column missing - should be in Part 1! Adding now...';
    ALTER TABLE public.profiles 
    ADD COLUMN deleted_by UUID REFERENCES public.profiles(id) DEFAULT NULL;
    RAISE NOTICE 'âœ… Added deleted_by column to profiles';
  ELSE
    RAISE NOTICE 'â„¹ï¸  deleted_by column exists (from Part 1)';
  END IF;
END $$;

-- Add index (safe - uses IF NOT EXISTS)
CREATE INDEX IF NOT EXISTS idx_profiles_deleted_at 
ON public.profiles(deleted_at) 
WHERE deleted_at IS NOT NULL;

-- Only add comments if columns exist
DO $$
BEGIN
  IF EXISTS (
    SELECT 1 FROM information_schema.columns 
    WHERE table_schema = 'public' 
      AND table_name = 'profiles' 
      AND column_name = 'deleted_at'
  ) THEN
    COMMENT ON COLUMN public.profiles.deleted_at IS 
    'v9.4.2: Soft delete timestamp. Users stay 30 days before archival.';
  END IF;
  
  IF EXISTS (
    SELECT 1 FROM information_schema.columns 
    WHERE table_schema = 'public' 
      AND table_name = 'profiles' 
      AND column_name = 'deleted_by'
  ) THEN
    COMMENT ON COLUMN public.profiles.deleted_by IS 
    'v9.4.2: Admin who deleted the user (for audit trail).';
  END IF;
END $$;

-- ===============================================
-- ğŸ†• v9.4.2: CREATE PROFILES_ARCHIVE TABLE (IF NOT EXISTS)
-- ===============================================

DO $$
BEGIN
  RAISE NOTICE '[0.6/10] ğŸ“¦ Creating profiles_archive table (if not exists)...';
END $$;

-- Only create if it doesn't exist
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.tables 
    WHERE table_schema = 'public' 
      AND table_name = 'profiles_archive'
  ) THEN
    CREATE TABLE public.profiles_archive (
      id UUID PRIMARY KEY,
      email TEXT NOT NULL,
      display_name TEXT,
      avatar_url TEXT,
      role TEXT NOT NULL DEFAULT 'user',
      account_type TEXT NOT NULL DEFAULT 'free',
      subscription_interval TEXT,
      subscription_status TEXT,
      subscription_started_at TIMESTAMPTZ,
      subscription_expires_at TIMESTAMPTZ,
      subscription_paused_until TIMESTAMPTZ,
      subscription_cancel_at_period_end BOOLEAN DEFAULT FALSE,
      trial_ends_at TIMESTAMPTZ,
      payment_provider TEXT,
      initial_portfolio NUMERIC(15,2) DEFAULT 10000,
      current_portfolio NUMERIC(15,2) DEFAULT 10000,
      total_pnl NUMERIC(15,2) DEFAULT 0,
      trade_count INTEGER DEFAULT 0,
      max_trades INTEGER DEFAULT 10,
      current_month_trades_count INTEGER DEFAULT 0,
      billing_cycle_start DATE,
      portfolio_size NUMERIC(15,2),
      risk_mode TEXT,
      risk_percentage NUMERIC(5,2),
      fixed_risk_amount NUMERIC(15,2),
      risk_settings JSONB DEFAULT '{}'::jsonb,
      referral_count INTEGER DEFAULT 0,
      free_months_available INTEGER DEFAULT 0,
      is_banned BOOLEAN DEFAULT false,
      ban_reason TEXT,
      banned_at TIMESTAMPTZ,
      banned_by UUID,
      last_login_at TIMESTAMPTZ,
      login_count INTEGER DEFAULT 0,
      metadata JSONB DEFAULT '{}'::jsonb,
      created_at TIMESTAMPTZ NOT NULL,
      updated_at TIMESTAMPTZ NOT NULL,
      deleted_at TIMESTAMPTZ NOT NULL,
      deleted_by UUID,
      archived_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
      archived_by UUID
    );
    
    RAISE NOTICE 'âœ… Created profiles_archive table';
  ELSE
    RAISE NOTICE 'â„¹ï¸  profiles_archive table already exists';
  END IF;
END $$;

-- ğŸ†• Add missing columns to profiles_archive if table already existed
DO $$
BEGIN
  -- Add subscription_cancel_at_period_end if missing
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns 
    WHERE table_schema = 'public' 
      AND table_name = 'profiles_archive' 
      AND column_name = 'subscription_cancel_at_period_end'
  ) THEN
    ALTER TABLE public.profiles_archive 
    ADD COLUMN subscription_cancel_at_period_end BOOLEAN DEFAULT FALSE;
    RAISE NOTICE 'âœ… Added subscription_cancel_at_period_end to profiles_archive';
  END IF;
  
  -- Add subscription_expires_at if missing
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns 
    WHERE table_schema = 'public' 
      AND table_name = 'profiles_archive' 
      AND column_name = 'subscription_expires_at'
  ) THEN
    ALTER TABLE public.profiles_archive 
    ADD COLUMN subscription_expires_at TIMESTAMPTZ;
    RAISE NOTICE 'âœ… Added subscription_expires_at to profiles_archive';
  END IF;
  
  -- Add archived_at if missing
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns 
    WHERE table_schema = 'public' 
      AND table_name = 'profiles_archive' 
      AND column_name = 'archived_at'
  ) THEN
    ALTER TABLE public.profiles_archive 
    ADD COLUMN archived_at TIMESTAMPTZ NOT NULL DEFAULT NOW();
    RAISE NOTICE 'âœ… Added archived_at to profiles_archive';
  END IF;
  
  -- Add archived_by if missing
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns 
    WHERE table_schema = 'public' 
      AND table_name = 'profiles_archive' 
      AND column_name = 'archived_by'
  ) THEN
    ALTER TABLE public.profiles_archive 
    ADD COLUMN archived_by UUID;
    RAISE NOTICE 'âœ… Added archived_by to profiles_archive';
  END IF;
  
  -- Add portfolio_size if missing
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns 
    WHERE table_schema = 'public' 
      AND table_name = 'profiles_archive' 
      AND column_name = 'portfolio_size'
  ) THEN
    ALTER TABLE public.profiles_archive 
    ADD COLUMN portfolio_size NUMERIC(15,2);
    RAISE NOTICE 'âœ… Added portfolio_size to profiles_archive';
  END IF;
  
  -- Add risk_mode if missing
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns 
    WHERE table_schema = 'public' 
      AND table_name = 'profiles_archive' 
      AND column_name = 'risk_mode'
  ) THEN
    ALTER TABLE public.profiles_archive 
    ADD COLUMN risk_mode TEXT;
    RAISE NOTICE 'âœ… Added risk_mode to profiles_archive';
  END IF;
  
  -- Add risk_percentage if missing
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns 
    WHERE table_schema = 'public' 
      AND table_name = 'profiles_archive' 
      AND column_name = 'risk_percentage'
  ) THEN
    ALTER TABLE public.profiles_archive 
    ADD COLUMN risk_percentage NUMERIC(5,2);
    RAISE NOTICE 'âœ… Added risk_percentage to profiles_archive';
  END IF;
  
  -- Add fixed_risk_amount if missing
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns 
    WHERE table_schema = 'public' 
      AND table_name = 'profiles_archive' 
      AND column_name = 'fixed_risk_amount'
  ) THEN
    ALTER TABLE public.profiles_archive 
    ADD COLUMN fixed_risk_amount NUMERIC(15,2);
    RAISE NOTICE 'âœ… Added fixed_risk_amount to profiles_archive';
  END IF;
END $$;

-- Create indexes (safe - uses IF NOT EXISTS)
CREATE INDEX IF NOT EXISTS idx_profiles_archive_email ON public.profiles_archive(email);
CREATE INDEX IF NOT EXISTS idx_profiles_archive_archived_at ON public.profiles_archive(archived_at DESC);
CREATE INDEX IF NOT EXISTS idx_profiles_archive_deleted_at ON public.profiles_archive(deleted_at);
CREATE INDEX IF NOT EXISTS idx_profiles_archive_account_type ON public.profiles_archive(account_type);

COMMENT ON TABLE public.profiles_archive IS 
'v9.4.2: Archive table for soft-deleted users. Users moved here after 30 days.';

GRANT SELECT, INSERT, DELETE ON public.profiles_archive TO authenticated;
GRANT ALL ON public.profiles_archive TO service_role;

-- ===============================================
-- SECTION 1: MATERIALIZED VIEWS
-- ===============================================

DO $$
BEGIN
  RAISE NOTICE '[1/10] ğŸ“Š Creating materialized views...';
END $$;

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- 1.1: Webhook Stats (for TradingView performance)
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
CREATE MATERIALIZED VIEW public.webhook_stats AS
SELECT 
  user_id,
  COUNT(*) as total_trades,
  COUNT(*) FILTER (WHERE broker = 'tradingview') as tradingview_trades,
  COUNT(*) FILTER (WHERE broker = 'tradingview' AND close_at IS NULL) as open_tradingview_trades,
  COUNT(*) FILTER (WHERE broker = 'tradingview' AND close_at IS NOT NULL) as closed_tradingview_trades,
  MAX(open_at) FILTER (WHERE broker = 'tradingview') as last_tradingview_trade_at,
  MAX(created_at) as last_trade_created_at
FROM trades
WHERE broker = 'tradingview'
GROUP BY user_id;

CREATE UNIQUE INDEX idx_webhook_stats_user 
ON public.webhook_stats(user_id);

COMMENT ON MATERIALIZED VIEW public.webhook_stats IS 
'Aggregated statistics for TradingView webhooks per user. Refresh hourly or on-demand.';

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- 1.2: Strategy Stats Materialized View (ğŸ†• CRITICAL FOR MY STRATEGIES)
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
CREATE MATERIALIZED VIEW public.strategy_stats_view AS
SELECT 
  s.id,
  s.user_id,
  s.name,
  s.status,
  s.category,
  s.setup_type,
  s.default_stop_loss,
  s.default_take_profit,
  s.created_at,
  s.updated_at,
  
  -- Trade counts
  COUNT(t.id) FILTER (WHERE t.exit_price IS NOT NULL) as total_trades,
  COUNT(t.id) FILTER (WHERE t.outcome = 'WIN') as wins,
  COUNT(t.id) FILTER (WHERE t.outcome = 'LOSS') as losses,
  COUNT(t.id) FILTER (WHERE t.outcome = 'BE') as break_even,
  COUNT(t.id) FILTER (WHERE t.outcome = 'OPEN') as open_trades,
  
  -- Win rate
  CASE 
    WHEN COUNT(t.id) FILTER (WHERE t.exit_price IS NOT NULL) > 0 
    THEN ROUND(
      (COUNT(t.id) FILTER (WHERE t.outcome = 'WIN')::NUMERIC / 
       COUNT(t.id) FILTER (WHERE t.exit_price IS NOT NULL)::NUMERIC) * 100, 
      2
    )
    ELSE 0 
  END as win_rate,
  
  -- P&L stats
  COALESCE(SUM(t.pnl) FILTER (WHERE t.exit_price IS NOT NULL), 0) as total_pnl,
  COALESCE(AVG(t.pnl) FILTER (WHERE t.outcome = 'WIN'), 0) as avg_win,
  COALESCE(AVG(t.pnl) FILTER (WHERE t.outcome = 'LOSS'), 0) as avg_loss,
  COALESCE(MAX(t.pnl), 0) as best_trade,
  COALESCE(MIN(t.pnl), 0) as worst_trade,
  
  -- R-multiple stats
  COALESCE(AVG(t.actual_r) FILTER (WHERE t.actual_r IS NOT NULL), 0) as avg_r,
  COALESCE(SUM(t.actual_r) FILTER (WHERE t.actual_r IS NOT NULL), 0) as total_r,
  COALESCE(MAX(t.actual_r), 0) as best_r,
  COALESCE(MIN(t.actual_r), 0) as worst_r,
  
  -- Profit factor
  CASE 
    WHEN ABS(SUM(t.pnl) FILTER (WHERE t.outcome = 'LOSS')) > 0 
    THEN ROUND(
      ABS(SUM(t.pnl) FILTER (WHERE t.outcome = 'WIN') / 
          SUM(t.pnl) FILTER (WHERE t.outcome = 'LOSS')), 
      2
    )
    ELSE 0 
  END as profit_factor,
  
  -- Last trade date
  MAX(t.close_at) as last_trade_date

FROM public.strategies s
LEFT JOIN public.trades t ON t.strategy_id = s.id
GROUP BY s.id, s.user_id, s.name, s.status, s.category, s.setup_type, 
         s.default_stop_loss, s.default_take_profit, s.created_at, s.updated_at;

-- Create indexes for strategy_stats_view
CREATE UNIQUE INDEX idx_strategy_stats_view_id 
ON public.strategy_stats_view(id);

CREATE INDEX idx_strategy_stats_view_user 
ON public.strategy_stats_view(user_id, status);

CREATE INDEX idx_strategy_stats_view_category
ON public.strategy_stats_view(category) WHERE status = 'active';

COMMENT ON MATERIALIZED VIEW public.strategy_stats_view IS 
'Pre-calculated strategy statistics for fast dashboard loading. Refresh after trade updates.';

-- ===============================================
-- SECTION 2: REGULAR VIEWS
-- ===============================================

DO $$
BEGIN
  RAISE NOTICE '[2/10] ğŸ‘ï¸  Creating regular views...';
END $$;

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- 2.3: Payment Analytics View
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
CREATE OR REPLACE VIEW public.payment_analytics AS
SELECT 
  plan, 
  status,
  COUNT(*) as payment_count,
  SUM(amount) as total_amount,
  AVG(amount) as avg_amount,
  DATE_TRUNC('month', created_at) as month
FROM public.payment_history
GROUP BY plan, status, DATE_TRUNC('month', created_at)
ORDER BY month DESC, plan, status;

COMMENT ON VIEW public.payment_analytics IS 
'Payment statistics grouped by plan, status, and month';

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- 2.4: Active Subscriptions View
-- ğŸ”„ SYNCED: Uses subscription_expires_at (not subscription_end_date)
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
CREATE OR REPLACE VIEW public.active_subscriptions AS
SELECT 
  sp.user_id, 
  sp.plan, 
  sp.period_start, 
  sp.period_end, 
  sp.auto_renew, 
  sp.canceled_at,
  p.email, 
  p.display_name, 
  p.account_type, 
  p.subscription_interval,
  p.subscription_cancel_at_period_end,  -- ğŸ†• v9.4.2
  EXTRACT(DAY FROM (sp.period_end - NOW()))::INTEGER as days_remaining,
  CASE 
    WHEN sp.period_end < NOW() THEN 'expired'
    WHEN sp.period_end < NOW() + INTERVAL '7 days' THEN 'expiring_soon'
    ELSE 'active'
  END as subscription_health
FROM public.subscription_periods sp
JOIN public.profiles p ON p.id = sp.user_id
WHERE sp.period_end > NOW() - INTERVAL '30 days'
ORDER BY sp.period_end ASC;

COMMENT ON VIEW public.active_subscriptions IS 
'Active subscriptions with health status and expiration tracking';

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- 2.5: Pricing Info View
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
CREATE OR REPLACE VIEW public.pricing_info AS
SELECT 'basic' as plan, 'monthly' as interval, 19.99 as price, 19.99 as monthly_equivalent
UNION ALL
SELECT 'basic' as plan, 'yearly' as interval, 149.00 as price, 12.42 as monthly_equivalent
UNION ALL
SELECT 'premium' as plan, 'monthly' as interval, 39.99 as price, 39.99 as monthly_equivalent
UNION ALL
SELECT 'premium' as plan, 'yearly' as interval, 299.00 as price, 24.92 as monthly_equivalent;

COMMENT ON VIEW public.pricing_info IS 
'Static pricing information for subscription plans';

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- ğŸ”´ REMOVED: user_referral_info - uses deleted referrals table
-- ğŸ”´ REMOVED: affiliate_stats_view - uses deleted affiliate_stats table
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- ğŸ†• v9.4.2: Archived Users View
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
CREATE OR REPLACE VIEW public.archived_users_view AS
SELECT 
  pa.id,
  pa.email,
  COALESCE(pa.display_name, split_part(pa.email, '@', 1)) as display_name,
  pa.account_type,
  pa.role,
  pa.subscription_status,
  pa.subscription_interval,
  pa.subscription_expires_at,
  pa.subscription_cancel_at_period_end,  -- ğŸ†• v9.4.2
  pa.is_banned,
  pa.ban_reason,
  pa.banned_at,
  pa.last_login_at,
  pa.login_count,
  pa.created_at,
  pa.updated_at,
  pa.current_portfolio,
  pa.initial_portfolio,
  pa.total_pnl,
  pa.trade_count,
  pa.current_month_trades_count,
  pa.max_trades,
  pa.portfolio_size,
  pa.risk_mode,
  pa.risk_percentage,
  pa.fixed_risk_amount,
  pa.deleted_at,
  pa.deleted_by,
  pa.archived_at,
  pa.archived_by,
  EXTRACT(DAY FROM (NOW() - pa.archived_at))::INTEGER as days_in_archive,
  COUNT(DISTINCT t.id) FILTER (WHERE t.exit_price IS NOT NULL) as total_closed_trades,
  CASE 
    WHEN COUNT(DISTINCT t.id) FILTER (WHERE t.exit_price IS NOT NULL) > 0 
    THEN ROUND(
      (COUNT(DISTINCT t.id) FILTER (WHERE t.outcome = 'WIN') * 100.0 
      / COUNT(DISTINCT t.id) FILTER (WHERE t.exit_price IS NOT NULL)), 2
    )
    ELSE 0 
  END as win_rate,
  COUNT(DISTINCT t.id) FILTER (WHERE t.outcome = 'WIN') as wins,
  COUNT(DISTINCT t.id) FILTER (WHERE t.outcome = 'LOSS') as losses,
  COUNT(DISTINCT t.id) FILTER (WHERE t.outcome = 'BE') as break_even,
  COUNT(DISTINCT t.id) FILTER (WHERE t.outcome = 'OPEN') as open_trades,
  MAX(t.close_at) as last_trade_date,
  ROUND(AVG(t.actual_r) FILTER (WHERE t.actual_r IS NOT NULL), 2) as avg_r,
  MAX(t.actual_r) FILTER (WHERE t.actual_r IS NOT NULL) as best_r,
  MIN(t.actual_r) FILTER (WHERE t.actual_r IS NOT NULL) as worst_r
FROM public.profiles_archive pa
LEFT JOIN public.trades t ON t.user_id = pa.id
GROUP BY 
  pa.id, pa.email, pa.display_name, pa.account_type, pa.role,
  pa.subscription_status, pa.subscription_interval, pa.subscription_expires_at,
  pa.subscription_cancel_at_period_end,
  pa.is_banned, pa.ban_reason, pa.banned_at,
  pa.last_login_at, pa.login_count, pa.created_at, pa.updated_at,
  pa.current_portfolio, pa.initial_portfolio, pa.total_pnl, pa.trade_count,
  pa.current_month_trades_count, pa.max_trades,
  pa.portfolio_size, pa.risk_mode, pa.risk_percentage, pa.fixed_risk_amount,
  pa.deleted_at, pa.deleted_by, pa.archived_at, pa.archived_by
ORDER BY pa.archived_at DESC;

COMMENT ON VIEW public.archived_users_view IS 
'v9.4.2: View of all archived users with their stats and archive metadata.';

-- ===============================================
-- ğŸ†• SECTION 2.8: SUBSCRIPTION MANAGEMENT VIEWS
-- ===============================================

DO $$
BEGIN
  RAISE NOTICE '[2.8/10] ğŸ“Š Creating subscription management views...';
END $$;

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- 2.8.2: Revenue Analytics View
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

CREATE OR REPLACE VIEW public.revenue_analytics_view AS
WITH monthly_revenue AS (
  SELECT 
    DATE_TRUNC('month', created_at) as month,
    payment_type,
    plan,
    COUNT(*) as transaction_count,
    SUM(amount) as total_amount,
    AVG(amount) as avg_amount,
    SUM(discount_amount) as total_discounts
  FROM payment_history
  WHERE status = 'completed'
  GROUP BY DATE_TRUNC('month', created_at), payment_type, plan
)
SELECT 
  month,
  payment_type,
  plan,
  transaction_count,
  ROUND(total_amount, 2) as total_revenue,
  ROUND(avg_amount, 2) as avg_transaction,
  ROUND(total_discounts, 2) as total_discounts,
  ROUND(total_amount - total_discounts, 2) as net_revenue
FROM monthly_revenue
ORDER BY month DESC, payment_type, plan;

COMMENT ON VIEW public.revenue_analytics_view IS 
'ğŸ’° Monthly revenue breakdown by payment type and plan';

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- 2.8.3: Proration Impact View
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

CREATE OR REPLACE VIEW public.proration_impact_view AS
SELECT 
  DATE_TRUNC('month', created_at) as month,
  COUNT(*) FILTER (WHERE is_prorated = TRUE) as prorated_count,
  COUNT(*) as total_upgrades,
  ROUND(
    (COUNT(*) FILTER (WHERE is_prorated = TRUE)::NUMERIC / NULLIF(COUNT(*), 0)::NUMERIC * 100),
    1
  ) as proration_percentage,
  ROUND(SUM(discount_amount) FILTER (WHERE is_prorated = TRUE), 2) as total_discounts_given,
  ROUND(AVG(prorated_days) FILTER (WHERE is_prorated = TRUE), 1) as avg_days_remaining,
  ROUND(AVG(discount_amount) FILTER (WHERE is_prorated = TRUE), 2) as avg_discount_per_upgrade
FROM payment_history
WHERE payment_type = 'upgrade'
GROUP BY DATE_TRUNC('month', created_at)
ORDER BY month DESC;

COMMENT ON VIEW public.proration_impact_view IS 
'ğŸ“‰ Analysis of proration impact on revenue and customer satisfaction';

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- 2.8.4: Cancellation Analytics View
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

CREATE OR REPLACE VIEW public.cancellation_analytics_view AS
SELECT 
  DATE_TRUNC('month', created_at) as month,
  from_plan,
  COUNT(*) as cancellation_count,
  
  -- Group by reason
  COUNT(*) FILTER (WHERE reason LIKE '%price%' OR reason LIKE '%expensive%') as price_related,
  COUNT(*) FILTER (WHERE reason LIKE '%feature%' OR reason LIKE '%not using%') as feature_related,
  COUNT(*) FILTER (WHERE reason LIKE '%support%' OR reason LIKE '%service%') as support_related,
  COUNT(*) FILTER (WHERE reason IS NULL OR reason = '') as no_reason_given,
  
  -- Average lifetime before cancellation
  ROUND(AVG(
    EXTRACT(DAY FROM (effective_date - (
      SELECT p.created_at 
      FROM profiles p 
      WHERE p.id = subscription_changes.user_id
    )))
  ), 1) as avg_days_before_cancel

FROM subscription_changes
WHERE change_type = 'cancel'
GROUP BY DATE_TRUNC('month', created_at), from_plan
ORDER BY month DESC, from_plan;

COMMENT ON VIEW public.cancellation_analytics_view IS 
'ğŸ“Š Cancellation trends and reasons analysis for retention strategies';

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- 2.8.5: Upgrade/Downgrade Flow View
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

CREATE OR REPLACE VIEW public.subscription_flow_view AS
SELECT 
  DATE_TRUNC('week', created_at) as week,
  change_type,
  from_plan,
  to_plan,
  COUNT(*) as change_count,
  
  -- Proration details for upgrades
  AVG(prorated_days) FILTER (WHERE change_type = 'upgrade') as avg_prorated_days,
  AVG(prorated_amount) FILTER (WHERE change_type = 'upgrade') as avg_prorated_amount,
  
  -- Revenue impact
  CASE 
    WHEN change_type = 'upgrade' THEN SUM(prorated_amount)
    ELSE 0
  END as total_revenue_impact

FROM subscription_changes
WHERE change_type IN ('upgrade', 'downgrade', 'cancel', 'reactivate')
GROUP BY DATE_TRUNC('week', created_at), change_type, from_plan, to_plan
ORDER BY week DESC, change_type, from_plan;

COMMENT ON VIEW public.subscription_flow_view IS 
'ğŸ”„ Weekly subscription change patterns and revenue impact';

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- ğŸ†• v9.4.2: Archive System Functions
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

CREATE OR REPLACE FUNCTION public.archive_soft_deleted_users()
RETURNS TABLE(
  archived_count INTEGER,
  archived_user_ids UUID[]
)
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_archived_users UUID[];
  v_user RECORD;
  v_count INTEGER := 0;
BEGIN
  RAISE NOTICE 'ğŸ”„ Starting archive process...';
  
  FOR v_user IN 
    SELECT * FROM public.profiles
    WHERE deleted_at IS NOT NULL
      AND deleted_at < NOW() - INTERVAL '30 days'
    ORDER BY deleted_at ASC
    LIMIT 1000
  LOOP
    BEGIN
      INSERT INTO public.profiles_archive SELECT v_user.*;
      DELETE FROM public.profiles WHERE id = v_user.id;
      v_archived_users := array_append(v_archived_users, v_user.id);
      v_count := v_count + 1;
    EXCEPTION WHEN OTHERS THEN
      RAISE WARNING 'âŒ Failed to archive user %: %', v_user.id, SQLERRM;
      CONTINUE;
    END;
  END LOOP;
  
  RAISE NOTICE 'âœ… Archived % users', v_count;
  RETURN QUERY SELECT v_count, v_archived_users;
END;
$$;

CREATE OR REPLACE FUNCTION public.restore_user_from_archive(
  p_user_id UUID,
  p_admin_id UUID
)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_archived_user RECORD;
BEGIN
  SELECT * INTO v_archived_user FROM public.profiles_archive WHERE id = p_user_id;
  
  IF NOT FOUND THEN
    RETURN jsonb_build_object('success', false, 'error', 'User not found in archive');
  END IF;
  
  INSERT INTO public.profiles SELECT 
    id, email, display_name, avatar_url, role, account_type,
    subscription_interval, subscription_status, subscription_started_at,
    subscription_expires_at, subscription_paused_until, 
    subscription_cancel_at_period_end, trial_ends_at,
    payment_provider, initial_portfolio, current_portfolio, total_pnl,
    trade_count, max_trades, current_month_trades_count, billing_cycle_start,
    portfolio_size, risk_mode, risk_percentage, fixed_risk_amount,
    risk_settings, referral_count,
    free_months_available, false, NULL, NULL, NULL,
    last_login_at, login_count, metadata, created_at, NOW(), NULL, NULL
  FROM public.profiles_archive WHERE id = p_user_id;
  
  DELETE FROM public.profiles_archive WHERE id = p_user_id;
  
  RETURN jsonb_build_object('success', true, 'message', 'User restored successfully');
END;
$$;

CREATE OR REPLACE FUNCTION public.permanent_delete_from_archive(
  p_user_id UUID,
  p_admin_id UUID
)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_admin_role TEXT;
BEGIN
  SELECT role INTO v_admin_role FROM public.profiles WHERE id = p_admin_id;
  
  IF v_admin_role != 'super_admin' THEN
    RETURN jsonb_build_object('success', false, 'error', 'Super admin only');
  END IF;
  
  DELETE FROM public.profiles_archive WHERE id = p_user_id;
  
  RETURN jsonb_build_object('success', true, 'message', 'User permanently deleted');
END;
$$;

GRANT EXECUTE ON FUNCTION public.archive_soft_deleted_users() TO service_role;
GRANT EXECUTE ON FUNCTION public.restore_user_from_archive(UUID, UUID) TO authenticated;
GRANT EXECUTE ON FUNCTION public.permanent_delete_from_archive(UUID, UUID) TO authenticated;

-- ===============================================
-- ğŸ†• 3.1: UNIFIED get_user_subscription_status v6.0.0
-- ===============================================
-- Returns ALL 31 fields required by frontend including Whop integration
-- ===============================================

DO $$
BEGIN
  RAISE NOTICE '[3.1/10] ğŸ”§ Creating UNIFIED get_user_subscription_status v6.0.0...';
END $$;

DROP FUNCTION IF EXISTS public.get_user_subscription_status(UUID) CASCADE;

CREATE OR REPLACE FUNCTION public.get_user_subscription_status(user_id_param UUID)
RETURNS TABLE (
  -- Core trade limits
  remaining INTEGER,
  used INTEGER,
  max_trades INTEGER,
  plan TEXT,
  reset_date TEXT,
  
  -- Account info
  account_type TEXT,
  role TEXT,
  
  -- Subscription details
  subscription_interval TEXT,
  subscription_status TEXT,
  subscription_expires_at TIMESTAMPTZ,
  subscription_cancel_at_period_end BOOLEAN,
  subscription_started_at TIMESTAMPTZ,
  
  -- Portfolio & Risk
  initial_portfolio NUMERIC,
  current_portfolio NUMERIC,
  portfolio_size NUMERIC,
  total_pnl NUMERIC,
  risk_mode TEXT,
  risk_percentage NUMERIC,
  fixed_risk_amount NUMERIC,
  
  -- Trade counts
  trade_count INTEGER,
  current_month_trades_count INTEGER,
  current_month_active_days INTEGER,
  billing_cycle_start TEXT,
  
  -- Flags
  is_lifetime BOOLEAN,
  
  -- Whop integration (CRITICAL!)
  payment_provider TEXT,
  whop_user_id TEXT,
  whop_membership_id TEXT,
  whop_product_id TEXT,
  whop_plan_id TEXT,
  whop_customer_email TEXT,
  
  -- Subscription management
  pending_downgrade_plan TEXT
)
LANGUAGE plpgsql
STABLE
SECURITY DEFINER
SET search_path TO 'public'
AS $$
DECLARE
  v_profile RECORD;
  v_trades_used INT;
  v_reset_date DATE;
  v_is_lifetime BOOLEAN;
BEGIN
  -- Fetch all profile data in one query
  SELECT 
    p.account_type,
    p.max_trades,
    p.subscription_interval,
    p.subscription_status,
    p.subscription_expires_at,
    p.subscription_cancel_at_period_end,
    p.subscription_started_at,
    COALESCE(p.billing_cycle_start, CURRENT_DATE) as billing_cycle_start,
    COALESCE(p.role, 'user') as role,
    COALESCE(p.current_month_trades_count, 0) as monthly_count,
    COALESCE(p.trade_count, 0) as lifetime_count,
    COALESCE(p.current_month_active_days, 0) as active_days,
    COALESCE(p.initial_portfolio, 10000) as initial_portfolio,
    COALESCE(p.current_portfolio, p.initial_portfolio, 10000) as current_portfolio,
    COALESCE(p.portfolio_size, p.current_portfolio, 10000) as portfolio_size,
    COALESCE(p.total_pnl, 0) as total_pnl,
    COALESCE(p.risk_mode, 'percentage') as risk_mode,
    p.risk_percentage,
    p.fixed_risk_amount,
    p.payment_provider,
    p.whop_user_id,
    p.whop_membership_id,
    p.whop_product_id,
    p.whop_plan_id,
    p.whop_customer_email,
    p.pending_downgrade_plan
  INTO v_profile
  FROM public.profiles p
  WHERE p.id = user_id_param;
  
  -- Handle user not found
  IF NOT FOUND THEN
    RETURN QUERY SELECT 
      10::INTEGER, 0::INTEGER, 10::INTEGER, 'Free Plan'::TEXT, NULL::TEXT,
      'free'::TEXT, 'user'::TEXT, 
      NULL::TEXT, 'active'::TEXT, NULL::TIMESTAMPTZ, FALSE, NULL::TIMESTAMPTZ,
      10000::NUMERIC, 10000::NUMERIC, 10000::NUMERIC, 0::NUMERIC, 
      'percentage'::TEXT, 1::NUMERIC, NULL::NUMERIC,
      0::INTEGER, 0::INTEGER, 0::INTEGER, NULL::TEXT, TRUE,
      NULL::TEXT, NULL::TEXT, NULL::TEXT, NULL::TEXT, NULL::TEXT, NULL::TEXT, NULL::TEXT;
    RETURN;
  END IF;
  
  -- Determine if lifetime limit (FREE users only)
  v_is_lifetime := (v_profile.account_type = 'free');
  
  -- Calculate reset date (only for non-FREE users)
  IF NOT v_is_lifetime THEN
    v_reset_date := (DATE_TRUNC('month', v_profile.billing_cycle_start) + INTERVAL '1 month')::DATE;
  END IF;
  
  -- Determine which trade counter to use
  v_trades_used := CASE WHEN v_is_lifetime THEN v_profile.lifetime_count ELSE v_profile.monthly_count END;
  
  -- Handle unlimited users (premium/admin/vip)
  IF v_profile.role IN ('admin', 'super_admin') OR v_profile.account_type IN ('premium', 'admin', 'vip') THEN
    RETURN QUERY SELECT
      999999::INTEGER,
      v_trades_used::INTEGER,
      999999::INTEGER,
      CASE v_profile.account_type 
        WHEN 'premium' THEN 'Premium Plan' 
        WHEN 'vip' THEN 'VIP Plan' 
        ELSE 'Admin' 
      END::TEXT,
      v_reset_date::TEXT,
      v_profile.account_type::TEXT,
      v_profile.role::TEXT,
      v_profile.subscription_interval::TEXT,
      v_profile.subscription_status::TEXT,
      v_profile.subscription_expires_at::TIMESTAMPTZ,
      COALESCE(v_profile.subscription_cancel_at_period_end, FALSE),
      v_profile.subscription_started_at::TIMESTAMPTZ,
      v_profile.initial_portfolio::NUMERIC,
      v_profile.current_portfolio::NUMERIC,
      v_profile.portfolio_size::NUMERIC,
      v_profile.total_pnl::NUMERIC,
      v_profile.risk_mode::TEXT,
      v_profile.risk_percentage::NUMERIC,
      v_profile.fixed_risk_amount::NUMERIC,
      v_profile.lifetime_count::INTEGER,
      v_profile.monthly_count::INTEGER,
      v_profile.active_days::INTEGER,
      v_profile.billing_cycle_start::TEXT,
      FALSE,
      v_profile.payment_provider::TEXT,
      v_profile.whop_user_id::TEXT,
      v_profile.whop_membership_id::TEXT,
      v_profile.whop_product_id::TEXT,
      v_profile.whop_plan_id::TEXT,
      v_profile.whop_customer_email::TEXT,
      v_profile.pending_downgrade_plan::TEXT;
    RETURN;
  END IF;
  
  -- Regular users (free/basic/trial)
  RETURN QUERY SELECT
    GREATEST(0, v_profile.max_trades - v_trades_used)::INTEGER,
    v_trades_used::INTEGER,
    v_profile.max_trades::INTEGER,
    CASE v_profile.account_type 
      WHEN 'free' THEN 'Free Plan' 
      WHEN 'basic' THEN 'Basic Plan' 
      WHEN 'trial' THEN 'Trial' 
      ELSE 'Free Plan' 
    END::TEXT,
    v_reset_date::TEXT,
    v_profile.account_type::TEXT,
    v_profile.role::TEXT,
    v_profile.subscription_interval::TEXT,
    v_profile.subscription_status::TEXT,
    v_profile.subscription_expires_at::TIMESTAMPTZ,
    COALESCE(v_profile.subscription_cancel_at_period_end, FALSE),
    v_profile.subscription_started_at::TIMESTAMPTZ,
    v_profile.initial_portfolio::NUMERIC,
    v_profile.current_portfolio::NUMERIC,
    v_profile.portfolio_size::NUMERIC,
    v_profile.total_pnl::NUMERIC,
    v_profile.risk_mode::TEXT,
    v_profile.risk_percentage::NUMERIC,
    v_profile.fixed_risk_amount::NUMERIC,
    v_profile.lifetime_count::INTEGER,
    v_profile.monthly_count::INTEGER,
    v_profile.active_days::INTEGER,
    v_profile.billing_cycle_start::TEXT,
    v_is_lifetime,
    v_profile.payment_provider::TEXT,
    v_profile.whop_user_id::TEXT,
    v_profile.whop_membership_id::TEXT,
    v_profile.whop_product_id::TEXT,
    v_profile.whop_plan_id::TEXT,
    v_profile.whop_customer_email::TEXT,
    v_profile.pending_downgrade_plan::TEXT;
END;
$$;

COMMENT ON FUNCTION public.get_user_subscription_status IS 
'v6.0.0 UNIFIED: Returns ALL 31 fields including Whop integration.
FREE = lifetime limit (no reset), BASIC/TRIAL = monthly reset, PREMIUM = unlimited.';

GRANT EXECUTE ON FUNCTION public.get_user_subscription_status(UUID) TO authenticated;
GRANT EXECUTE ON FUNCTION public.get_user_subscription_status(UUID) TO anon;

-- ===============================================
-- SECTION 3: VIEW PERMISSIONS - FIXED VERSION
-- ===============================================
-- ğŸ”’ FIX: Admin views accessible to authenticated users
-- ğŸ”’ Security enforced via admin_get_* RPC functions
-- ğŸ”’ OR direct view access for admins only
-- ===============================================

DO $$
BEGIN
  RAISE NOTICE '[3/10] ğŸ” Setting up view permissions...';
END $$;

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- 3.1: DROP EXISTING ADMIN VIEWS TO RECREATE WITH SECURITY
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

DROP VIEW IF EXISTS public.admin_stats_view CASCADE;
DROP VIEW IF EXISTS public.admin_users_list_view CASCADE;
DROP VIEW IF EXISTS public.subscription_health_view CASCADE;

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- 3.2: RECREATE ADMIN STATS VIEW WITH BUILT-IN SECURITY
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

CREATE OR REPLACE VIEW public.admin_stats_view 
WITH (security_invoker = false)
AS
WITH 
  admin_check AS (
    SELECT EXISTS (
      SELECT 1 FROM public.profiles 
      WHERE id = auth.uid() 
      AND role IN ('admin', 'super_admin')
    ) as is_admin
  ),
  time_periods AS (
    SELECT 
      CURRENT_TIMESTAMP as now,
      CURRENT_DATE as today,
      (CURRENT_TIMESTAMP - INTERVAL '1 day') as one_day_ago,
      (CURRENT_TIMESTAMP - INTERVAL '7 days') as seven_days_ago,
      (CURRENT_TIMESTAMP - INTERVAL '30 days') as thirty_days_ago,
      DATE_TRUNC('week', CURRENT_DATE) as start_of_week,
      DATE_TRUNC('month', CURRENT_DATE) as start_of_month
  ),
  user_counts AS (
    SELECT
      COUNT(*) as total_users,
      COUNT(*) FILTER (WHERE last_login_at > (SELECT thirty_days_ago FROM time_periods)) as active_users,
      COUNT(*) FILTER (WHERE created_at::date = (SELECT today FROM time_periods)) as new_users_today,
      COUNT(*) FILTER (WHERE created_at >= (SELECT start_of_week FROM time_periods)) as new_users_this_week,
      COUNT(*) FILTER (WHERE created_at >= (SELECT start_of_month FROM time_periods)) as new_users_this_month,
      COUNT(*) FILTER (WHERE account_type = 'free') as free_users,
      COUNT(*) FILTER (WHERE account_type = 'basic') as basic_users,
      COUNT(*) FILTER (WHERE account_type = 'premium') as premium_users,
      COUNT(*) FILTER (WHERE subscription_status = 'trial') as trial_users,
      COUNT(*) FILTER (WHERE account_type = 'basic' AND subscription_interval = 'monthly') as basic_monthly_users,
      COUNT(*) FILTER (WHERE account_type = 'basic' AND subscription_interval = 'yearly') as basic_yearly_users,
      COUNT(*) FILTER (WHERE account_type = 'premium' AND subscription_interval = 'monthly') as premium_monthly_users,
      COUNT(*) FILTER (WHERE account_type = 'premium' AND subscription_interval = 'yearly') as premium_yearly_users,
      COUNT(*) FILTER (WHERE last_login_at > (SELECT one_day_ago FROM time_periods)) as daily_active_users,
      COUNT(*) FILTER (WHERE last_login_at > (SELECT seven_days_ago FROM time_periods)) as weekly_active_users,
      COUNT(*) FILTER (WHERE last_login_at > (SELECT thirty_days_ago FROM time_periods)) as monthly_active_users
    FROM public.profiles
    WHERE deleted_at IS NULL
  ),
  trade_counts AS (
    SELECT
      COUNT(*) as total_trades,
      COUNT(*) FILTER (WHERE created_at >= (SELECT start_of_week FROM time_periods)) as trades_this_week,
      COUNT(*) FILTER (WHERE created_at >= (SELECT start_of_month FROM time_periods)) as trades_this_month
    FROM public.trades
  ),
  revenue AS (
    SELECT
      (uc.basic_monthly_users * 15.99 +
       uc.basic_yearly_users * 12.99 +
       uc.premium_monthly_users * 24.99 +
       uc.premium_yearly_users * 19.99) as estimated_monthly_revenue
    FROM user_counts uc
  )
SELECT
  CASE WHEN (SELECT is_admin FROM admin_check) THEN uc.total_users ELSE NULL END as total_users,
  CASE WHEN (SELECT is_admin FROM admin_check) THEN uc.active_users ELSE NULL END as active_users,
  CASE WHEN (SELECT is_admin FROM admin_check) THEN uc.new_users_today ELSE NULL END as new_users_today,
  CASE WHEN (SELECT is_admin FROM admin_check) THEN uc.new_users_this_week ELSE NULL END as new_users_this_week,
  CASE WHEN (SELECT is_admin FROM admin_check) THEN uc.new_users_this_month ELSE NULL END as new_users_this_month,
  CASE WHEN (SELECT is_admin FROM admin_check) THEN uc.free_users ELSE NULL END as free_users,
  CASE WHEN (SELECT is_admin FROM admin_check) THEN uc.basic_users ELSE NULL END as basic_users,
  CASE WHEN (SELECT is_admin FROM admin_check) THEN uc.premium_users ELSE NULL END as premium_users,
  CASE WHEN (SELECT is_admin FROM admin_check) THEN uc.trial_users ELSE NULL END as trial_users,
  CASE WHEN (SELECT is_admin FROM admin_check) THEN uc.basic_monthly_users ELSE NULL END as basic_monthly_users,
  CASE WHEN (SELECT is_admin FROM admin_check) THEN uc.basic_yearly_users ELSE NULL END as basic_yearly_users,
  CASE WHEN (SELECT is_admin FROM admin_check) THEN uc.premium_monthly_users ELSE NULL END as premium_monthly_users,
  CASE WHEN (SELECT is_admin FROM admin_check) THEN uc.premium_yearly_users ELSE NULL END as premium_yearly_users,
  CASE WHEN (SELECT is_admin FROM admin_check) THEN r.estimated_monthly_revenue ELSE NULL END as estimated_monthly_revenue,
  CASE WHEN (SELECT is_admin FROM admin_check) THEN (r.estimated_monthly_revenue * 12) ELSE NULL END as estimated_yearly_revenue,
  CASE WHEN (SELECT is_admin FROM admin_check) THEN tc.total_trades ELSE NULL END as total_trades,
  CASE WHEN (SELECT is_admin FROM admin_check) THEN tc.trades_this_week ELSE NULL END as trades_this_week,
  CASE WHEN (SELECT is_admin FROM admin_check) THEN tc.trades_this_month ELSE NULL END as trades_this_month,
  CASE WHEN (SELECT is_admin FROM admin_check) THEN 
    CASE 
      WHEN uc.total_users > 0 THEN ROUND((tc.total_trades::NUMERIC / uc.total_users::NUMERIC), 2)
      ELSE 0 
    END
  ELSE NULL END as average_trades_per_user,
  CASE WHEN (SELECT is_admin FROM admin_check) THEN uc.daily_active_users ELSE NULL END as daily_active_users,
  CASE WHEN (SELECT is_admin FROM admin_check) THEN uc.weekly_active_users ELSE NULL END as weekly_active_users,
  CASE WHEN (SELECT is_admin FROM admin_check) THEN uc.monthly_active_users ELSE NULL END as monthly_active_users,
  CASE WHEN (SELECT is_admin FROM admin_check) THEN 
    CASE 
      WHEN (uc.free_users + uc.basic_users + uc.premium_users) > 0 
      THEN ROUND(((uc.basic_users + uc.premium_users)::NUMERIC / 
                  (uc.free_users + uc.basic_users + uc.premium_users)::NUMERIC * 100), 2)
      ELSE 0 
    END
  ELSE NULL END as free_to_paying_conversion_rate,
  CASE WHEN (SELECT is_admin FROM admin_check) THEN 
    CASE 
      WHEN (uc.trial_users + uc.basic_users + uc.premium_users) > 0 
      THEN ROUND(((uc.basic_users + uc.premium_users)::NUMERIC / 
                  (uc.trial_users + uc.basic_users + uc.premium_users)::NUMERIC * 100), 2)
      ELSE 0 
    END
  ELSE NULL END as trial_to_paying_conversion_rate,
  (SELECT is_admin FROM admin_check) as _is_authorized
FROM user_counts uc
CROSS JOIN trade_counts tc
CROSS JOIN revenue r;

COMMENT ON VIEW public.admin_stats_view IS 
'Platform statistics for admin dashboard - returns NULL for non-admins';

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- 3.3: RECREATE ADMIN USERS LIST VIEW WITH BUILT-IN SECURITY
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

CREATE OR REPLACE VIEW public.admin_users_list_view 
WITH (security_invoker = false)
AS
SELECT 
  CASE WHEN (SELECT role IN ('admin', 'super_admin') FROM public.profiles WHERE id = auth.uid()) THEN p.id ELSE NULL END as id,
  CASE WHEN (SELECT role IN ('admin', 'super_admin') FROM public.profiles WHERE id = auth.uid()) THEN p.email ELSE NULL END as email,
  CASE WHEN (SELECT role IN ('admin', 'super_admin') FROM public.profiles WHERE id = auth.uid()) THEN COALESCE(p.display_name, split_part(p.email, '@', 1)) ELSE NULL END as display_name,
  CASE WHEN (SELECT role IN ('admin', 'super_admin') FROM public.profiles WHERE id = auth.uid()) THEN COALESCE(p.account_type, 'free') ELSE NULL END as account_type,
  CASE WHEN (SELECT role IN ('admin', 'super_admin') FROM public.profiles WHERE id = auth.uid()) THEN COALESCE(p.role, 'user') ELSE NULL END as role,
  CASE WHEN (SELECT role IN ('admin', 'super_admin') FROM public.profiles WHERE id = auth.uid()) THEN p.subscription_status ELSE NULL END as subscription_status,
  CASE WHEN (SELECT role IN ('admin', 'super_admin') FROM public.profiles WHERE id = auth.uid()) THEN p.subscription_interval ELSE NULL END as subscription_interval,
  CASE WHEN (SELECT role IN ('admin', 'super_admin') FROM public.profiles WHERE id = auth.uid()) THEN p.subscription_expires_at ELSE NULL END as subscription_expires_at,
  CASE WHEN (SELECT role IN ('admin', 'super_admin') FROM public.profiles WHERE id = auth.uid()) THEN p.subscription_cancel_at_period_end ELSE NULL END as subscription_cancel_at_period_end,
  CASE WHEN (SELECT role IN ('admin', 'super_admin') FROM public.profiles WHERE id = auth.uid()) THEN p.is_banned ELSE NULL END as is_banned,
  CASE WHEN (SELECT role IN ('admin', 'super_admin') FROM public.profiles WHERE id = auth.uid()) THEN p.last_login_at ELSE NULL END as last_login_at,
  CASE WHEN (SELECT role IN ('admin', 'super_admin') FROM public.profiles WHERE id = auth.uid()) THEN p.login_count ELSE NULL END as login_count,
  CASE WHEN (SELECT role IN ('admin', 'super_admin') FROM public.profiles WHERE id = auth.uid()) THEN p.created_at ELSE NULL END as created_at,
  CASE WHEN (SELECT role IN ('admin', 'super_admin') FROM public.profiles WHERE id = auth.uid()) THEN p.updated_at ELSE NULL END as updated_at,
  CASE WHEN (SELECT role IN ('admin', 'super_admin') FROM public.profiles WHERE id = auth.uid()) THEN p.current_portfolio ELSE NULL END as current_portfolio,
  CASE WHEN (SELECT role IN ('admin', 'super_admin') FROM public.profiles WHERE id = auth.uid()) THEN p.initial_portfolio ELSE NULL END as initial_portfolio,
  CASE WHEN (SELECT role IN ('admin', 'super_admin') FROM public.profiles WHERE id = auth.uid()) THEN p.total_pnl ELSE NULL END as total_pnl,
  CASE WHEN (SELECT role IN ('admin', 'super_admin') FROM public.profiles WHERE id = auth.uid()) THEN p.trade_count ELSE NULL END as trade_count,
  CASE WHEN (SELECT role IN ('admin', 'super_admin') FROM public.profiles WHERE id = auth.uid()) THEN p.risk_settings ELSE NULL END as risk_settings,
  CASE WHEN (SELECT role IN ('admin', 'super_admin') FROM public.profiles WHERE id = auth.uid()) THEN p.current_month_trades_count ELSE NULL END as current_month_trades_count,
  CASE WHEN (SELECT role IN ('admin', 'super_admin') FROM public.profiles WHERE id = auth.uid()) THEN p.max_trades ELSE NULL END as max_trades,
  CASE WHEN (SELECT role IN ('admin', 'super_admin') FROM public.profiles WHERE id = auth.uid()) THEN p.portfolio_size ELSE NULL END as portfolio_size,
  CASE WHEN (SELECT role IN ('admin', 'super_admin') FROM public.profiles WHERE id = auth.uid()) THEN p.risk_mode ELSE NULL END as risk_mode,
  CASE WHEN (SELECT role IN ('admin', 'super_admin') FROM public.profiles WHERE id = auth.uid()) THEN p.risk_percentage ELSE NULL END as risk_percentage,
  CASE WHEN (SELECT role IN ('admin', 'super_admin') FROM public.profiles WHERE id = auth.uid()) THEN p.fixed_risk_amount ELSE NULL END as fixed_risk_amount,
  CASE WHEN (SELECT role IN ('admin', 'super_admin') FROM public.profiles WHERE id = auth.uid()) THEN 
    CASE 
      WHEN p.risk_mode = 'percentage' THEN ROUND((p.portfolio_size * p.risk_percentage) / 100, 2)
      WHEN p.risk_mode = 'fixed' THEN p.fixed_risk_amount
      ELSE NULL
    END
  ELSE NULL END as calculated_one_r,
  CASE WHEN (SELECT role IN ('admin', 'super_admin') FROM public.profiles WHERE id = auth.uid()) THEN COUNT(DISTINCT t.id) FILTER (WHERE t.exit_price IS NOT NULL) ELSE NULL END as total_closed_trades,
  CASE WHEN (SELECT role IN ('admin', 'super_admin') FROM public.profiles WHERE id = auth.uid()) THEN 
    CASE 
      WHEN COUNT(DISTINCT t.id) FILTER (WHERE t.exit_price IS NOT NULL) > 0 
      THEN ROUND(
        (COUNT(DISTINCT t.id) FILTER (WHERE t.outcome = 'WIN') * 100.0 
        / COUNT(DISTINCT t.id) FILTER (WHERE t.exit_price IS NOT NULL)), 2
      )
      ELSE 0 
    END
  ELSE NULL END as win_rate,
  CASE WHEN (SELECT role IN ('admin', 'super_admin') FROM public.profiles WHERE id = auth.uid()) THEN COUNT(DISTINCT t.id) FILTER (WHERE t.outcome = 'WIN') ELSE NULL END as wins,
  CASE WHEN (SELECT role IN ('admin', 'super_admin') FROM public.profiles WHERE id = auth.uid()) THEN COUNT(DISTINCT t.id) FILTER (WHERE t.outcome = 'LOSS') ELSE NULL END as losses,
  CASE WHEN (SELECT role IN ('admin', 'super_admin') FROM public.profiles WHERE id = auth.uid()) THEN COUNT(DISTINCT t.id) FILTER (WHERE t.outcome = 'BE') ELSE NULL END as break_even,
  CASE WHEN (SELECT role IN ('admin', 'super_admin') FROM public.profiles WHERE id = auth.uid()) THEN COUNT(DISTINCT t.id) FILTER (WHERE t.outcome = 'OPEN') ELSE NULL END as open_trades,
  CASE WHEN (SELECT role IN ('admin', 'super_admin') FROM public.profiles WHERE id = auth.uid()) THEN MAX(t.close_at) ELSE NULL END as last_trade_date,
  CASE WHEN (SELECT role IN ('admin', 'super_admin') FROM public.profiles WHERE id = auth.uid()) THEN ROUND(AVG(t.actual_r) FILTER (WHERE t.actual_r IS NOT NULL), 2) ELSE NULL END as avg_r,
  CASE WHEN (SELECT role IN ('admin', 'super_admin') FROM public.profiles WHERE id = auth.uid()) THEN MAX(t.actual_r) FILTER (WHERE t.actual_r IS NOT NULL) ELSE NULL END as best_r,
  CASE WHEN (SELECT role IN ('admin', 'super_admin') FROM public.profiles WHERE id = auth.uid()) THEN MIN(t.actual_r) FILTER (WHERE t.actual_r IS NOT NULL) ELSE NULL END as worst_r
FROM public.profiles p
LEFT JOIN public.trades t ON t.user_id = p.id
WHERE p.deleted_at IS NULL
  AND (SELECT role IN ('admin', 'super_admin') FROM public.profiles WHERE id = auth.uid())
GROUP BY 
  p.id, p.email, p.display_name, p.account_type, p.role,
  p.subscription_status, p.subscription_interval, p.subscription_expires_at,
  p.subscription_cancel_at_period_end,
  p.is_banned, p.last_login_at, p.login_count, p.created_at, p.updated_at,
  p.current_portfolio, p.initial_portfolio, p.total_pnl, p.trade_count, 
  p.risk_settings, p.current_month_trades_count, p.max_trades,
  p.portfolio_size, p.risk_mode, p.risk_percentage, p.fixed_risk_amount
ORDER BY p.created_at DESC;

COMMENT ON VIEW public.admin_users_list_view IS 
'v9.4.2: User list for admin management - returns empty for non-admins';

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- 3.4: RECREATE SUBSCRIPTION HEALTH VIEW WITH BUILT-IN SECURITY
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

CREATE OR REPLACE VIEW public.subscription_health_view 
WITH (security_invoker = false)
AS
SELECT 
  CASE WHEN (SELECT role IN ('admin', 'super_admin') FROM public.profiles WHERE id = auth.uid()) THEN p.id ELSE NULL END as user_id,
  CASE WHEN (SELECT role IN ('admin', 'super_admin') FROM public.profiles WHERE id = auth.uid()) THEN p.email ELSE NULL END as email,
  CASE WHEN (SELECT role IN ('admin', 'super_admin') FROM public.profiles WHERE id = auth.uid()) THEN p.display_name ELSE NULL END as display_name,
  CASE WHEN (SELECT role IN ('admin', 'super_admin') FROM public.profiles WHERE id = auth.uid()) THEN p.account_type ELSE NULL END as account_type,
  CASE WHEN (SELECT role IN ('admin', 'super_admin') FROM public.profiles WHERE id = auth.uid()) THEN p.subscription_interval ELSE NULL END as subscription_interval,
  CASE WHEN (SELECT role IN ('admin', 'super_admin') FROM public.profiles WHERE id = auth.uid()) THEN p.subscription_status ELSE NULL END as subscription_status,
  CASE WHEN (SELECT role IN ('admin', 'super_admin') FROM public.profiles WHERE id = auth.uid()) THEN p.subscription_expires_at ELSE NULL END as subscription_expires_at,
  CASE WHEN (SELECT role IN ('admin', 'super_admin') FROM public.profiles WHERE id = auth.uid()) THEN p.subscription_cancel_at_period_end ELSE NULL END as subscription_cancel_at_period_end,
  CASE WHEN (SELECT role IN ('admin', 'super_admin') FROM public.profiles WHERE id = auth.uid()) THEN p.cancellation_requested_at ELSE NULL END as cancellation_requested_at,
  CASE WHEN (SELECT role IN ('admin', 'super_admin') FROM public.profiles WHERE id = auth.uid()) THEN p.cancellation_effective_date ELSE NULL END as cancellation_effective_date,
  CASE WHEN (SELECT role IN ('admin', 'super_admin') FROM public.profiles WHERE id = auth.uid()) THEN 
    CASE 
      WHEN p.subscription_expires_at IS NULL THEN NULL
      ELSE EXTRACT(DAY FROM (p.subscription_expires_at - NOW()))::INTEGER
    END
  ELSE NULL END as days_remaining,
  CASE WHEN (SELECT role IN ('admin', 'super_admin') FROM public.profiles WHERE id = auth.uid()) THEN 
    CASE 
      WHEN p.account_type = 'free' THEN 'free'
      WHEN p.subscription_status = 'cancelled' THEN 'cancelled'
      WHEN p.subscription_cancel_at_period_end = TRUE THEN 'cancelling_at_period_end'
      WHEN p.subscription_expires_at < NOW() THEN 'expired'
      WHEN p.subscription_expires_at < NOW() + INTERVAL '7 days' THEN 'expiring_soon'
      WHEN p.subscription_expires_at < NOW() + INTERVAL '14 days' THEN 'active_expiring'
      ELSE 'active_healthy'
    END
  ELSE NULL END as health_status,
  CASE WHEN (SELECT role IN ('admin', 'super_admin') FROM public.profiles WHERE id = auth.uid()) THEN 
    (SELECT ph.created_at 
     FROM payment_history ph 
     WHERE ph.user_id = p.id AND ph.status = 'completed'
     ORDER BY ph.created_at DESC LIMIT 1)
  ELSE NULL END as last_payment_date,
  CASE WHEN (SELECT role IN ('admin', 'super_admin') FROM public.profiles WHERE id = auth.uid()) THEN 
    (SELECT ph.amount 
     FROM payment_history ph 
     WHERE ph.user_id = p.id AND ph.status = 'completed'
     ORDER BY ph.created_at DESC LIMIT 1)
  ELSE NULL END as last_payment_amount,
  CASE WHEN (SELECT role IN ('admin', 'super_admin') FROM public.profiles WHERE id = auth.uid()) THEN 
    (SELECT COALESCE(SUM(ph.amount), 0)
     FROM payment_history ph
     WHERE ph.user_id = p.id AND ph.status = 'completed')
  ELSE NULL END as lifetime_value,
  CASE WHEN (SELECT role IN ('admin', 'super_admin') FROM public.profiles WHERE id = auth.uid()) THEN 
    (SELECT COUNT(*)
     FROM subscription_changes sc
     WHERE sc.user_id = p.id AND sc.change_type = 'renew')
  ELSE NULL END as renewal_count,
  CASE WHEN (SELECT role IN ('admin', 'super_admin') FROM public.profiles WHERE id = auth.uid()) THEN 
    (SELECT sp.period_start
     FROM subscription_periods sp
     WHERE sp.user_id = p.id AND sp.period_end > NOW()
     ORDER BY sp.period_end DESC LIMIT 1)
  ELSE NULL END as current_period_start,
  CASE WHEN (SELECT role IN ('admin', 'super_admin') FROM public.profiles WHERE id = auth.uid()) THEN 
    (SELECT sp.auto_renew
     FROM subscription_periods sp
     WHERE sp.user_id = p.id AND sp.period_end > NOW()
     ORDER BY sp.period_end DESC LIMIT 1)
  ELSE NULL END as auto_renew_enabled
FROM public.profiles p
WHERE p.deleted_at IS NULL
  AND (SELECT role IN ('admin', 'super_admin') FROM public.profiles WHERE id = auth.uid())
ORDER BY 
  CASE p.subscription_status
    WHEN 'active' THEN 1
    WHEN 'cancelled' THEN 2
    WHEN 'expired' THEN 3
    ELSE 4
  END,
  p.subscription_expires_at ASC NULLS LAST;

COMMENT ON VIEW public.subscription_health_view IS 
'ğŸ“Š v9.4.2: Subscription health dashboard - returns empty for non-admins';

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- 3.5: GRANT SELECT TO AUTHENTICATED ON ALL ADMIN VIEWS
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

GRANT SELECT ON public.admin_stats_view TO authenticated;
GRANT SELECT ON public.admin_stats_view TO service_role;

GRANT SELECT ON public.admin_users_list_view TO authenticated;
GRANT SELECT ON public.admin_users_list_view TO service_role;

GRANT SELECT ON public.subscription_health_view TO authenticated;
GRANT SELECT ON public.subscription_health_view TO service_role;

-- Other admin views - grant to both
GRANT SELECT ON public.payment_analytics TO authenticated;
GRANT SELECT ON public.payment_analytics TO service_role;

GRANT SELECT ON public.active_subscriptions TO authenticated;
GRANT SELECT ON public.active_subscriptions TO service_role;

GRANT SELECT ON public.archived_users_view TO authenticated;
GRANT SELECT ON public.archived_users_view TO service_role;

GRANT SELECT ON public.revenue_analytics_view TO authenticated;
GRANT SELECT ON public.revenue_analytics_view TO service_role;

GRANT SELECT ON public.proration_impact_view TO authenticated;
GRANT SELECT ON public.proration_impact_view TO service_role;

GRANT SELECT ON public.cancellation_analytics_view TO authenticated;
GRANT SELECT ON public.cancellation_analytics_view TO service_role;

GRANT SELECT ON public.subscription_flow_view TO authenticated;
GRANT SELECT ON public.subscription_flow_view TO service_role;

-- Public views
GRANT SELECT ON public.pricing_info TO authenticated;
GRANT SELECT ON public.pricing_info TO anon;
GRANT SELECT ON public.pricing_info TO service_role;

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- 3.6: MATERIALIZED VIEWS - service_role + RPC access
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

GRANT SELECT ON public.webhook_stats TO service_role;
GRANT SELECT ON public.strategy_stats_view TO service_role;

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- 3.7: DROP EXISTING FUNCTIONS (to allow return type changes)
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

DROP FUNCTION IF EXISTS public.get_my_webhook_stats() CASCADE;
DROP FUNCTION IF EXISTS public.get_my_strategy_stats() CASCADE;
DROP FUNCTION IF EXISTS public.admin_get_stats() CASCADE;
DROP FUNCTION IF EXISTS public.admin_get_users_list(INTEGER, INTEGER, TEXT, TEXT) CASCADE;
DROP FUNCTION IF EXISTS public.admin_get_payment_analytics() CASCADE;
DROP FUNCTION IF EXISTS public.admin_get_subscription_health() CASCADE;

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- 3.8: CREATE SECURE RPC FUNCTIONS FOR USER DATA
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

-- Function to get user's own webhook stats
CREATE OR REPLACE FUNCTION public.get_my_webhook_stats()
RETURNS TABLE (
  total_trades BIGINT,
  tradingview_trades BIGINT,
  open_tradingview_trades BIGINT,
  closed_tradingview_trades BIGINT,
  last_tradingview_trade_at TIMESTAMPTZ,
  last_trade_created_at TIMESTAMPTZ
)
LANGUAGE plpgsql
SECURITY DEFINER
STABLE
SET search_path = public
AS $$
BEGIN
  RETURN QUERY
  SELECT 
    ws.total_trades,
    ws.tradingview_trades,
    ws.open_tradingview_trades,
    ws.closed_tradingview_trades,
    ws.last_tradingview_trade_at,
    ws.last_trade_created_at
  FROM public.webhook_stats ws
  WHERE ws.user_id = auth.uid();
END;
$$;

GRANT EXECUTE ON FUNCTION public.get_my_webhook_stats() TO authenticated;

COMMENT ON FUNCTION public.get_my_webhook_stats IS 
'ğŸ”’ Secure access to webhook_stats - returns only current user data';

-- Function to get user's own strategy stats
CREATE OR REPLACE FUNCTION public.get_my_strategy_stats()
RETURNS TABLE (
  id UUID,
  name TEXT,
  status TEXT,
  category TEXT,
  setup_type TEXT,
  total_trades BIGINT,
  wins BIGINT,
  losses BIGINT,
  break_even BIGINT,
  open_trades BIGINT,
  win_rate NUMERIC,
  total_pnl NUMERIC,
  avg_win NUMERIC,
  avg_loss NUMERIC,
  best_trade NUMERIC,
  worst_trade NUMERIC,
  avg_r NUMERIC,
  total_r NUMERIC,
  profit_factor NUMERIC,
  last_trade_date TIMESTAMPTZ,
  created_at TIMESTAMPTZ,
  updated_at TIMESTAMPTZ
)
LANGUAGE plpgsql
SECURITY DEFINER
STABLE
SET search_path = public
AS $$
BEGIN
  RETURN QUERY
  SELECT 
    ss.id,
    ss.name,
    ss.status,
    ss.category,
    ss.setup_type,
    ss.total_trades,
    ss.wins,
    ss.losses,
    ss.break_even,
    ss.open_trades,
    ss.win_rate,
    ss.total_pnl,
    ss.avg_win,
    ss.avg_loss,
    ss.best_trade,
    ss.worst_trade,
    ss.avg_r,
    ss.total_r,
    ss.profit_factor,
    ss.last_trade_date,
    ss.created_at,
    ss.updated_at
  FROM public.strategy_stats_view ss
  WHERE ss.user_id = auth.uid();
END;
$$;

GRANT EXECUTE ON FUNCTION public.get_my_strategy_stats() TO authenticated;

COMMENT ON FUNCTION public.get_my_strategy_stats IS 
'ğŸ”’ Secure access to strategy_stats_view - returns only current user strategies';

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- 3.9: ADMIN RPC FUNCTIONS (BACKUP - views now have built-in security)
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

-- Admin stats RPC (backup method)
CREATE OR REPLACE FUNCTION public.admin_get_stats()
RETURNS TABLE (
  total_users BIGINT,
  active_users BIGINT,
  new_users_today BIGINT,
  new_users_this_week BIGINT,
  new_users_this_month BIGINT,
  free_users BIGINT,
  basic_users BIGINT,
  premium_users BIGINT,
  trial_users BIGINT,
  basic_monthly_users BIGINT,
  basic_yearly_users BIGINT,
  premium_monthly_users BIGINT,
  premium_yearly_users BIGINT,
  estimated_monthly_revenue NUMERIC,
  estimated_yearly_revenue NUMERIC,
  total_trades BIGINT,
  trades_this_week BIGINT,
  trades_this_month BIGINT,
  average_trades_per_user NUMERIC,
  daily_active_users BIGINT,
  weekly_active_users BIGINT,
  monthly_active_users BIGINT,
  free_to_paying_conversion_rate NUMERIC,
  trial_to_paying_conversion_rate NUMERIC
)
LANGUAGE plpgsql
SECURITY DEFINER
STABLE
SET search_path = public
AS $$
BEGIN
  -- Check if user is admin
  IF NOT EXISTS (
    SELECT 1 FROM public.profiles 
    WHERE id = auth.uid() 
    AND role IN ('admin', 'super_admin')
  ) THEN
    RAISE EXCEPTION 'Access denied: Admin only';
  END IF;
  
  RETURN QUERY SELECT * FROM public.admin_stats_view WHERE _is_authorized = true;
END;
$$;

GRANT EXECUTE ON FUNCTION public.admin_get_stats() TO authenticated;

-- Admin users list RPC (backup method)
CREATE OR REPLACE FUNCTION public.admin_get_users_list(
  p_limit INTEGER DEFAULT 100,
  p_offset INTEGER DEFAULT 0,
  p_search TEXT DEFAULT NULL,
  p_account_type TEXT DEFAULT NULL
)
RETURNS TABLE (
  id UUID,
  email TEXT,
  display_name TEXT,
  account_type TEXT,
  role TEXT,
  subscription_status TEXT,
  subscription_interval TEXT,
  subscription_expires_at TIMESTAMPTZ,
  subscription_cancel_at_period_end BOOLEAN,
  is_banned BOOLEAN,
  last_login_at TIMESTAMPTZ,
  login_count INTEGER,
  created_at TIMESTAMPTZ,
  updated_at TIMESTAMPTZ,
  current_portfolio NUMERIC,
  initial_portfolio NUMERIC,
  total_pnl NUMERIC,
  trade_count INTEGER,
  risk_settings JSONB,
  current_month_trades_count INTEGER,
  max_trades INTEGER,
  portfolio_size NUMERIC,
  risk_mode TEXT,
  risk_percentage NUMERIC,
  fixed_risk_amount NUMERIC,
  calculated_one_r NUMERIC,
  total_closed_trades BIGINT,
  win_rate NUMERIC,
  wins BIGINT,
  losses BIGINT,
  break_even BIGINT,
  open_trades BIGINT,
  last_trade_date TIMESTAMPTZ,
  avg_r NUMERIC,
  best_r NUMERIC,
  worst_r NUMERIC
)
LANGUAGE plpgsql
SECURITY DEFINER
STABLE
SET search_path = public
AS $$
BEGIN
  -- Check if user is admin
  IF NOT EXISTS (
    SELECT 1 FROM public.profiles 
    WHERE id = auth.uid() 
    AND role IN ('admin', 'super_admin')
  ) THEN
    RAISE EXCEPTION 'Access denied: Admin only';
  END IF;
  
  RETURN QUERY
  SELECT 
    u.id, u.email, u.display_name, u.account_type, u.role,
    u.subscription_status, u.subscription_interval, u.subscription_expires_at,
    u.subscription_cancel_at_period_end, u.is_banned, u.last_login_at,
    u.login_count, u.created_at, u.updated_at, u.current_portfolio,
    u.initial_portfolio, u.total_pnl, u.trade_count, u.risk_settings,
    u.current_month_trades_count, u.max_trades, u.portfolio_size,
    u.risk_mode, u.risk_percentage, u.fixed_risk_amount, u.calculated_one_r,
    u.total_closed_trades, u.win_rate, u.wins, u.losses, u.break_even,
    u.open_trades, u.last_trade_date, u.avg_r, u.best_r, u.worst_r
  FROM public.admin_users_list_view u
  WHERE u.id IS NOT NULL  -- Filter out NULL rows (non-admin access)
    AND (p_search IS NULL OR 
         u.email ILIKE '%' || p_search || '%' OR 
         u.display_name ILIKE '%' || p_search || '%')
    AND (p_account_type IS NULL OR u.account_type = p_account_type)
  ORDER BY u.created_at DESC
  LIMIT p_limit
  OFFSET p_offset;
END;
$$;

GRANT EXECUTE ON FUNCTION public.admin_get_users_list(INTEGER, INTEGER, TEXT, TEXT) TO authenticated;

-- Payment analytics RPC
CREATE OR REPLACE FUNCTION public.admin_get_payment_analytics()
RETURNS TABLE (
  plan TEXT,
  status TEXT,
  payment_count BIGINT,
  total_amount NUMERIC,
  avg_amount NUMERIC,
  month TIMESTAMPTZ
)
LANGUAGE plpgsql
SECURITY DEFINER
STABLE
SET search_path = public
AS $$
BEGIN
  -- Check if user is admin
  IF NOT EXISTS (
    SELECT 1 FROM public.profiles 
    WHERE id = auth.uid() 
    AND role IN ('admin', 'super_admin')
  ) THEN
    RAISE EXCEPTION 'Access denied: Admin only';
  END IF;
  
  RETURN QUERY SELECT * FROM public.payment_analytics;
END;
$$;

GRANT EXECUTE ON FUNCTION public.admin_get_payment_analytics() TO authenticated;

-- Subscription health RPC
CREATE OR REPLACE FUNCTION public.admin_get_subscription_health()
RETURNS TABLE (
  user_id UUID,
  email TEXT,
  display_name TEXT,
  account_type TEXT,
  subscription_interval TEXT,
  subscription_status TEXT,
  subscription_expires_at TIMESTAMPTZ,
  subscription_cancel_at_period_end BOOLEAN,
  cancellation_requested_at TIMESTAMPTZ,
  cancellation_effective_date DATE,
  days_remaining INTEGER,
  health_status TEXT,
  last_payment_date TIMESTAMPTZ,
  last_payment_amount NUMERIC,
  lifetime_value NUMERIC,
  renewal_count BIGINT,
  current_period_start TIMESTAMPTZ,
  auto_renew_enabled BOOLEAN
)
LANGUAGE plpgsql
SECURITY DEFINER
STABLE
SET search_path = public
AS $$
BEGIN
  -- Check if user is admin
  IF NOT EXISTS (
    SELECT 1 FROM public.profiles 
    WHERE id = auth.uid() 
    AND role IN ('admin', 'super_admin')
  ) THEN
    RAISE EXCEPTION 'Access denied: Admin only';
  END IF;
  
  RETURN QUERY SELECT * FROM public.subscription_health_view WHERE shv.user_id IS NOT NULL;
END;
$$;

GRANT EXECUTE ON FUNCTION public.admin_get_subscription_health() TO authenticated;

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- 3.10: VERIFICATION
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

DO $$
DECLARE
  v_views_with_auth INTEGER;
  v_functions_created INTEGER;
BEGIN
  -- Count views accessible to authenticated
  SELECT COUNT(*) INTO v_views_with_auth
  FROM information_schema.role_table_grants
  WHERE table_schema = 'public'
    AND table_name IN ('admin_stats_view', 'admin_users_list_view', 'subscription_health_view')
    AND grantee = 'authenticated'
    AND privilege_type = 'SELECT';
  
  -- Count functions created
  SELECT COUNT(*) INTO v_functions_created
  FROM pg_proc p
  JOIN pg_namespace n ON p.pronamespace = n.oid
  WHERE n.nspname = 'public'
    AND p.proname IN ('get_my_webhook_stats', 'get_my_strategy_stats', 
                      'admin_get_stats', 'admin_get_users_list', 
                      'admin_get_payment_analytics', 'admin_get_subscription_health');

  RAISE NOTICE '';
  RAISE NOTICE 'â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•';
  RAISE NOTICE 'ğŸ”’ SECTION 3 - PERMISSIONS COMPLETE';
  RAISE NOTICE 'â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•';
  RAISE NOTICE '';
  RAISE NOTICE 'ğŸ“Š Results:';
  RAISE NOTICE '   â”œâ”€ Admin views with SELECT grant: % (should be 3)', v_views_with_auth;
  RAISE NOTICE '   â””â”€ RPC functions created: % (should be 6)', v_functions_created;
  RAISE NOTICE '';
  RAISE NOTICE 'ğŸ” Security Model:';
  RAISE NOTICE '   â”œâ”€ Admin Views â†’ Built-in admin check (returns NULL for non-admins)';
  RAISE NOTICE '   â”œâ”€ Direct Access â†’ SELECT granted to authenticated';
  RAISE NOTICE '   â”œâ”€ RPC Backup â†’ Functions with role check available';
  RAISE NOTICE '   â””â”€ User Data â†’ Via secure RPC filtered by auth.uid()';
  RAISE NOTICE '';
  RAISE NOTICE 'âœ… Admins can now directly query admin_stats_view!';
  RAISE NOTICE '';
END $$;
-- ===============================================
-- SECTION 4: DATA MIGRATION & FIXES (PROFILES)
-- ===============================================

DO $$
BEGIN
  RAISE NOTICE '[4/10] ğŸ‘¤ Migrating profile data...';
END $$;

-- Fix profiles defaults
UPDATE public.profiles SET role = 'user' WHERE role IS NULL;
UPDATE public.profiles SET account_type = 'free' 
WHERE account_type IS NULL OR account_type NOT IN ('free', 'basic', 'premium', 'trial');
UPDATE public.profiles SET subscription_status = 'active' WHERE subscription_status IS NULL;

-- âœ… FIXED: Set correct trade limits per account type
UPDATE public.profiles 
SET max_trades = CASE account_type
  WHEN 'free' THEN 10
  WHEN 'basic' THEN 25
  WHEN 'trial' THEN 25
  WHEN 'premium' THEN 999999
  ELSE 10
END
WHERE max_trades IS NULL OR max_trades = 0;

UPDATE public.profiles SET subscription_interval = 'monthly' 
WHERE account_type IN ('basic', 'premium') AND subscription_interval IS NULL;
UPDATE public.profiles SET metadata = '{}'::jsonb WHERE metadata IS NULL;

-- Safe updates for columns that might not exist
DO $$
BEGIN
  -- free_months_available
  IF EXISTS (SELECT 1 FROM information_schema.columns 
    WHERE table_name = 'profiles' AND column_name = 'free_months_available') THEN
    UPDATE public.profiles SET free_months_available = 0 WHERE free_months_available IS NULL;
  END IF;
  
  -- referral_count
  IF EXISTS (SELECT 1 FROM information_schema.columns 
    WHERE table_name = 'profiles' AND column_name = 'referral_count') THEN
    UPDATE public.profiles SET referral_count = 0 WHERE referral_count IS NULL;
  END IF;
END $$;

UPDATE public.profiles SET billing_cycle_start = CURRENT_DATE WHERE billing_cycle_start IS NULL;
UPDATE public.profiles SET current_month_trades_count = 0 WHERE current_month_trades_count IS NULL;

-- ğŸ†• v9.4.2: Set default for subscription_cancel_at_period_end
UPDATE public.profiles SET subscription_cancel_at_period_end = FALSE 
WHERE subscription_cancel_at_period_end IS NULL;

-- Initialize portfolio columns
UPDATE public.profiles SET initial_portfolio = 10000 WHERE initial_portfolio IS NULL;
UPDATE public.profiles SET current_portfolio = initial_portfolio WHERE current_portfolio IS NULL;
UPDATE public.profiles SET total_pnl = 0 WHERE total_pnl IS NULL;
UPDATE public.profiles SET trade_count = 0 WHERE trade_count IS NULL;

-- ğŸ”¥ FIX EXISTING USERS WITH NULL risk_settings
UPDATE public.profiles
SET 
  portfolio_size = COALESCE(initial_portfolio, 10000),
  risk_mode = 'percentage',
  risk_percentage = 1,
  fixed_risk_amount = NULL,
  initial_portfolio = COALESCE(initial_portfolio, 10000),
  current_portfolio = COALESCE(current_portfolio, initial_portfolio, 10000),
  total_pnl = COALESCE(total_pnl, 0)
WHERE portfolio_size IS NULL OR risk_mode IS NULL;

-- ğŸ†• UPDATE EXISTING BASIC AND TRIAL USERS TO 25 TRADES
DO $$
DECLARE
  v_affected_users INTEGER;
BEGIN
  RAISE NOTICE 'ğŸ”„ Updating existing BASIC and TRIAL users to 25 trades limit...';
  
  UPDATE public.profiles
  SET max_trades = 25
  WHERE account_type IN ('basic', 'trial')
    AND max_trades != 25;
  
  GET DIAGNOSTICS v_affected_users = ROW_COUNT;
  
  IF v_affected_users > 0 THEN
    BEGIN
      INSERT INTO public.admin_audit_log (admin_id, action, details)
      SELECT 
        id,
        'UPDATE_TRADE_LIMITS',
        jsonb_build_object(
          'change', 'BASIC and TRIAL limits changed to 25 trades/month',
          'affected_users', v_affected_users,
          'previous_limit', 'unlimited',
          'new_limit', 25,
          'timestamp', NOW()
        )
      FROM public.profiles
      WHERE role = 'super_admin'
      LIMIT 1;
    EXCEPTION WHEN undefined_table THEN
      NULL;
    END;
    
    RAISE NOTICE 'âœ… Updated % BASIC/TRIAL users to 25 trades/month', v_affected_users;
  ELSE
    RAISE NOTICE 'â„¹ï¸  No BASIC/TRIAL users needed update (already at 25 trades)';
  END IF;
END $$;

-- ===============================================
-- SECTION 5: DATA MIGRATION & FIXES (TRADES)
-- ===============================================

DO $$
BEGIN
  RAISE NOTICE '[5/10] ğŸ“ˆ Migrating trade data...';
END $$;

UPDATE public.trades SET open_at = created_at 
WHERE open_at IS NULL AND created_at IS NOT NULL;

UPDATE public.trades SET outcome = CASE 
  WHEN exit_price IS NULL THEN 'OPEN'
  WHEN pnl > 0 THEN 'WIN'
  WHEN pnl < 0 THEN 'LOSS'
  ELSE 'BE'
END WHERE outcome IS NULL;

UPDATE public.trades
SET 
  risk_pts = ABS(entry_price - stop_price),
  reward_pts = CASE 
    WHEN take_profit_price IS NOT NULL AND side = 'LONG' THEN take_profit_price - entry_price
    WHEN take_profit_price IS NOT NULL AND side = 'SHORT' THEN entry_price - take_profit_price
    ELSE NULL
  END,
  risk_usd = (ABS(entry_price - stop_price) * quantity * COALESCE(multiplier, 1)) + COALESCE(fees, 0),
  reward_usd = CASE 
    WHEN take_profit_price IS NOT NULL AND side = 'LONG' THEN (take_profit_price - entry_price) * quantity * COALESCE(multiplier, 1)
    WHEN take_profit_price IS NOT NULL AND side = 'SHORT' THEN (entry_price - take_profit_price) * quantity * COALESCE(multiplier, 1)
    ELSE NULL
  END,
  rr = CASE
    WHEN stop_price IS NOT NULL AND take_profit_price IS NOT NULL 
    AND ABS(entry_price - stop_price) > 0 THEN
      ROUND(
        ABS(
          CASE 
            WHEN side = 'LONG' THEN take_profit_price - entry_price
            ELSE entry_price - take_profit_price
          END
        ) / ABS(entry_price - stop_price),
        4
      )
    ELSE NULL
  END
WHERE 
  stop_price IS NOT NULL 
  AND (risk_pts IS NULL OR risk_usd IS NULL OR rr IS NULL);

-- ===============================================
-- ğŸ”´ SECTION 8: RLS POLICIES - REMOVED!
-- ===============================================

DO $$
BEGIN
  RAISE NOTICE '[8/10] ğŸ”’ RLS policies defined in Part 1 - skipping...';
  RAISE NOTICE '   âœ… profiles_select_policy (with admin mode) - Part 1';
  RAISE NOTICE '   âœ… profiles_admin_update_policy - Part 1';
  RAISE NOTICE '   âœ… profiles_insert_policy - Part 1';
  RAISE NOTICE '   âœ… profiles_delete_never - Part 1';
END $$;

-- ===============================================
-- SECTION 9: GRANT ALL FUNCTION PERMISSIONS
-- ===============================================

DO $$
BEGIN
  RAISE NOTICE '[9/10] ğŸ”‘ Granting ALL function permissions...';
END $$;

-- Core functions
DO $$
BEGIN
  BEGIN
    GRANT EXECUTE ON FUNCTION public.get_asset_multiplier(TEXT) TO authenticated;
  EXCEPTION WHEN undefined_function THEN NULL;
  END;
  BEGIN
    GRANT EXECUTE ON FUNCTION public.is_admin() TO authenticated;
  EXCEPTION WHEN undefined_function THEN NULL;
  END;
  BEGIN
    GRANT EXECUTE ON FUNCTION public.is_super_admin() TO authenticated;
  EXCEPTION WHEN undefined_function THEN NULL;
  END;
  BEGIN
    GRANT EXECUTE ON FUNCTION public.get_user_role() TO authenticated;
  EXCEPTION WHEN undefined_function THEN NULL;
  END;
END $$;

-- Trade limits
DO $$
BEGIN
  BEGIN
    GRANT EXECUTE ON FUNCTION public.get_trade_limit(TEXT) TO authenticated;
  EXCEPTION WHEN undefined_function THEN NULL;
  END;
  BEGIN
    GRANT EXECUTE ON FUNCTION public.get_remaining_trades(UUID) TO authenticated;
  EXCEPTION WHEN undefined_function THEN NULL;
  END;
  BEGIN
    GRANT EXECUTE ON FUNCTION public.can_create_trade(UUID) TO authenticated;
  EXCEPTION WHEN undefined_function THEN NULL;
  END;
  BEGIN
    GRANT EXECUTE ON FUNCTION public.check_usage_warning(UUID) TO authenticated;
  EXCEPTION WHEN undefined_function THEN NULL;
  END;
  BEGIN
    GRANT EXECUTE ON FUNCTION public.mark_warning_shown(UUID) TO authenticated;
  EXCEPTION WHEN undefined_function THEN NULL;
  END;
  BEGIN
    GRANT EXECUTE ON FUNCTION public.reset_monthly_trade_counts() TO service_role;
  EXCEPTION WHEN undefined_function THEN NULL;
  END;
END $$;

-- Subscriptions
DO $$
BEGIN
  BEGIN
    GRANT EXECUTE ON FUNCTION public.get_user_subscription_status(UUID) TO authenticated;
  EXCEPTION WHEN undefined_function THEN NULL;
  END;
  BEGIN
    GRANT EXECUTE ON FUNCTION public.check_expired_subscriptions() TO service_role;
  EXCEPTION WHEN undefined_function THEN NULL;
  END;
  BEGIN
    GRANT EXECUTE ON FUNCTION public.process_expired_subscriptions() TO service_role;
  EXCEPTION WHEN undefined_function THEN NULL;
  END;
  BEGIN
    GRANT EXECUTE ON FUNCTION public.verify_and_activate_subscription(UUID, TEXT, TEXT, TEXT) TO service_role;
  EXCEPTION WHEN undefined_function THEN NULL;
  END;
END $$;

-- Portfolio & Stats
DO $$
BEGIN
  BEGIN
    GRANT EXECUTE ON FUNCTION public.get_portfolio_stats(UUID) TO authenticated;
  EXCEPTION WHEN undefined_function THEN NULL;
  END;
END $$;

-- Search & Notes
DO $$
BEGIN
  BEGIN
    GRANT EXECUTE ON FUNCTION public.search_trades(TEXT, UUID) TO authenticated;
  EXCEPTION WHEN undefined_function THEN NULL;
  END;
  BEGIN
    GRANT EXECUTE ON FUNCTION public.get_trade_details(UUID) TO authenticated;
  EXCEPTION WHEN undefined_function THEN NULL;
  END;
  BEGIN
    GRANT EXECUTE ON FUNCTION public.get_user_storage_usage(UUID) TO authenticated;
  EXCEPTION WHEN undefined_function THEN NULL;
  END;
END $$;

-- TradingView
DO $$
BEGIN
  BEGIN
    GRANT EXECUTE ON FUNCTION public.close_tradingview_trade(UUID, TEXT, TEXT, NUMERIC) TO authenticated;
  EXCEPTION WHEN undefined_function THEN NULL;
  END;
  BEGIN
    GRANT EXECUTE ON FUNCTION public.generate_tradingview_webhook() TO authenticated;
  EXCEPTION WHEN undefined_function THEN NULL;
  END;
END $$;

-- Admin functions
DO $$
BEGIN
  BEGIN
    GRANT EXECUTE ON FUNCTION public.log_admin_action(TEXT, TEXT, UUID, JSONB) TO authenticated;
  EXCEPTION WHEN undefined_function THEN NULL;
  END;
  BEGIN
    GRANT EXECUTE ON FUNCTION public.admin_toggle_user_ban(UUID, TEXT) TO authenticated;
  EXCEPTION WHEN undefined_function THEN NULL;
  END;
  BEGIN
    GRANT EXECUTE ON FUNCTION public.admin_update_subscription(UUID, TEXT, TEXT, TEXT, TIMESTAMPTZ) TO authenticated;
  EXCEPTION WHEN undefined_function THEN NULL;
  END;
  BEGIN
    GRANT EXECUTE ON FUNCTION public.admin_reset_trade_count(UUID) TO authenticated;
  EXCEPTION WHEN undefined_function THEN NULL;
  END;
  BEGIN
    GRANT EXECUTE ON FUNCTION public.admin_grant_free_months(UUID, INTEGER) TO authenticated;
  EXCEPTION WHEN undefined_function THEN NULL;
  END;
  BEGIN
    GRANT EXECUTE ON FUNCTION public.admin_get_limits_overview() TO authenticated;
  EXCEPTION WHEN undefined_function THEN NULL;
  END;
  BEGIN
    GRANT EXECUTE ON FUNCTION public.get_platform_stats() TO authenticated;
  EXCEPTION WHEN undefined_function THEN NULL;
  END;
  BEGIN
    GRANT EXECUTE ON FUNCTION public.get_user_detailed_stats(UUID) TO authenticated;
  EXCEPTION WHEN undefined_function THEN NULL;
  END;
  BEGIN
    GRANT EXECUTE ON FUNCTION public.get_subscription_breakdown() TO authenticated;
  EXCEPTION WHEN undefined_function THEN NULL;
  END;
  BEGIN
    GRANT EXECUTE ON FUNCTION public.get_revenue_analytics(INTEGER) TO authenticated;
  EXCEPTION WHEN undefined_function THEN NULL;
  END;
END $$;

-- Broker functions
DO $$
BEGIN
  BEGIN
    GRANT EXECUTE ON FUNCTION public.get_broker_status(TEXT) TO authenticated;
  EXCEPTION WHEN undefined_function THEN NULL;
  END;
  BEGIN
    GRANT EXECUTE ON FUNCTION public.get_trades_by_broker() TO authenticated;
  EXCEPTION WHEN undefined_function THEN NULL;
  END;
  BEGIN
    GRANT EXECUTE ON FUNCTION public.admin_get_broker_stats() TO authenticated;
  EXCEPTION WHEN undefined_function THEN NULL;
  END;
END $$;

-- Payment Security Functions
DO $$
BEGIN
  BEGIN
    GRANT EXECUTE ON FUNCTION public.verify_paid_access(UUID) TO authenticated;
  EXCEPTION WHEN undefined_function THEN NULL;
  END;
  BEGIN
    GRANT EXECUTE ON FUNCTION public.admin_grant_free_access(UUID, INTEGER, TEXT) TO authenticated;
  EXCEPTION WHEN undefined_function THEN NULL;
  END;
END $$;

-- Rate Limiting Functions
DO $$
BEGIN
  BEGIN
    GRANT EXECUTE ON FUNCTION public.check_rate_limit(TEXT, INTEGER, INTEGER) TO authenticated;
  EXCEPTION WHEN undefined_function THEN NULL;
  END;
END $$;

-- Soft Delete Functions
DO $$
BEGIN
  BEGIN
    GRANT EXECUTE ON FUNCTION public.soft_delete_trade(UUID) TO authenticated;
  EXCEPTION WHEN undefined_function THEN NULL;
  END;
  BEGIN
    GRANT EXECUTE ON FUNCTION public.restore_trade(UUID) TO authenticated;
  EXCEPTION WHEN undefined_function THEN NULL;
  END;
  BEGIN
    GRANT EXECUTE ON FUNCTION public.permanent_delete_trade(UUID) TO authenticated;
  EXCEPTION WHEN undefined_function THEN NULL;
  END;
END $$;

-- Impersonation Functions
DO $$
BEGIN
  BEGIN
    GRANT EXECUTE ON FUNCTION public.start_impersonation_session_v1(UUID, TEXT) TO authenticated;
  EXCEPTION WHEN undefined_function THEN NULL;
  END;
  BEGIN
    GRANT EXECUTE ON FUNCTION public.end_impersonation_session(TEXT) TO authenticated;
  EXCEPTION WHEN undefined_function THEN NULL;
  END;
  BEGIN
    GRANT EXECUTE ON FUNCTION public.get_active_impersonation_sessions() TO authenticated;
  EXCEPTION WHEN undefined_function THEN NULL;
  END;
END $$;

-- Main Grant Free Access Function
DO $$
BEGIN
  BEGIN
    GRANT EXECUTE ON FUNCTION public.grant_free_access(UUID, INTEGER, TEXT, UUID) TO authenticated;
  EXCEPTION WHEN undefined_function THEN NULL;
  END;
END $$;

-- ===============================================
-- ğŸ†• SECTION 10: CRON JOBS SETUP
-- ===============================================
-- âš ï¸ NOTE: pg_cron must be enabled via Supabase Dashboard
-- Database â†’ Extensions â†’ pg_cron â†’ Enable
-- Then run these commands in SQL Editor:
-- ===============================================

DO $notice_block$
BEGIN
  RAISE NOTICE '';
  RAISE NOTICE '[10/10] â° CRON JOBS - Manual Setup Required!';
  RAISE NOTICE '';
  RAISE NOTICE 'Run these in Supabase SQL Editor after enabling pg_cron:';
  RAISE NOTICE '';
  RAISE NOTICE '-- 1. Daily 2:00 AM - Process expired subscriptions';
  RAISE NOTICE 'SELECT cron.schedule(''expire-subscriptions'', ''0 2 * * *'', ''SELECT process_expired_subscriptions()'');';
  RAISE NOTICE '';
  RAISE NOTICE '-- 2. Daily 3:00 AM - Archive deleted users (30+ days)';  
  RAISE NOTICE 'SELECT cron.schedule(''archive-users'', ''0 3 * * *'', ''SELECT archive_soft_deleted_users()'');';
  RAISE NOTICE '';
  RAISE NOTICE '-- 3. Daily 5:00 AM - Refresh materialized views';
  RAISE NOTICE 'SELECT cron.schedule(''refresh-views'', ''0 5 * * *'', ''REFRESH MATERIALIZED VIEW CONCURRENTLY webhook_stats; REFRESH MATERIALIZED VIEW CONCURRENTLY strategy_stats_view;'');';
  RAISE NOTICE '';
  RAISE NOTICE '-- 4. Weekly Sunday 4:00 AM - Cleanup old rate limits';
  RAISE NOTICE 'SELECT cron.schedule(''cleanup-rate-limits'', ''0 4 * * 0'', ''DELETE FROM api_rate_limits WHERE window_start < NOW() - INTERVAL ''''7 days'''''');';
  RAISE NOTICE '';
END $notice_block$;

-- âŒ Don't try to create extension - it requires superuser
-- CREATE EXTENSION IF NOT EXISTS pg_cron;  -- REMOVED!

-- Try to schedule if pg_cron is available (won't fail if not)
DO $cron_block$
BEGIN
  BEGIN
    PERFORM cron.schedule(
      'archive-soft-deleted-users',
      '0 3 * * *',
      'SELECT public.archive_soft_deleted_users();'
    );
    RAISE NOTICE 'âœ… Scheduled: archive-soft-deleted-users (daily 3:00 AM)';
  EXCEPTION WHEN undefined_function THEN
    RAISE WARNING 'âš ï¸  pg_cron not available - schedule manually';
  WHEN OTHERS THEN
    RAISE WARNING 'âš ï¸  Could not schedule: %', SQLERRM;
  END;
END $cron_block$;

DO $cron_block2$
BEGIN
  BEGIN
    IF EXISTS (SELECT 1 FROM pg_proc WHERE proname = 'process_expired_subscriptions') THEN
      PERFORM cron.schedule(
        'process-expired-subscriptions',
        '0 2 * * *',
        'SELECT public.process_expired_subscriptions();'
      );
      RAISE NOTICE 'âœ… Scheduled: process-expired-subscriptions (daily 2:00 AM)';
    END IF;
  EXCEPTION WHEN undefined_function THEN
    RAISE WARNING 'âš ï¸  pg_cron not available';
  WHEN OTHERS THEN
    RAISE WARNING 'âš ï¸  Could not schedule: %', SQLERRM;
  END;
END $cron_block2$;

DO $cron_block3$
BEGIN
  BEGIN
    PERFORM cron.schedule(
      'refresh-materialized-views',
      '0 5 * * *',
      'REFRESH MATERIALIZED VIEW CONCURRENTLY webhook_stats; REFRESH MATERIALIZED VIEW CONCURRENTLY strategy_stats_view;'
    );
    RAISE NOTICE 'âœ… Scheduled: refresh-materialized-views (daily 5:00 AM)';
  EXCEPTION WHEN undefined_function THEN
    RAISE WARNING 'âš ï¸  pg_cron not available';
  WHEN OTHERS THEN
    RAISE WARNING 'âš ï¸  Could not schedule: %', SQLERRM;
  END;
END $cron_block3$;

DO $cron_block4$
BEGIN
  BEGIN
    IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'api_rate_limits') THEN
      PERFORM cron.schedule(
        'cleanup-old-rate-limits',
        '0 4 * * 0',
        'DELETE FROM api_rate_limits WHERE window_start < NOW() - INTERVAL ''7 days'';'
      );
      RAISE NOTICE 'âœ… Scheduled: cleanup-old-rate-limits (weekly Sunday 4:00 AM)';
    END IF;
  EXCEPTION WHEN undefined_function THEN
    RAISE WARNING 'âš ï¸  pg_cron not available';
  WHEN OTHERS THEN
    RAISE WARNING 'âš ï¸  Could not schedule: %', SQLERRM;
  END;
END $cron_block4$;

-- ===============================================
-- REFRESH MATERIALIZED VIEWS
-- ===============================================

DO $$
BEGIN
  RAISE NOTICE '';
  RAISE NOTICE 'ğŸ”„ Refreshing materialized views...';
END $$;

REFRESH MATERIALIZED VIEW public.webhook_stats;
REFRESH MATERIALIZED VIEW public.strategy_stats_view;

COMMIT;

-- ===============================================
-- ğŸ” FINAL SYNC VERIFICATION (FROM DOCUMENT 1)
-- ===============================================

DO $$
DECLARE
  v_sync_issues TEXT[] := ARRAY[]::TEXT[];
BEGIN
  RAISE NOTICE '';
  RAISE NOTICE 'ğŸ” Running sync verification...';
  
  -- Check critical columns exist
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns 
    WHERE table_name = 'profiles' AND column_name = 'subscription_expires_at') THEN
    v_sync_issues := array_append(v_sync_issues, 'Missing: profiles.subscription_expires_at');
  END IF;
  
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns 
    WHERE table_name = 'profiles' AND column_name = 'subscription_cancel_at_period_end') THEN
    v_sync_issues := array_append(v_sync_issues, 'Missing: profiles.subscription_cancel_at_period_end');
  END IF;
  
  -- Check critical functions exist
  IF NOT EXISTS (SELECT 1 FROM pg_proc WHERE proname = 'get_trade_limit') THEN
    v_sync_issues := array_append(v_sync_issues, 'Missing: get_trade_limit()');
  END IF;
  
  IF NOT EXISTS (SELECT 1 FROM pg_proc WHERE proname = 'can_create_trade') THEN
    v_sync_issues := array_append(v_sync_issues, 'Missing: can_create_trade()');
  END IF;
  
  IF NOT EXISTS (SELECT 1 FROM pg_proc WHERE proname = 'process_expired_subscriptions') THEN
    v_sync_issues := array_append(v_sync_issues, 'Missing: process_expired_subscriptions()');
  END IF;
  
  -- Check for deprecated columns
  IF EXISTS (SELECT 1 FROM information_schema.columns 
    WHERE table_name = 'profiles' AND column_name = 'subscription_end_date') THEN
    v_sync_issues := array_append(v_sync_issues, 'Deprecated column exists: subscription_end_date');
  END IF;
  
  IF EXISTS (SELECT 1 FROM information_schema.columns 
    WHERE table_name = 'trades' AND column_name = 'actual_user_r') THEN
    v_sync_issues := array_append(v_sync_issues, 'Deprecated column exists: trades.actual_user_r');
  END IF;
  
  -- Report results
  IF array_length(v_sync_issues, 1) > 0 THEN
    RAISE WARNING '';
    RAISE WARNING 'âš ï¸ SYNC ISSUES FOUND:';
    FOR i IN 1..array_length(v_sync_issues, 1) LOOP
      RAISE WARNING '   â€¢ %', v_sync_issues[i];
    END LOOP;
    RAISE WARNING '';
  ELSE
    RAISE NOTICE '';
    RAISE NOTICE 'âœ… All sync checks passed!';
    RAISE NOTICE '';
  END IF;
END $$;

-- ===============================================
-- FINAL VERIFICATION
-- ===============================================

DO $$
DECLARE 
  total_users INTEGER;
  total_trades INTEGER;
  total_strategies INTEGER;
  total_functions INTEGER;
  total_triggers INTEGER;
  total_indexes INTEGER;
  total_policies INTEGER;
  total_views INTEGER;
  total_mat_views INTEGER;
  users_with_risk_settings INTEGER;
  super_admin_exists BOOLEAN;
  webhook_stats_rows INTEGER;
  strategy_stats_rows INTEGER;
  basic_trial_users INTEGER;
  admin_stats_exists BOOLEAN;
  admin_users_view_exists BOOLEAN;
  strategy_stats_exists BOOLEAN;
  profiles_policies_count INTEGER;
  subscription_views_count INTEGER;
  has_cancel_at_period_end BOOLEAN;
BEGIN
  RAISE NOTICE '';
  RAISE NOTICE 'â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•';
  RAISE NOTICE '          ğŸ” FINAL VERIFICATION';
  RAISE NOTICE 'â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•';
  RAISE NOTICE '';
  
  SELECT COUNT(*) INTO total_users FROM public.profiles;
  SELECT COUNT(*) INTO total_trades FROM public.trades;
  SELECT COUNT(*) INTO total_strategies FROM public.strategies;
  SELECT COUNT(*) INTO total_functions FROM pg_proc p 
    JOIN pg_namespace n ON p.pronamespace = n.oid 
    WHERE n.nspname = 'public';
  SELECT COUNT(*) INTO total_triggers FROM pg_trigger t
    JOIN pg_class c ON t.tgrelid = c.oid
    JOIN pg_namespace n ON c.relnamespace = n.oid
    WHERE n.nspname = 'public' AND NOT t.tgisinternal;
  SELECT COUNT(*) INTO total_indexes FROM pg_indexes WHERE schemaname = 'public';
  SELECT COUNT(*) INTO total_policies FROM pg_policies WHERE schemaname = 'public';
  SELECT COUNT(*) INTO total_views FROM pg_views WHERE schemaname = 'public';
  SELECT COUNT(*) INTO total_mat_views FROM pg_matviews WHERE schemaname = 'public';
  SELECT COUNT(*) INTO users_with_risk_settings 
    FROM public.profiles WHERE portfolio_size IS NOT NULL AND risk_mode IS NOT NULL;
  SELECT EXISTS(SELECT 1 FROM public.profiles WHERE email = 'elad2550@gmail.com' AND role = 'super_admin') INTO super_admin_exists;
  SELECT COUNT(*) INTO webhook_stats_rows FROM public.webhook_stats;
  SELECT COUNT(*) INTO strategy_stats_rows FROM public.strategy_stats_view;
  SELECT COUNT(*) INTO basic_trial_users FROM public.profiles WHERE account_type IN ('basic', 'trial') AND max_trades = 25;
  
  SELECT EXISTS(SELECT 1 FROM information_schema.views WHERE table_name = 'admin_stats_view') INTO admin_stats_exists;
  SELECT EXISTS(SELECT 1 FROM information_schema.views WHERE table_name = 'admin_users_list_view') INTO admin_users_view_exists;
  SELECT EXISTS(SELECT 1 FROM pg_matviews WHERE matviewname = 'strategy_stats_view') INTO strategy_stats_exists;
  
  SELECT COUNT(*) INTO subscription_views_count FROM information_schema.views 
  WHERE table_name IN ('subscription_health_view', 'revenue_analytics_view', 'proration_impact_view', 
                       'cancellation_analytics_view', 'subscription_flow_view');
  
  SELECT EXISTS(
    SELECT 1 FROM information_schema.columns 
    WHERE table_name = 'profiles' AND column_name = 'subscription_cancel_at_period_end'
  ) INTO has_cancel_at_period_end;
  
  SELECT COUNT(*) INTO profiles_policies_count
  FROM pg_policies WHERE schemaname = 'public' AND tablename = 'profiles';
  
  RAISE NOTICE 'â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—';
  RAISE NOTICE 'â•‘  âœ… FINOTAUR MIGRATION v9.4.2 COMPLETE!       â•‘';
  RAISE NOTICE 'â•‘     ğŸ”„ SYNCED: Part 1 v9.4.2 + Part 2 merged  â•‘';
  RAISE NOTICE 'â•‘     ğŸ†• BASIC/TRIAL = 25 trades/month          â•‘';
  RAISE NOTICE 'â•‘     ğŸ†• ALL VIEWS FIXED!                       â•‘';
  RAISE NOTICE 'â•‘     ğŸ†• SUBSCRIPTION MGMT VIEWS!               â•‘';
  RAISE NOTICE 'â•‘     ğŸ†• CRON JOBS CONFIGURED!                  â•‘';
  RAISE NOTICE 'â•‘     ğŸ”’ RLS: Uses Part 1 policies              â•‘';
  RAISE NOTICE 'â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•';
  RAISE NOTICE '';
  RAISE NOTICE 'ğŸ“Š DATABASE STATISTICS:';
  RAISE NOTICE '   â”œâ”€ Regular Views: %', total_views;
  RAISE NOTICE '   â”œâ”€ Materialized Views: %', total_mat_views;
  RAISE NOTICE '   â”œâ”€ Subscription Mgmt Views: % / 5', subscription_views_count;
  RAISE NOTICE '   â”œâ”€ Functions: %', total_functions;
  RAISE NOTICE '   â”œâ”€ Triggers: %', total_triggers;
  RAISE NOTICE '   â”œâ”€ Indexes: %', total_indexes;
  RAISE NOTICE '   â””â”€ RLS Policies: %', profiles_policies_count;
  RAISE NOTICE '';
  RAISE NOTICE 'ğŸ” CRITICAL VIEWS STATUS:';
  RAISE NOTICE '   â”œâ”€ admin_stats_view: %', CASE WHEN admin_stats_exists THEN 'âœ… EXISTS' ELSE 'âŒ MISSING' END;
  RAISE NOTICE '   â”œâ”€ admin_users_list_view: %', CASE WHEN admin_users_view_exists THEN 'âœ… EXISTS' ELSE 'âŒ MISSING' END;
  RAISE NOTICE '   â”œâ”€ strategy_stats_view: %', CASE WHEN strategy_stats_exists THEN 'âœ… EXISTS' ELSE 'âŒ MISSING' END;
  RAISE NOTICE '   â””â”€ subscription_health_view: %', CASE WHEN subscription_views_count >= 5 THEN 'âœ… ALL 5 VIEWS' ELSE 'âš ï¸ MISSING' END;
  RAISE NOTICE '';
  RAISE NOTICE 'ğŸ†• v9.4.2 COLUMN STATUS:';
  RAISE NOTICE '   â””â”€ subscription_cancel_at_period_end: %', CASE WHEN has_cancel_at_period_end THEN 'âœ… EXISTS' ELSE 'âŒ MISSING' END;
  RAISE NOTICE '';
  RAISE NOTICE 'ğŸ‘¥ USER DATA:';
  RAISE NOTICE '   â”œâ”€ Total Users: %', total_users;
  RAISE NOTICE '   â”œâ”€ Total Trades: %', total_trades;
  RAISE NOTICE '   â”œâ”€ Total Strategies: %', total_strategies;
  RAISE NOTICE '   â”œâ”€ Users with Risk Settings: %', users_with_risk_settings;
  RAISE NOTICE '   â”œâ”€ BASIC/TRIAL with 25 trades: %', basic_trial_users;
  RAISE NOTICE '   â””â”€ Super Admin Setup: %', CASE WHEN super_admin_exists THEN 'âœ… YES' ELSE 'âŒ NO' END;
  RAISE NOTICE '';
  RAISE NOTICE 'ğŸ¯ TRADE LIMITS:';
  RAISE NOTICE '   â”œâ”€ FREE: 10 lifetime trades';
  RAISE NOTICE '   â”œâ”€ BASIC: 25 trades/month âœ…';
  RAISE NOTICE '   â”œâ”€ TRIAL: 25 trades/month âœ…';
  RAISE NOTICE '   â””â”€ PREMIUM: Unlimited';
  RAISE NOTICE '';
  RAISE NOTICE 'â° CRON JOBS (manual setup if pg_cron unavailable):';
  RAISE NOTICE '   âœ… 02:00 AM Daily - Expire old subscriptions';
  RAISE NOTICE '   âœ… 03:00 AM Daily - Archive deleted users (30+ days)';
  RAISE NOTICE '   âœ… 04:00 AM Sunday - Cleanup old rate limits';
  RAISE NOTICE '   âœ… 05:00 AM Daily - Refresh materialized views';
  RAISE NOTICE '';
  RAISE NOTICE 'âœ… MIGRATION v9.4.2 COMPLETE - PRODUCTION READY!';
  RAISE NOTICE 'â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•';
  RAISE NOTICE '';
END $$;

-- ===============================================
-- END OF MIGRATION v9.4.2
-- ===============================================