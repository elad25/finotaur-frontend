-- ===============================================
-- ğŸ”¥ FINOTAUR - COMPLETE UNIFIED MIGRATION
-- ===============================================
-- Version: MERGED-v8.5.10-SYNC (NO AFFILIATE)
-- Date: 2025-01-22
-- Parts: 3/4 (Functions + Triggers) - COMPLETE FILE
-- ğŸ”¥ v8.5.10: ALL BUGS FIXED + NEW ADDITIONS!
-- ğŸ”¥ WITH SNAPTRADE INTEGRATION!
-- ğŸ”§ REMOVED: All affiliate/referral features
-- ğŸ”§ INCLUDES ALL v8.5.2 FIXES + v8.5.10 ADDITIONS
-- ğŸ”§ v9.4.2-SYNCED: Fixed subscription_end_date â†’ subscription_expires_at
-- ğŸ”§ v9.4.2-SYNCED: Fixed duplicate functions
-- ğŸ”§ v9.4.2-SYNCED: Added subscription_cancel_at_period_end
-- PREREQUISITE: Run PART-1-SCHEMA.sql first!
-- ===============================================

BEGIN;

DO $$
BEGIN
  RAISE NOTICE '';
  RAISE NOTICE 'â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—';
  RAISE NOTICE 'â•‘  ğŸ”¥ FINOTAUR MERGED MIGRATION v8.5.10 â•‘';
  RAISE NOTICE 'â•‘     Part 2/3: Functions + Triggers    â•‘';
  RAISE NOTICE 'â•‘     Section 1/2: ×¡×¢×™×¤×™× 7-10         â•‘';
  RAISE NOTICE 'â•‘     ğŸ”¥ WITH SNAPTRADE INTEGRATION!    â•‘';
  RAISE NOTICE 'â•‘     ğŸ”’ ALL BUGS FIXED!                â•‘';
  RAISE NOTICE 'â•‘     âŒ NO AFFILIATE FEATURES          â•‘';
  RAISE NOTICE 'â•‘     âœ… v9.4.2-SYNCED FIXES APPLIED    â•‘';
  RAISE NOTICE 'â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•';
  RAISE NOTICE '';
END $$;

-- ===============================================
-- SECTION 7: SUBSCRIPTION FUNCTIONS
-- ===============================================

DO $$
BEGIN
  RAISE NOTICE '[7/15] Creating subscription functions...';
END $$;

-- ğŸ”§ Drop old function first to avoid type conflicts
DROP FUNCTION IF EXISTS public.get_user_subscription_status(UUID) CASCADE;

-- âœ… Get User Subscription Status (WITH PORTFOLIO FIELDS)
CREATE OR REPLACE FUNCTION public.get_user_subscription_status(user_id_param UUID)
RETURNS TABLE (
  remaining INT,
  used INT,
  max_trades INT,
  plan TEXT,
  reset_date TEXT,
  account_type TEXT,
  subscription_interval TEXT,
  subscription_status TEXT,
  subscription_expires_at TIMESTAMPTZ,
  role TEXT,
  initial_portfolio NUMERIC,
  current_portfolio NUMERIC
) 
LANGUAGE plpgsql
SECURITY DEFINER
STABLE
SET search_path = public
AS $$
DECLARE
  v_profile RECORD;
  v_trades_used INT;
  v_reset_date DATE;
BEGIN
  -- Get profile data (INCLUDING PORTFOLIO FIELDS)
  SELECT 
    p.account_type,
    p.max_trades,
    p.subscription_interval,
    p.subscription_status,
    p.subscription_expires_at,
    COALESCE(p.billing_cycle_start, CURRENT_DATE) as billing_cycle_start,
    COALESCE(p.role, 'user') as role,
    COALESCE(p.current_month_trades_count, 0) as monthly_count,
    COALESCE(p.trade_count, 0) as lifetime_count,
    COALESCE(p.initial_portfolio, 10000) as initial_portfolio,
    COALESCE(p.current_portfolio, p.initial_portfolio, 10000) as current_portfolio
  INTO v_profile
  FROM public.profiles p
  WHERE p.id = user_id_param;
  
  -- If profile doesn't exist, return safe defaults
  IF NOT FOUND THEN
    RETURN QUERY SELECT 
      10::INT,                    -- remaining
      0::INT,                     -- used
      10::INT,                    -- max_trades
      'Free Plan'::TEXT,          -- plan
      NULL::TEXT,                 -- reset_date (FREE has no reset)
      'free'::TEXT,               -- account_type
      NULL::TEXT,                 -- subscription_interval
      'active'::TEXT,             -- subscription_status
      NULL::TIMESTAMPTZ,          -- subscription_expires_at
      'user'::TEXT,               -- role
      10000::NUMERIC,             -- initial_portfolio
      10000::NUMERIC;             -- current_portfolio
    RETURN;
  END IF;
  
  -- Calculate reset date (next month for BASIC/TRIAL/PREMIUM only)
  IF v_profile.account_type IN ('basic', 'trial', 'premium') THEN
    v_reset_date := (DATE_TRUNC('month', v_profile.billing_cycle_start) + INTERVAL '1 month')::DATE;
  ELSE
    -- FREE users don't have reset date
    v_reset_date := NULL;
  END IF;
  
  -- Determine which counter to use
  IF v_profile.account_type = 'free' THEN
    v_trades_used := v_profile.lifetime_count;
  ELSE
    v_trades_used := v_profile.monthly_count;
  END IF;
  
  -- Handle unlimited users (admin/premium/vip)
  IF v_profile.role IN ('admin', 'super_admin') OR 
     v_profile.account_type IN ('premium', 'admin', 'vip') THEN
    RETURN QUERY SELECT
      999999::INT,                                    -- remaining (unlimited)
      v_trades_used::INT,                             -- used
      999999::INT,                                    -- max_trades
      CASE v_profile.account_type
        WHEN 'premium' THEN 'Premium Plan'
        WHEN 'admin' THEN 'Admin'
        WHEN 'vip' THEN 'VIP'
        ELSE 'Premium Plan'
      END::TEXT,                                      -- plan
      v_reset_date::TEXT,                             -- reset_date
      v_profile.account_type::TEXT,                   -- account_type
      v_profile.subscription_interval::TEXT,          -- subscription_interval
      v_profile.subscription_status::TEXT,            -- subscription_status
      v_profile.subscription_expires_at::TIMESTAMPTZ, -- subscription_expires_at
      v_profile.role::TEXT,                           -- role
      v_profile.initial_portfolio::NUMERIC,           -- initial_portfolio
      v_profile.current_portfolio::NUMERIC;           -- current_portfolio
    RETURN;
  END IF;
  
  -- Regular user result
  RETURN QUERY SELECT
    GREATEST(0, v_profile.max_trades - v_trades_used)::INT, -- remaining
    v_trades_used::INT,                                     -- used
    v_profile.max_trades::INT,                              -- max_trades
    CASE v_profile.account_type
      WHEN 'free' THEN 'Free Plan'
      WHEN 'basic' THEN 'Basic Plan'
      WHEN 'premium' THEN 'Premium Plan'
      WHEN 'trial' THEN 'Trial'
      ELSE 'Free Plan'
    END::TEXT,                                              -- plan
    v_reset_date::TEXT,                                     -- reset_date
    v_profile.account_type::TEXT,                           -- account_type
    v_profile.subscription_interval::TEXT,                  -- subscription_interval
    v_profile.subscription_status::TEXT,                    -- subscription_status
    v_profile.subscription_expires_at::TIMESTAMPTZ,         -- subscription_expires_at
    v_profile.role::TEXT,                                   -- role
    v_profile.initial_portfolio::NUMERIC,                   -- initial_portfolio
    v_profile.current_portfolio::NUMERIC;                   -- current_portfolio
END;
$$;

COMMENT ON FUNCTION public.get_user_subscription_status IS 
'v8.5.10: Returns subscription status WITH portfolio fields. FREE uses lifetime count, BASIC/TRIAL use monthly count';

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- âœ… v9.4.2-SYNCED: check_subscription_status (FIXED!)
-- Uses subscription_expires_at (NOT subscription_end_date)
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
DROP FUNCTION IF EXISTS public.check_subscription_status(UUID) CASCADE;

CREATE OR REPLACE FUNCTION public.check_subscription_status(p_user_id UUID)
RETURNS TABLE (
  is_active BOOLEAN,
  account_type TEXT,
  days_remaining INTEGER,
  should_downgrade BOOLEAN,
  subscription_status TEXT
)
LANGUAGE plpgsql
SECURITY DEFINER
STABLE
AS $$
DECLARE
  v_profile RECORD;
BEGIN
  SELECT 
    p.account_type,
    p.subscription_expires_at,  -- âœ… FIXED: was subscription_end_date
    p.subscription_status,
    p.subscription_cancel_at_period_end
  INTO v_profile
  FROM public.profiles p
  WHERE p.id = p_user_id;
  
  IF NOT FOUND THEN
    RETURN QUERY SELECT FALSE, 'free'::TEXT, 0, FALSE, 'none'::TEXT;
    RETURN;
  END IF;
  
  RETURN QUERY SELECT
    v_profile.account_type != 'free',
    v_profile.account_type,
    CASE 
      WHEN v_profile.subscription_expires_at IS NOT NULL 
      THEN GREATEST(0, EXTRACT(DAY FROM (v_profile.subscription_expires_at - NOW()))::INTEGER)
      ELSE NULL::INTEGER
    END,
    (v_profile.subscription_expires_at IS NOT NULL 
      AND v_profile.subscription_expires_at < NOW()
      AND v_profile.account_type != 'free'),
    COALESCE(v_profile.subscription_status, 'none')::TEXT;
END;
$$;

COMMENT ON FUNCTION public.check_subscription_status IS 
'v9.4.2-SYNCED: Uses subscription_expires_at (not subscription_end_date)';

-- âœ… Check Expired Subscriptions
CREATE OR REPLACE FUNCTION public.check_expired_subscriptions()
RETURNS TABLE(user_id UUID, old_plan TEXT, email TEXT) 
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  RETURN QUERY
  WITH expired_users AS (
    SELECT DISTINCT sp.user_id
    FROM public.subscription_periods sp
    WHERE sp.period_end < NOW()
      AND sp.auto_renew = FALSE
      AND NOT EXISTS (
        SELECT 1 FROM public.subscription_periods sp2
        WHERE sp2.user_id = sp.user_id AND sp2.period_end > NOW()
      )
  )
  UPDATE public.profiles p
  SET 
    account_type = 'free',
    max_trades = 10,
    subscription_status = 'expired',
    subscription_interval = NULL,
    updated_at = NOW()
  FROM expired_users eu
  WHERE p.id = eu.user_id 
    AND p.role NOT IN ('admin', 'super_admin')
  RETURNING p.id, p.account_type, p.email;
END;
$$;

COMMENT ON FUNCTION public.check_expired_subscriptions IS 
'v8.5.10: Checks and downgrades expired subscriptions to free plan';

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- âœ… v9.4.2-SYNCED: cancel_subscription (WITH subscription_cancel_at_period_end)
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
DROP FUNCTION IF EXISTS public.cancel_subscription(UUID, TEXT, BOOLEAN) CASCADE;

CREATE OR REPLACE FUNCTION public.cancel_subscription(
  p_user_id UUID,
  p_reason TEXT DEFAULT NULL,
  p_immediate BOOLEAN DEFAULT FALSE
)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_profile RECORD;
  v_effective_date TIMESTAMPTZ;
  v_days_remaining INTEGER;
BEGIN
  SELECT * INTO v_profile
  FROM public.profiles
  WHERE id = p_user_id;
  
  IF NOT FOUND THEN
    RETURN jsonb_build_object('success', false, 'error', 'User not found');
  END IF;
  
  IF v_profile.account_type = 'free' THEN
    RETURN jsonb_build_object('success', false, 'error', 'No active subscription');
  END IF;
  
  IF p_immediate THEN
    v_effective_date := NOW();
    
    UPDATE public.profiles
    SET 
      previous_account_type = account_type,
      account_type = 'free',
      max_trades = 10,
      subscription_status = 'expired',
      subscription_interval = NULL,
      payment_provider = NULL,
      subscription_expires_at = NOW(),
      subscription_cancel_at_period_end = FALSE,  -- âœ… NEW!
      cancellation_reason = p_reason,
      cancellation_requested_at = NOW(),
      cancellation_effective_date = NOW(),
      updated_at = NOW()
    WHERE id = p_user_id;
  ELSE
    -- Graceful cancellation - cancel at period end
    v_effective_date := COALESCE(v_profile.subscription_expires_at, NOW());
    
    UPDATE public.profiles
    SET 
      subscription_status = 'cancelled',
      subscription_cancel_at_period_end = TRUE,  -- âœ… NEW!
      cancellation_reason = p_reason,
      cancellation_requested_at = NOW(),
      cancellation_effective_date = v_effective_date,
      updated_at = NOW()
    WHERE id = p_user_id;
  END IF;
  
  -- Log to subscription_changes
  INSERT INTO public.subscription_changes (
    user_id, change_type, from_plan, to_plan, effective_date, reason
  ) VALUES (
    p_user_id, 'cancel', v_profile.account_type, 'free', v_effective_date, p_reason
  );
  
  v_days_remaining := GREATEST(0, EXTRACT(DAY FROM (v_effective_date - NOW()))::INTEGER);
  
  RETURN jsonb_build_object(
    'success', true,
    'message', CASE 
      WHEN p_immediate THEN 'Subscription cancelled immediately'
      ELSE format('Subscription will cancel on %s', v_effective_date::DATE)
    END,
    'data', jsonb_build_object(
      'effective_date', v_effective_date,
      'days_remaining', v_days_remaining,
      'immediate', p_immediate
    )
  );
END;
$$;

COMMENT ON FUNCTION public.cancel_subscription IS 
'v9.4.2-SYNCED: Cancel subscription with subscription_cancel_at_period_end support';

-- âœ… Reset Monthly Trade Counts (ONLY FOR BASIC/TRIAL/PREMIUM)
DROP FUNCTION IF EXISTS public.reset_monthly_trade_counts() CASCADE;

CREATE OR REPLACE FUNCTION public.reset_monthly_trade_counts()
RETURNS INTEGER
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  reset_count INTEGER;
BEGIN
  WITH reset_users AS (
    UPDATE public.profiles
    SET 
      current_month_trades_count = 0,
      billing_cycle_start = CURRENT_DATE,
      updated_at = NOW()
    WHERE billing_cycle_start < CURRENT_DATE - INTERVAL '1 month'
      AND account_type IN ('basic', 'trial', 'premium')  -- âœ… Only reset paid plans
    RETURNING id
  )
  SELECT COUNT(*) INTO reset_count FROM reset_users;
  
  RETURN reset_count;
END;
$$;

COMMENT ON FUNCTION public.reset_monthly_trade_counts IS 
'v8.5.10: CRON JOB - Resets monthly counters for BASIC/TRIAL/PREMIUM only. FREE keeps lifetime count.';

GRANT EXECUTE ON FUNCTION public.reset_monthly_trade_counts() TO service_role;

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- âœ… v9.4.2-SYNCED: process_expired_subscriptions (FIXED!)
-- Uses subscription_expires_at (NOT subscription_end_date)
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
DROP FUNCTION IF EXISTS public.process_expired_subscriptions() CASCADE;

CREATE OR REPLACE FUNCTION public.process_expired_subscriptions()
RETURNS TABLE(
  downgraded_count INTEGER,
  downgraded_emails TEXT[]
)
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_count INTEGER := 0;
  v_emails TEXT[] := ARRAY[]::TEXT[];
  v_user RECORD;
BEGIN
  FOR v_user IN
    SELECT 
      p.id,
      p.email,
      p.account_type
    FROM public.profiles p
    WHERE p.subscription_expires_at < NOW()  -- âœ… FIXED: was subscription_end_date
      AND p.account_type IN ('basic', 'premium', 'trial')
      AND p.subscription_status IN ('active', 'cancelled')
      AND p.role NOT IN ('admin', 'super_admin')
    ORDER BY p.subscription_expires_at ASC
    LIMIT 1000
  LOOP
    UPDATE public.profiles
    SET 
      previous_account_type = v_user.account_type,
      account_type = 'free',
      max_trades = 10,
      subscription_status = 'expired',
      subscription_interval = NULL,
      subscription_cancel_at_period_end = FALSE,
      payment_provider = NULL,
      updated_at = NOW()
    WHERE id = v_user.id;
    
    -- Log the change
    INSERT INTO public.subscription_changes (
      user_id, change_type, from_plan, to_plan, effective_date
    ) VALUES (
      v_user.id, 'expire', v_user.account_type, 'free', NOW()
    );
    
    v_emails := array_append(v_emails, v_user.email);
    v_count := v_count + 1;
  END LOOP;
  
  RETURN QUERY SELECT v_count, v_emails;
END;
$$;

COMMENT ON FUNCTION public.process_expired_subscriptions IS 
'v9.4.2-SYNCED: CRON job - downgrades expired subscriptions. Uses subscription_expires_at.';

GRANT EXECUTE ON FUNCTION public.process_expired_subscriptions() TO service_role;

-- âœ… Check Usage Warning
CREATE OR REPLACE FUNCTION public.check_usage_warning(target_user_id UUID)
RETURNS BOOLEAN
LANGUAGE plpgsql
SECURITY DEFINER
STABLE
SET search_path = public
AS $$
DECLARE
  profile_record RECORD;
  usage_percentage NUMERIC;
  trades_used INTEGER;
BEGIN
  SELECT 
    max_trades,
    current_month_trades_count,
    trade_count,
    account_type,
    last_warning_shown_at
  INTO profile_record
  FROM public.profiles
  WHERE id = target_user_id;
  
  -- Premium users never get warnings
  IF profile_record.account_type = 'premium' THEN
    RETURN FALSE;
  END IF;
  
  -- Handle NULL/zero max_trades
  IF profile_record.max_trades IS NULL OR profile_record.max_trades = 0 THEN
    RETURN FALSE;
  END IF;
  
  -- FREE uses lifetime count, others use monthly
  IF profile_record.account_type = 'free' THEN
    trades_used := COALESCE(profile_record.trade_count, 0);
  ELSE
    trades_used := COALESCE(profile_record.current_month_trades_count, 0);
  END IF;
  
  usage_percentage := (trades_used::NUMERIC / profile_record.max_trades::NUMERIC) * 100;
  
  -- Show warning at 80%, max once per 24 hours
  IF usage_percentage >= 80 AND 
     (profile_record.last_warning_shown_at IS NULL OR 
      profile_record.last_warning_shown_at < NOW() - INTERVAL '24 hours') THEN
    RETURN TRUE;
  END IF;
  
  RETURN FALSE;
END;
$$;

COMMENT ON FUNCTION public.check_usage_warning IS 
'v8.5.10: Returns TRUE if user should see 80% usage warning. Max once per 24h.';

-- âœ… Mark Warning Shown
CREATE OR REPLACE FUNCTION public.mark_warning_shown(target_user_id UUID)
RETURNS VOID
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  UPDATE public.profiles
  SET 
    last_warning_shown_at = NOW(),
    updated_at = NOW()
  WHERE id = target_user_id;
END;
$$;

COMMENT ON FUNCTION public.mark_warning_shown IS 
'v8.5.10: Updates last_warning_shown_at to prevent warning spam.';

-- ===============================================
-- SECTION 8: PORTFOLIO & STATISTICS
-- ===============================================

DO $$
BEGIN
  RAISE NOTICE '[8/15] Creating portfolio functions...';
END $$;

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- ğŸ”’ SECURE VERSION: get_portfolio_stats (v8.5.10)
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
DROP FUNCTION IF EXISTS public.get_portfolio_stats(UUID) CASCADE;

CREATE OR REPLACE FUNCTION public.get_portfolio_stats(p_user_id UUID)
RETURNS TABLE (
  initial_portfolio NUMERIC,
  current_portfolio NUMERIC,
  total_pnl NUMERIC,
  growth NUMERIC,
  trade_count BIGINT
) 
LANGUAGE plpgsql
SECURITY DEFINER
STABLE
SET search_path = public
AS $$
DECLARE
  v_initial_portfolio NUMERIC;
  v_total_pnl NUMERIC;
  v_trade_count BIGINT;
  v_current_portfolio NUMERIC;
  v_growth NUMERIC;
  v_is_admin BOOLEAN;
  v_caller_id UUID;
BEGIN
  -- Get caller ID
  v_caller_id := auth.uid();
  
  -- ğŸ”’ Check permissions
  SELECT role IN ('admin', 'super_admin') AND is_banned = FALSE
  INTO v_is_admin
  FROM profiles
  WHERE id = v_caller_id;

  -- Users can only view their own stats unless admin
  IF p_user_id != v_caller_id AND NOT COALESCE(v_is_admin, FALSE) THEN
    RAISE EXCEPTION 'Access denied: You can only view your own portfolio stats';
  END IF;

  -- ğŸ”’ Admin enables admin mode for viewing other users
  IF COALESCE(v_is_admin, FALSE) AND p_user_id != v_caller_id THEN
    PERFORM set_config('app.admin_mode', 'true', true);
  END IF;

  -- Get initial portfolio
  SELECT COALESCE(profiles.initial_portfolio, 10000)
  INTO v_initial_portfolio
  FROM profiles
  WHERE profiles.id = p_user_id;

  -- Default if user not found
  IF v_initial_portfolio IS NULL THEN
    v_initial_portfolio := 10000;
  END IF;

  -- Calculate PnL from closed trades only
  SELECT 
    COALESCE(SUM(trades.pnl), 0),
    COUNT(*)
  INTO v_total_pnl, v_trade_count
  FROM trades
  WHERE trades.user_id = p_user_id
    AND trades.exit_price IS NOT NULL
    AND trades.deleted_at IS NULL;

  -- Calculate current portfolio value
  v_current_portfolio := v_initial_portfolio + v_total_pnl;
  
  -- Calculate growth percentage
  IF v_initial_portfolio > 0 THEN
    v_growth := ((v_current_portfolio - v_initial_portfolio) / v_initial_portfolio) * 100;
  ELSE
    v_growth := 0;
  END IF;

  -- ğŸ”’ Disable admin mode
  IF COALESCE(v_is_admin, FALSE) THEN
    PERFORM set_config('app.admin_mode', 'false', true);
  END IF;

  RETURN QUERY SELECT 
    v_initial_portfolio,
    v_current_portfolio,
    v_total_pnl,
    v_growth,
    v_trade_count;
END;
$$;

COMMENT ON FUNCTION public.get_portfolio_stats IS 
'v8.5.10-SECURE: Get portfolio stats with mandatory access control. Users can only view their own stats unless admin.';

-- ===============================================
-- SECTION 9: TRADINGVIEW WEBHOOKS
-- ===============================================

DO $$
BEGIN
  RAISE NOTICE '[9/15] Creating TradingView webhook functions...';
END $$;

-- âœ… Close TradingView Trade (ATOMIC)
CREATE OR REPLACE FUNCTION public.close_tradingview_trade(
  p_user_id UUID,
  p_symbol TEXT,
  p_side TEXT,
  p_exit_price NUMERIC
)
RETURNS UUID
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_trade_id UUID;
  v_entry_price NUMERIC;
  v_outcome TEXT;
BEGIN
  -- Find the most recent open trade matching criteria (with lock)
  SELECT id, entry_price
  INTO v_trade_id, v_entry_price
  FROM public.trades
  WHERE user_id = p_user_id
    AND symbol = p_symbol
    AND side = p_side
    AND exit_price IS NULL
    AND deleted_at IS NULL
  ORDER BY open_at DESC
  LIMIT 1
  FOR UPDATE SKIP LOCKED;

  IF v_trade_id IS NULL THEN
    RAISE EXCEPTION 'No open trade found for symbol % side %', p_symbol, p_side;
  END IF;

  -- Determine outcome
  IF (p_exit_price > v_entry_price AND p_side = 'LONG') OR
     (p_exit_price < v_entry_price AND p_side = 'SHORT') THEN
    v_outcome := 'WIN';
  ELSIF (p_exit_price < v_entry_price AND p_side = 'LONG') OR
        (p_exit_price > v_entry_price AND p_side = 'SHORT') THEN
    v_outcome := 'LOSS';
  ELSE
    v_outcome := 'BE';
  END IF;

  -- Update the trade (unified trigger will calculate PnL)
  UPDATE public.trades
  SET 
    exit_price = p_exit_price,
    outcome = v_outcome,
    close_at = NOW(),
    updated_at = NOW()
  WHERE id = v_trade_id;

  RETURN v_trade_id;
END;
$$;

COMMENT ON FUNCTION public.close_tradingview_trade IS 
'v8.5.10: Atomically closes a TradingView trade with proper locking. Trigger calculates PnL.';

GRANT EXECUTE ON FUNCTION public.close_tradingview_trade(UUID, TEXT, TEXT, NUMERIC) TO authenticated;
GRANT EXECUTE ON FUNCTION public.close_tradingview_trade(UUID, TEXT, TEXT, NUMERIC) TO service_role;

-- âœ… Generate TradingView Webhook Secret
CREATE OR REPLACE FUNCTION public.generate_tradingview_webhook()
RETURNS TEXT 
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  secret TEXT;
  v_user_id UUID;
BEGIN
  v_user_id := auth.uid();
  
  IF v_user_id IS NULL THEN
    RAISE EXCEPTION 'Not authenticated';
  END IF;
  
  -- Generate secure random secret (64 hex chars)
  secret := encode(gen_random_bytes(32), 'hex');
  
  -- Upsert into user_settings
  INSERT INTO public.user_settings (user_id, tradingview_webhook_secret, updated_at)
  VALUES (v_user_id, secret, NOW())
  ON CONFLICT (user_id) 
  DO UPDATE SET 
    tradingview_webhook_secret = EXCLUDED.tradingview_webhook_secret,
    updated_at = NOW();
  
  RETURN secret;
END;
$$;

COMMENT ON FUNCTION public.generate_tradingview_webhook IS 
'v8.5.10: Generates a secure 64-char hex webhook secret for TradingView integration.';

-- ===============================================
-- SECTION 10: ADMIN FUNCTIONS
-- ===============================================

DO $$
BEGIN
  RAISE NOTICE '[10/15] Creating admin functions...';
END $$;

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- âœ… v9.4.2-SYNCED: log_admin_action (SINGLE VERSION ONLY!)
-- Removed all duplicate versions
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
DROP FUNCTION IF EXISTS public.log_admin_action(TEXT, UUID, TEXT, UUID, JSONB) CASCADE;
DROP FUNCTION IF EXISTS public.log_admin_action(TEXT, TEXT, UUID, JSONB) CASCADE;
DROP FUNCTION IF EXISTS public.log_admin_action CASCADE;

-- âœ… Single version with 4 parameters
CREATE OR REPLACE FUNCTION public.log_admin_action(
  p_action_type TEXT,
  p_resource_type TEXT DEFAULT NULL,
  p_resource_id UUID DEFAULT NULL,
  p_details JSONB DEFAULT '{}'::jsonb
)
RETURNS UUID
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_action_id UUID;
  v_admin_id UUID;
BEGIN
  v_admin_id := auth.uid();
  
  IF v_admin_id IS NULL THEN
    RAISE EXCEPTION 'Not authenticated';
  END IF;
  
  INSERT INTO public.admin_actions (
    action_type,
    admin_id,
    resource_type,
    resource_id,
    details,
    created_at
  ) VALUES (
    p_action_type,
    v_admin_id,
    p_resource_type,
    p_resource_id,
    COALESCE(p_details, '{}'::jsonb),
    NOW()
  )
  RETURNING id INTO v_action_id;
  
  RETURN v_action_id;
END;
$$;

COMMENT ON FUNCTION public.log_admin_action IS 
'v9.4.2-SYNCED: Single version - logs admin actions with 4 parameters';

GRANT EXECUTE ON FUNCTION public.log_admin_action(TEXT, TEXT, UUID, JSONB) TO authenticated;

-- âœ… Admin Toggle User Ban
CREATE OR REPLACE FUNCTION public.admin_toggle_user_ban(
  p_user_id UUID,
  p_ban_reason TEXT DEFAULT NULL
)
RETURNS VOID 
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  current_ban_status BOOLEAN;
  v_admin_id UUID;
BEGIN
  v_admin_id := auth.uid();
  
  -- Check super admin permission
  IF NOT is_super_admin() THEN
    RAISE EXCEPTION 'Unauthorized - Super Admin access required';
  END IF;

  -- Get current ban status
  SELECT is_banned INTO current_ban_status
  FROM public.profiles
  WHERE id = p_user_id;
  
  IF current_ban_status IS NULL THEN
    RAISE EXCEPTION 'User not found: %', p_user_id;
  END IF;

  -- Toggle ban status
  UPDATE public.profiles
  SET 
    is_banned = NOT current_ban_status,
    ban_reason = CASE WHEN NOT current_ban_status THEN p_ban_reason ELSE NULL END,
    banned_at = CASE WHEN NOT current_ban_status THEN NOW() ELSE NULL END,
    banned_by = CASE WHEN NOT current_ban_status THEN v_admin_id ELSE NULL END,
    updated_at = NOW()
  WHERE id = p_user_id;

  -- Log admin action
  PERFORM log_admin_action(
    CASE WHEN NOT current_ban_status THEN 'BAN_USER' ELSE 'UNBAN_USER' END,
    'user', 
    p_user_id, 
    jsonb_build_object(
      'reason', p_ban_reason,
      'previous_status', current_ban_status
    )
  );
END;
$$;

COMMENT ON FUNCTION public.admin_toggle_user_ban IS 
'v8.5.10: Toggles user ban status. Super admin only.';

-- âœ… Admin Update Subscription (RETURNS JSONB, uses get_trade_limit)
-- âœ… v9.4.2-SYNCED: Uses subscription_expires_at (NOT subscription_end_date)
DROP FUNCTION IF EXISTS public.admin_update_subscription(UUID, TEXT, TEXT, TEXT, TIMESTAMPTZ) CASCADE;

CREATE OR REPLACE FUNCTION public.admin_update_subscription(
  p_user_id UUID,
  p_account_type TEXT,
  p_subscription_interval TEXT,
  p_subscription_status TEXT,
  p_subscription_expires_at TIMESTAMPTZ
)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_admin_id UUID;
  v_admin_role TEXT;
  v_max_trades INTEGER;
  v_old_account_type TEXT;
BEGIN
  -- Verify authentication
  v_admin_id := auth.uid();
  
  IF v_admin_id IS NULL THEN
    RETURN jsonb_build_object('success', false, 'error', 'Not authenticated');
  END IF;
  
  -- Verify admin role
  SELECT role INTO v_admin_role FROM public.profiles WHERE id = v_admin_id;
  
  IF v_admin_role NOT IN ('admin', 'super_admin') THEN
    RETURN jsonb_build_object('success', false, 'error', 'Insufficient permissions');
  END IF;
  
  -- Validate account type
  IF p_account_type NOT IN ('free', 'basic', 'premium', 'trial') THEN
    RETURN jsonb_build_object('success', false, 'error', 'Invalid account type: ' || p_account_type);
  END IF;

  -- Validate subscription interval (only required for non-free)
  IF p_account_type != 'free' AND p_subscription_interval NOT IN ('monthly', 'yearly') THEN
    RETURN jsonb_build_object('success', false, 'error', 'Invalid subscription interval: ' || p_subscription_interval);
  END IF;

  -- Validate subscription status
  IF p_subscription_status NOT IN ('trial', 'active', 'expired', 'cancelled') THEN
    RETURN jsonb_build_object('success', false, 'error', 'Invalid subscription status: ' || p_subscription_status);
  END IF;
  
  -- Get old account type for logging
  SELECT account_type INTO v_old_account_type 
  FROM public.profiles WHERE id = p_user_id;
  
  IF v_old_account_type IS NULL THEN
    RETURN jsonb_build_object('success', false, 'error', 'User not found');
  END IF;
  
  -- Use get_trade_limit() function if it exists, otherwise fallback
  BEGIN
    v_max_trades := public.get_trade_limit(p_account_type);
  EXCEPTION WHEN undefined_function THEN
    -- Fallback if function doesn't exist
    v_max_trades := CASE p_account_type
      WHEN 'free' THEN 10
      WHEN 'basic' THEN 25
      WHEN 'premium' THEN 999999
      WHEN 'trial' THEN 25
      ELSE 10
    END;
  END;
  
  -- Update profile (uses subscription_expires_at - FIXED!)
  UPDATE public.profiles
  SET 
    account_type = p_account_type,
    subscription_interval = CASE 
      WHEN p_account_type = 'free' THEN NULL 
      ELSE p_subscription_interval 
    END,
    subscription_status = p_subscription_status,
    subscription_expires_at = p_subscription_expires_at,  -- âœ… CORRECT column name
    max_trades = v_max_trades,
    -- Reset counters when upgrading from free
    current_month_trades_count = CASE 
      WHEN v_old_account_type = 'free' AND p_account_type IN ('basic', 'trial', 'premium') THEN 0 
      ELSE current_month_trades_count 
    END,
    billing_cycle_start = CASE 
      WHEN v_old_account_type = 'free' AND p_account_type IN ('basic', 'trial', 'premium') THEN CURRENT_DATE 
      ELSE billing_cycle_start 
    END,
    subscription_started_at = CASE
      WHEN v_old_account_type = 'free' AND p_account_type IN ('basic', 'trial', 'premium') THEN NOW()
      ELSE subscription_started_at
    END,
    updated_at = NOW()
  WHERE id = p_user_id;
  
  -- Log admin action
  BEGIN
    PERFORM log_admin_action(
      'UPDATE_SUBSCRIPTION',
      'subscription', 
      p_user_id,
      jsonb_build_object(
        'old_account_type', v_old_account_type,
        'new_account_type', p_account_type,
        'subscription_interval', p_subscription_interval,
        'subscription_status', p_subscription_status,
        'expires_at', p_subscription_expires_at,
        'max_trades', v_max_trades
      )
    );
  EXCEPTION 
    WHEN OTHERS THEN
      -- Don't fail the update if logging fails
      RAISE WARNING 'Failed to log admin action: %', SQLERRM;
  END;
  
  RETURN jsonb_build_object(
    'success', true, 
    'message', 'Subscription updated successfully',
    'data', jsonb_build_object(
      'user_id', p_user_id,
      'old_account_type', v_old_account_type,
      'new_account_type', p_account_type,
      'max_trades', v_max_trades,
      'expires_at', p_subscription_expires_at
    )
  );
  
EXCEPTION 
  WHEN OTHERS THEN
    RETURN jsonb_build_object('success', false, 'error', SQLERRM);
END;
$$;

COMMENT ON FUNCTION public.admin_update_subscription IS 
'v9.4.2-SYNCED: Returns JSONB with success/error. Uses subscription_expires_at. Uses get_trade_limit() with fallback.';

GRANT EXECUTE ON FUNCTION public.admin_update_subscription(UUID, TEXT, TEXT, TEXT, TIMESTAMPTZ) TO authenticated;

-- âœ… Admin Reset Trade Count
CREATE OR REPLACE FUNCTION public.admin_reset_trade_count(target_user_id UUID)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_admin_id UUID;
  v_old_count INTEGER;
  v_user_email TEXT;
BEGIN
  v_admin_id := auth.uid();
  
  IF NOT public.is_admin() THEN
    RETURN jsonb_build_object('success', false, 'error', 'Unauthorized: Admin access required');
  END IF;

  -- Get old count and email for logging
  SELECT current_month_trades_count, email 
  INTO v_old_count, v_user_email
  FROM public.profiles 
  WHERE id = target_user_id;
  
  IF v_old_count IS NULL THEN
    RETURN jsonb_build_object('success', false, 'error', 'User not found');
  END IF;

  -- Reset the counter
  UPDATE public.profiles
  SET 
    current_month_trades_count = 0,
    billing_cycle_start = CURRENT_DATE,
    updated_at = NOW()
  WHERE id = target_user_id;
  
  -- Log admin action
  PERFORM public.log_admin_action(
    'RESET_TRADE_COUNT',
    'profile',
    target_user_id,
    jsonb_build_object(
      'old_count', v_old_count, 
      'reset_date', CURRENT_DATE,
      'user_email', v_user_email
    )
  );
  
  RETURN jsonb_build_object(
    'success', true,
    'message', 'Trade count reset successfully',
    'data', jsonb_build_object(
      'user_id', target_user_id,
      'user_email', v_user_email,
      'old_count', v_old_count,
      'new_count', 0
    )
  );
END;
$$;

COMMENT ON FUNCTION public.admin_reset_trade_count IS 
'v8.5.10: Resets monthly trade count for a user. Admin only. Logs action.';

-- ===============================================
-- ğŸ†• ADMIN SOFT DELETE USER FUNCTION
-- ===============================================

CREATE OR REPLACE FUNCTION public.admin_soft_delete_user(
  p_user_id UUID,
  p_reason TEXT DEFAULT NULL
)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_user_email TEXT;
  v_user_name TEXT;
  v_affected_trades INTEGER;
  v_affected_strategies INTEGER;
BEGIN
  IF NOT public.is_admin() THEN
    RAISE EXCEPTION 'Unauthorized - Admin access required';
  END IF;
  
  IF EXISTS(
    SELECT 1 FROM public.profiles 
    WHERE id = p_user_id AND role = 'super_admin'
  ) THEN
    RAISE EXCEPTION 'Cannot delete super admin users';
  END IF;
  
  SELECT email, display_name INTO v_user_email, v_user_name
  FROM public.profiles
  WHERE id = p_user_id;
  
  IF v_user_email IS NULL THEN
    RAISE EXCEPTION 'User not found: %', p_user_id;
  END IF;
  
  SELECT COUNT(*) INTO v_affected_trades
  FROM public.trades
  WHERE user_id = p_user_id AND deleted_at IS NULL;
  
  SELECT COUNT(*) INTO v_affected_strategies
  FROM public.strategies
  WHERE user_id = p_user_id AND deleted_at IS NULL;
  
  UPDATE public.profiles
  SET 
    deleted_at = NOW(),
    deleted_by = auth.uid(),
    is_banned = TRUE,
    ban_reason = COALESCE(p_reason, 'Admin deleted user'),
    banned_at = NOW(),
    banned_by = auth.uid(),
    updated_at = NOW()
  WHERE id = p_user_id;
  
  UPDATE public.trades
  SET 
    deleted_at = NOW(),
    deleted_by = auth.uid()
  WHERE user_id = p_user_id
    AND deleted_at IS NULL;
  
  UPDATE public.strategies
  SET deleted_at = NOW()
  WHERE user_id = p_user_id
    AND deleted_at IS NULL;
  
  PERFORM public.log_admin_action(
    'SOFT_DELETE_USER',
    'user',
    p_user_id,
    jsonb_build_object(
      'email', v_user_email,
      'display_name', v_user_name,
      'reason', p_reason,
      'affected_trades', v_affected_trades,
      'affected_strategies', v_affected_strategies,
      'deleted_by', auth.uid(),
      'deleted_at', NOW()
    )
  );
  
  RETURN jsonb_build_object(
    'success', TRUE,
    'message', 'User soft deleted successfully',
    'data', jsonb_build_object(
      'user_id', p_user_id,
      'email', v_user_email,
      'display_name', v_user_name,
      'affected_trades', v_affected_trades,
      'affected_strategies', v_affected_strategies,
      'can_restore', TRUE
    )
  );
  
EXCEPTION 
  WHEN OTHERS THEN
    RETURN jsonb_build_object(
      'success', FALSE,
      'error', SQLERRM
    );
END;
$$;

COMMENT ON FUNCTION public.admin_soft_delete_user IS 
'v9.4.2: Soft deletes a user and all their data. Admin only.';

GRANT EXECUTE ON FUNCTION public.admin_soft_delete_user(UUID, TEXT) TO authenticated;

-- âœ… Admin Get Limits Overview
-- ğŸ”§ DROP first to avoid return type conflicts
DROP FUNCTION IF EXISTS public.admin_get_limits_overview() CASCADE;

CREATE OR REPLACE FUNCTION public.admin_get_limits_overview()
RETURNS TABLE(
  user_id UUID,
  email TEXT,
  display_name TEXT,
  plan TEXT,
  lifetime_trades INTEGER,
  monthly_trades INTEGER,
  max_limit INTEGER,
  usage_percent NUMERIC,
  can_add BOOLEAN,
  last_trade_at TIMESTAMPTZ
)
LANGUAGE plpgsql
STABLE
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  IF NOT public.is_admin() THEN
    RAISE EXCEPTION 'Unauthorized: Admin access required';
  END IF;

  RETURN QUERY
  SELECT 
    p.id as user_id,
    p.email,
    p.display_name,
    p.account_type as plan,
    COALESCE(p.trade_count, 0)::INTEGER as lifetime_trades,
    COALESCE(p.current_month_trades_count, 0)::INTEGER as monthly_trades,
    COALESCE(p.max_trades, public.get_trade_limit(p.account_type))::INTEGER as max_limit,
    CASE 
      WHEN COALESCE(p.max_trades, 10) = 0 THEN 0
      WHEN p.account_type = 'free' THEN 
        ROUND((COALESCE(p.trade_count, 0)::NUMERIC / COALESCE(p.max_trades, 10)) * 100, 1)
      ELSE 
        ROUND((COALESCE(p.current_month_trades_count, 0)::NUMERIC / COALESCE(p.max_trades, 25)) * 100, 1)
    END as usage_percent,
    public.can_create_trade(p.id) as can_add,
    (SELECT MAX(t.open_at) FROM public.trades t WHERE t.user_id = p.id) as last_trade_at
  FROM public.profiles p
  WHERE p.deleted_at IS NULL
  ORDER BY 
    CASE p.account_type
      WHEN 'free' THEN p.trade_count
      ELSE p.current_month_trades_count
    END DESC
  LIMIT 100;
END;
$$;

COMMENT ON FUNCTION public.admin_get_limits_overview IS 
'v8.5.10: Returns overview of all users trade limits with usage percentage. Admin only.';

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- âœ… v9.4.2-SYNCED: search_ticker_symbols (SINGLE VERSION ONLY!)
-- Removed all duplicate versions
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
DROP FUNCTION IF EXISTS public.search_ticker_symbols(TEXT) CASCADE;
DROP FUNCTION IF EXISTS public.search_ticker_symbols(TEXT, INTEGER) CASCADE;
DROP FUNCTION IF EXISTS public.search_ticker_symbols(TEXT, TEXT) CASCADE;
DROP FUNCTION IF EXISTS public.search_ticker_symbols(TEXT, TEXT, INTEGER) CASCADE;

CREATE OR REPLACE FUNCTION public.search_ticker_symbols(
  p_query TEXT,
  p_asset_class TEXT DEFAULT NULL,
  p_limit INTEGER DEFAULT 20
)
RETURNS TABLE (
  symbol TEXT,
  name TEXT,
  asset_class TEXT,
  exchange TEXT,
  multiplier NUMERIC,
  popularity_rank INTEGER
)
LANGUAGE plpgsql
SECURITY DEFINER
STABLE
AS $$
BEGIN
  RETURN QUERY
  SELECT 
    t.symbol,
    t.name,
    t.asset_class,
    t.exchange,
    t.multiplier,
    t.popularity_rank
  FROM public.ticker_symbols t
  WHERE 
    t.is_active = TRUE
    AND (p_asset_class IS NULL OR t.asset_class = p_asset_class)
    AND (
      t.symbol ILIKE p_query || '%'
      OR t.name ILIKE '%' || p_query || '%'
    )
  ORDER BY 
    t.popularity_rank ASC,
    CASE WHEN t.symbol ILIKE p_query THEN 0 ELSE 1 END,
    t.symbol
  LIMIT LEAST(p_limit, 100);
END;
$$;

COMMENT ON FUNCTION public.search_ticker_symbols IS 
'v9.4.2-SYNCED: Single version with 3 params (query, asset_class, limit)';

GRANT EXECUTE ON FUNCTION public.search_ticker_symbols(TEXT, TEXT, INTEGER) TO authenticated, anon;

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- GRANT PERMISSIONS FOR SECTION 7-10
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

DO $$
BEGIN
  RAISE NOTICE 'ğŸ” Granting permissions for sections 7-10...';
END $$;

GRANT EXECUTE ON FUNCTION public.get_user_subscription_status(UUID) TO authenticated;
GRANT EXECUTE ON FUNCTION public.check_subscription_status(UUID) TO authenticated;
GRANT EXECUTE ON FUNCTION public.check_expired_subscriptions() TO authenticated;
GRANT EXECUTE ON FUNCTION public.cancel_subscription(UUID, TEXT, BOOLEAN) TO authenticated;
GRANT EXECUTE ON FUNCTION public.reset_monthly_trade_counts() TO authenticated;
GRANT EXECUTE ON FUNCTION public.process_expired_subscriptions() TO authenticated;
GRANT EXECUTE ON FUNCTION public.check_usage_warning(UUID) TO authenticated;
GRANT EXECUTE ON FUNCTION public.mark_warning_shown(UUID) TO authenticated;
GRANT EXECUTE ON FUNCTION public.get_portfolio_stats(UUID) TO authenticated;
GRANT EXECUTE ON FUNCTION public.generate_tradingview_webhook() TO authenticated;
GRANT EXECUTE ON FUNCTION public.admin_toggle_user_ban(UUID, TEXT) TO authenticated;
GRANT EXECUTE ON FUNCTION public.admin_reset_trade_count(UUID) TO authenticated;
GRANT EXECUTE ON FUNCTION public.admin_get_limits_overview() TO authenticated;

COMMIT;

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- END OF PART 1/2 - Sections 7-10 Complete
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

DO $$
BEGIN
  RAISE NOTICE '';
  RAISE NOTICE 'â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—';
  RAISE NOTICE 'â•‘  âœ… PART 1/2 COMPLETE! (v8.5.10)      â•‘';
  RAISE NOTICE 'â•‘     Sections 7-10 - ALL BUGS FIXED!   â•‘';
  RAISE NOTICE 'â•‘     ğŸ”’ SECURITY ENHANCED!              â•‘';
  RAISE NOTICE 'â•‘     âŒ NO AFFILIATE FEATURES           â•‘';
  RAISE NOTICE 'â•‘     âœ… v9.4.2-SYNCED FIXES APPLIED     â•‘';
  RAISE NOTICE 'â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•';
  RAISE NOTICE '';
  RAISE NOTICE 'ğŸ”§ v9.4.2 FIXES APPLIED:';
  RAISE NOTICE '   â€¢ subscription_end_date â†’ subscription_expires_at';
  RAISE NOTICE '   â€¢ Added subscription_cancel_at_period_end';
  RAISE NOTICE '   â€¢ Removed duplicate log_admin_action versions';
  RAISE NOTICE '   â€¢ Removed duplicate search_ticker_symbols versions';
  RAISE NOTICE '   â€¢ Fixed check_subscription_status';
  RAISE NOTICE '   â€¢ Fixed process_expired_subscriptions';
  RAISE NOTICE '   â€¢ Fixed cancel_subscription';
  RAISE NOTICE '';
END $$;
-- ===============================================
-- ğŸ”¥ FINOTAUR - PART 2/2 (Sections 11-15)
-- ===============================================
-- Version: MERGED-v8.5.10-SYNC (NO AFFILIATE)
-- Date: 2025-01-22
-- ğŸ”§ v9.4.2-SYNCED: All fixes from Part 1 applied
-- ===============================================

BEGIN;

DO $$
BEGIN
  RAISE NOTICE '';
  RAISE NOTICE 'â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—';
  RAISE NOTICE 'â•‘  ğŸ”¥ FINOTAUR MERGED MIGRATION v8.5.10 â•‘';
  RAISE NOTICE 'â•‘     Part 2/3: Functions + Triggers    â•‘';
  RAISE NOTICE 'â•‘     Section 2/2: ×¡×¢×™×¤×™× 11-15        â•‘';
  RAISE NOTICE 'â•‘     ğŸ”¥ WITH SNAPTRADE INTEGRATION!    â•‘';
  RAISE NOTICE 'â•‘     ğŸ”’ CRITICAL BUGS FIXED!           â•‘';
  RAISE NOTICE 'â•‘     âŒ NO AFFILIATE FEATURES          â•‘';
  RAISE NOTICE 'â•‘     âœ… v9.4.2-SYNCED FIXES APPLIED    â•‘';
  RAISE NOTICE 'â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•';
  RAISE NOTICE '';
END $$;

-- ===============================================
-- SECTION 11: ADMIN STATISTICS & ANALYTICS
-- ===============================================

DO $$
BEGIN
  RAISE NOTICE '[11/15] Creating admin statistics functions...';
END $$;

-- âœ… Get Platform Stats
CREATE OR REPLACE FUNCTION public.get_platform_stats()
RETURNS JSON 
LANGUAGE plpgsql
SECURITY DEFINER
STABLE
SET search_path = public
AS $$
DECLARE
  stats JSON;
  v_basic_monthly INTEGER;
  v_basic_yearly INTEGER;
  v_premium_monthly INTEGER;
  v_premium_yearly INTEGER;
  v_monthly_revenue NUMERIC;
  v_yearly_revenue NUMERIC;
BEGIN
  IF NOT is_admin() THEN
    RAISE EXCEPTION 'Unauthorized - Admin access required';
  END IF;

  -- Count subscribers by plan and interval
  SELECT COUNT(*) INTO v_basic_monthly
  FROM public.profiles 
  WHERE account_type = 'basic' AND subscription_interval = 'monthly';
  
  SELECT COUNT(*) INTO v_basic_yearly
  FROM public.profiles 
  WHERE account_type = 'basic' AND subscription_interval = 'yearly';
  
  SELECT COUNT(*) INTO v_premium_monthly
  FROM public.profiles 
  WHERE account_type = 'premium' AND subscription_interval = 'monthly';
  
  SELECT COUNT(*) INTO v_premium_yearly
  FROM public.profiles 
  WHERE account_type = 'premium' AND subscription_interval = 'yearly';

  -- Calculate revenue (prices: basic monthly=$19.99, yearly=$149; premium monthly=$39.99, yearly=$299)
  v_monthly_revenue := 
    (v_basic_monthly * 19.99) + 
    (v_basic_yearly * 12.42) +   -- 149/12 = 12.42
    (v_premium_monthly * 39.99) + 
    (v_premium_yearly * 24.92);  -- 299/12 = 24.92
    
  v_yearly_revenue := v_monthly_revenue * 12;

  -- Build comprehensive stats object
  SELECT json_build_object(
    'total_users', (SELECT COUNT(*) FROM public.profiles),
    'active_users', (SELECT COUNT(*) FROM public.profiles WHERE last_login_at > NOW() - INTERVAL '30 days'),
    'free_users', (SELECT COUNT(*) FROM public.profiles WHERE account_type = 'free'),
    'basic_users', (SELECT COUNT(*) FROM public.profiles WHERE account_type = 'basic'),
    'premium_users', (SELECT COUNT(*) FROM public.profiles WHERE account_type = 'premium'),
    'trial_users', (SELECT COUNT(*) FROM public.profiles WHERE subscription_status = 'trial'),
    'banned_users', (SELECT COUNT(*) FROM public.profiles WHERE is_banned = true),
    'basic_monthly_subscribers', v_basic_monthly,
    'basic_yearly_subscribers', v_basic_yearly,
    'premium_monthly_subscribers', v_premium_monthly,
    'premium_yearly_subscribers', v_premium_yearly,
    'estimated_monthly_revenue', ROUND(v_monthly_revenue, 2),
    'estimated_yearly_revenue', ROUND(v_yearly_revenue, 2),
    'total_trades', (SELECT COUNT(*) FROM public.trades WHERE deleted_at IS NULL),
    'trades_today', (SELECT COUNT(*) FROM public.trades WHERE created_at::date = CURRENT_DATE AND deleted_at IS NULL),
    'trades_this_week', (SELECT COUNT(*) FROM public.trades WHERE created_at > NOW() - INTERVAL '7 days' AND deleted_at IS NULL),
    'trades_this_month', (SELECT COUNT(*) FROM public.trades WHERE DATE_TRUNC('month', created_at) = DATE_TRUNC('month', CURRENT_DATE) AND deleted_at IS NULL),
    'total_strategies', (SELECT COUNT(*) FROM public.strategies WHERE deleted_at IS NULL),
    'new_users_today', (SELECT COUNT(*) FROM public.profiles WHERE created_at::date = CURRENT_DATE),
    'new_users_this_week', (SELECT COUNT(*) FROM public.profiles WHERE created_at > NOW() - INTERVAL '7 days'),
    'new_users_this_month', (SELECT COUNT(*) FROM public.profiles WHERE DATE_TRUNC('month', created_at) = DATE_TRUNC('month', CURRENT_DATE)),
    'generated_at', NOW()
  ) INTO stats;

  RETURN stats;
END;
$$;

COMMENT ON FUNCTION public.get_platform_stats IS 
'v8.5.10: Returns comprehensive platform statistics including users, trades, and revenue estimates. Admin only.';

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- ğŸ”’ SECURE VERSION: get_user_detailed_stats (v8.5.10)
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
DROP FUNCTION IF EXISTS public.get_user_detailed_stats(UUID) CASCADE;

CREATE OR REPLACE FUNCTION public.get_user_detailed_stats(p_user_id UUID)
RETURNS JSON 
LANGUAGE plpgsql
SECURITY DEFINER
STABLE
SET search_path = public
AS $$
DECLARE
  stats JSON;
  v_is_admin BOOLEAN;
BEGIN
  -- ğŸ”’ Strict admin check
  SELECT role IN ('admin', 'super_admin') AND is_banned = FALSE
  INTO v_is_admin
  FROM public.profiles
  WHERE id = auth.uid();

  IF NOT COALESCE(v_is_admin, FALSE) THEN
    RAISE EXCEPTION 'Access denied: Admin access required';
  END IF;

  -- ğŸ”’ Enable admin mode for RLS bypass
  PERFORM set_config('app.admin_mode', 'true', true);

  -- Build detailed stats for the user
  SELECT json_build_object(
    'user_id', p_user_id,
    'total_trades', (SELECT COUNT(*) FROM public.trades WHERE user_id = p_user_id AND deleted_at IS NULL),
    'open_trades', (SELECT COUNT(*) FROM public.trades WHERE user_id = p_user_id AND exit_price IS NULL AND deleted_at IS NULL),
    'closed_trades', (SELECT COUNT(*) FROM public.trades WHERE user_id = p_user_id AND exit_price IS NOT NULL AND deleted_at IS NULL),
    'total_strategies', (SELECT COUNT(*) FROM public.strategies WHERE user_id = p_user_id AND deleted_at IS NULL),
    'win_rate', (
      SELECT CASE WHEN COUNT(*) > 0 THEN 
        ROUND((COUNT(*) FILTER (WHERE outcome = 'WIN')::NUMERIC / COUNT(*)::NUMERIC) * 100, 2)
      ELSE 0 END
      FROM public.trades 
      WHERE user_id = p_user_id AND outcome IN ('WIN', 'LOSS') AND deleted_at IS NULL
    ),
    'total_pnl', (SELECT COALESCE(SUM(pnl), 0) FROM public.trades WHERE user_id = p_user_id AND deleted_at IS NULL),
    'avg_pnl', (SELECT ROUND(COALESCE(AVG(pnl), 0)::NUMERIC, 2) FROM public.trades WHERE user_id = p_user_id AND pnl IS NOT NULL AND deleted_at IS NULL),
    'best_trade', (SELECT MAX(pnl) FROM public.trades WHERE user_id = p_user_id AND deleted_at IS NULL),
    'worst_trade', (SELECT MIN(pnl) FROM public.trades WHERE user_id = p_user_id AND deleted_at IS NULL),
    'first_trade_date', (SELECT MIN(open_at) FROM public.trades WHERE user_id = p_user_id AND deleted_at IS NULL),
    'last_trade_date', (SELECT MAX(open_at) FROM public.trades WHERE user_id = p_user_id AND deleted_at IS NULL),
    'most_traded_symbol', (
      SELECT symbol FROM public.trades WHERE user_id = p_user_id AND deleted_at IS NULL
      GROUP BY symbol ORDER BY COUNT(*) DESC LIMIT 1
    ),
    'favorite_side', (
      SELECT side FROM public.trades WHERE user_id = p_user_id AND deleted_at IS NULL
      GROUP BY side ORDER BY COUNT(*) DESC LIMIT 1
    ),
    'generated_at', NOW()
  ) INTO stats;

  -- ğŸ”’ Disable admin mode
  PERFORM set_config('app.admin_mode', 'false', true);

  RETURN stats;
END;
$$;

COMMENT ON FUNCTION public.get_user_detailed_stats IS 
'v8.5.10-SECURE: Admin-only function with admin_mode enforcement and strict permission checks.';

-- âœ… Get Subscription Breakdown
CREATE OR REPLACE FUNCTION public.get_subscription_breakdown()
RETURNS TABLE (
  account_type TEXT,
  subscription_interval TEXT,
  user_count BIGINT,
  percentage NUMERIC,
  monthly_revenue NUMERIC
) 
LANGUAGE plpgsql
SECURITY DEFINER
STABLE
SET search_path = public
AS $$
BEGIN
  IF NOT public.is_admin() THEN
    RAISE EXCEPTION 'Unauthorized - Admin access required';
  END IF;

  RETURN QUERY
  WITH total_users AS (
    SELECT COUNT(*)::NUMERIC as total FROM public.profiles
  ),
  breakdown AS (
    SELECT 
      p.account_type,
      COALESCE(p.subscription_interval, 'none') as subscription_interval,
      COUNT(*) as user_count,
      CASE 
        WHEN p.account_type = 'basic' AND p.subscription_interval = 'monthly' THEN 19.99
        WHEN p.account_type = 'basic' AND p.subscription_interval = 'yearly' THEN 12.42
        WHEN p.account_type = 'premium' AND p.subscription_interval = 'monthly' THEN 39.99
        WHEN p.account_type = 'premium' AND p.subscription_interval = 'yearly' THEN 24.92
        ELSE 0
      END as monthly_price
    FROM public.profiles p
    GROUP BY p.account_type, p.subscription_interval
  )
  SELECT 
    b.account_type,
    b.subscription_interval,
    b.user_count,
    ROUND((b.user_count::NUMERIC / NULLIF(t.total, 0) * 100), 2) as percentage,
    ROUND((b.user_count * b.monthly_price), 2) as monthly_revenue
  FROM breakdown b
  CROSS JOIN total_users t
  ORDER BY b.account_type, b.subscription_interval;
END;
$$;

COMMENT ON FUNCTION public.get_subscription_breakdown IS 
'v8.5.10: Returns subscription breakdown with revenue estimates. Admin only.';

-- âœ… Get Revenue Analytics
CREATE OR REPLACE FUNCTION public.get_revenue_analytics(p_days INTEGER DEFAULT 30)
RETURNS TABLE (
  date DATE,
  basic_monthly_count INTEGER,
  basic_yearly_count INTEGER,
  premium_monthly_count INTEGER,
  premium_yearly_count INTEGER,
  daily_revenue NUMERIC,
  cumulative_revenue NUMERIC
) 
LANGUAGE plpgsql
SECURITY DEFINER
STABLE
SET search_path = public
AS $$
DECLARE
  v_start_date DATE;
BEGIN
  IF NOT is_admin() THEN
    RAISE EXCEPTION 'Unauthorized - Admin access required';
  END IF;

  -- Limit to reasonable range
  IF p_days > 365 THEN
    p_days := 365;
  END IF;

  v_start_date := CURRENT_DATE - p_days;

  RETURN QUERY
  WITH RECURSIVE date_series AS (
    SELECT v_start_date as date
    UNION ALL
    SELECT (date + 1)::DATE FROM date_series WHERE date < CURRENT_DATE
  ),
  daily_stats AS (
    SELECT 
      ds.date,
      COUNT(*) FILTER (WHERE p.account_type = 'basic' AND p.subscription_interval = 'monthly') as basic_monthly,
      COUNT(*) FILTER (WHERE p.account_type = 'basic' AND p.subscription_interval = 'yearly') as basic_yearly,
      COUNT(*) FILTER (WHERE p.account_type = 'premium' AND p.subscription_interval = 'monthly') as premium_monthly,
      COUNT(*) FILTER (WHERE p.account_type = 'premium' AND p.subscription_interval = 'yearly') as premium_yearly
    FROM date_series ds
    LEFT JOIN public.profiles p ON p.subscription_started_at::DATE <= ds.date 
      AND (p.subscription_expires_at IS NULL OR p.subscription_expires_at::DATE >= ds.date)
      AND p.account_type IN ('basic', 'premium')
    GROUP BY ds.date
  )
  SELECT 
    ds.date,
    ds.basic_monthly::INTEGER,
    ds.basic_yearly::INTEGER,
    ds.premium_monthly::INTEGER,
    ds.premium_yearly::INTEGER,
    ROUND(((ds.basic_monthly * 19.99) + (ds.basic_yearly * 12.42) + 
     (ds.premium_monthly * 39.99) + (ds.premium_yearly * 24.92))::NUMERIC, 2) as daily_revenue,
    ROUND(SUM((ds.basic_monthly * 19.99) + (ds.basic_yearly * 12.42) +
        (ds.premium_monthly * 39.99) + (ds.premium_yearly * 24.92)) 
    OVER (ORDER BY ds.date)::NUMERIC, 2) as cumulative_revenue
  FROM daily_stats ds
  ORDER BY ds.date;
END;
$$;

COMMENT ON FUNCTION public.get_revenue_analytics IS 
'v8.5.10: Returns daily revenue analytics for specified number of days. Admin only.';

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- ğŸ”§ ADMIN IMPERSONATION FUNCTIONS
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

DO $$
BEGIN
  RAISE NOTICE '';
  RAISE NOTICE '[11.5/15] ğŸ”§ Creating impersonation functions...';
END $$;

-- âœ… Start Impersonation Session
DROP FUNCTION IF EXISTS public.start_impersonation_session_v1(UUID, TEXT) CASCADE;

CREATE OR REPLACE FUNCTION public.start_impersonation_session_v1(
  p_user_id UUID,
  p_admin_email TEXT
)
RETURNS TABLE (
  access_token TEXT,
  refresh_token TEXT,
  user_data JSONB
)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public, extensions
AS $$
DECLARE
  v_admin_id UUID;
  v_session_token TEXT;
  v_impersonated_user RECORD;
BEGIN
  -- Verify admin by email
  SELECT id INTO v_admin_id
  FROM public.profiles
  WHERE email = p_admin_email
    AND role IN ('admin', 'super_admin')
    AND is_banned = FALSE;
  
  IF v_admin_id IS NULL THEN
    RAISE EXCEPTION 'Unauthorized: Must be admin. Email % not found or not admin.', p_admin_email;
  END IF;
  
  -- Get target user info
  SELECT 
    p.id,
    p.email,
    p.display_name,
    p.role,
    p.account_type
  INTO v_impersonated_user
  FROM public.profiles p
  WHERE p.id = p_user_id;
  
  IF v_impersonated_user.id IS NULL THEN
    RAISE EXCEPTION 'User not found: %', p_user_id;
  END IF;
  
  -- Cannot impersonate other admins
  IF v_impersonated_user.role IN ('admin', 'super_admin') THEN
    RAISE EXCEPTION 'Cannot impersonate other admins';
  END IF;
  
  -- Generate secure session token
  v_session_token := encode(extensions.gen_random_bytes(32), 'hex');
  
  -- Create impersonation session record
  INSERT INTO public.admin_impersonation_sessions (
    admin_id,
    impersonated_user_id,
    session_token,
    expires_at,
    impersonated_user_email,
    impersonated_user_name,
    admin_email,
    is_active
  ) VALUES (
    v_admin_id,
    p_user_id,
    v_session_token,
    NOW() + INTERVAL '2 hours',
    v_impersonated_user.email,
    COALESCE(v_impersonated_user.display_name, v_impersonated_user.email),
    p_admin_email,
    TRUE
  );
  
  -- Log action with CORRECT admin_id
  BEGIN
    PERFORM public.log_admin_action(
      'START_IMPERSONATION',
      'impersonation_session',
      p_user_id,
      jsonb_build_object(
        'admin_id', v_admin_id,
        'impersonated_email', v_impersonated_user.email,
        'impersonated_name', v_impersonated_user.display_name,
        'session_token_prefix', LEFT(v_session_token, 8) || '...'
      )
    );
  EXCEPTION 
    WHEN undefined_function THEN
      RAISE WARNING 'log_admin_action function not found';
    WHEN OTHERS THEN
      RAISE WARNING 'Failed to log impersonation action: %', SQLERRM;
  END;
  
  -- Return session data for UI
  RETURN QUERY SELECT
    v_session_token::TEXT as access_token,
    v_session_token::TEXT as refresh_token,
    jsonb_build_object(
      'id', v_impersonated_user.id,
      'email', v_impersonated_user.email,
      'display_name', COALESCE(v_impersonated_user.display_name, v_impersonated_user.email),
      'role', v_impersonated_user.role,
      'account_type', v_impersonated_user.account_type,
      'impersonated', TRUE,
      'impersonated_by', p_admin_email,
      'session_expires_at', NOW() + INTERVAL '2 hours'
    ) as user_data;
END;
$$;

COMMENT ON FUNCTION public.start_impersonation_session_v1 IS 
'v8.5.10: Allows admins to impersonate users. Admin_id correctly logged.';

GRANT EXECUTE ON FUNCTION public.start_impersonation_session_v1(UUID, TEXT) TO authenticated;

-- âœ… End Impersonation Session
CREATE OR REPLACE FUNCTION public.end_impersonation_session(p_session_token TEXT)
RETURNS BOOLEAN
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public, extensions
AS $$
DECLARE
  v_session RECORD;
BEGIN
  -- Get session details
  SELECT admin_id, impersonated_user_id, is_active, admin_email
  INTO v_session
  FROM public.admin_impersonation_sessions
  WHERE session_token = p_session_token;
  
  IF v_session.admin_id IS NULL THEN
    RAISE WARNING 'Session not found: %', LEFT(p_session_token, 8) || '...';
    RETURN FALSE;
  END IF;
  
  -- Verify caller is the admin who started the session
  IF v_session.admin_id != auth.uid() THEN
    RAISE EXCEPTION 'Unauthorized: Only the admin who started impersonation can end it';
  END IF;
  
  -- End the session
  UPDATE public.admin_impersonation_sessions
  SET 
    is_active = FALSE,
    last_activity_at = NOW()
  WHERE session_token = p_session_token;
  
  -- Log the action
  PERFORM public.log_admin_action(
    'END_IMPERSONATION',
    'impersonation_session',
    v_session.impersonated_user_id,
    jsonb_build_object(
      'session_token_prefix', LEFT(p_session_token, 8) || '...',
      'ended_at', NOW()
    )
  );
  
  RETURN TRUE;
END;
$$;

COMMENT ON FUNCTION public.end_impersonation_session IS 
'v8.5.10: Ends an active impersonation session. Only starting admin can end it.';

GRANT EXECUTE ON FUNCTION public.end_impersonation_session(TEXT) TO authenticated;

-- âœ… Get Active Impersonation Sessions
CREATE OR REPLACE FUNCTION public.get_active_impersonation_sessions()
RETURNS TABLE (
  id UUID,
  admin_email TEXT,
  impersonated_user_email TEXT,
  impersonated_user_name TEXT,
  created_at TIMESTAMPTZ,
  expires_at TIMESTAMPTZ,
  last_activity_at TIMESTAMPTZ
)
LANGUAGE plpgsql
SECURITY DEFINER
STABLE
SET search_path = public
AS $$
BEGIN
  IF NOT public.is_admin() THEN
    RAISE EXCEPTION 'Unauthorized: Admin access required';
  END IF;
  
  RETURN QUERY
  SELECT 
    s.id,
    s.admin_email,
    s.impersonated_user_email,
    s.impersonated_user_name,
    s.created_at,
    s.expires_at,
    s.last_activity_at
  FROM public.admin_impersonation_sessions s
  WHERE s.is_active = TRUE
    AND s.expires_at > NOW()
  ORDER BY s.created_at DESC;
END;
$$;

COMMENT ON FUNCTION public.get_active_impersonation_sessions IS 
'v8.5.10: Returns all active (non-expired) impersonation sessions. Admin only.';

GRANT EXECUTE ON FUNCTION public.get_active_impersonation_sessions() TO authenticated;

-- ===============================================
-- SECTION 12: ACTIVITY TRACKING
-- ===============================================

DO $$
BEGIN
  RAISE NOTICE '[12/15] Creating activity tracking functions...';
END $$;

-- âœ… Update User Login Stats (Trigger Function)
CREATE OR REPLACE FUNCTION public.update_user_login_stats()
RETURNS TRIGGER 
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  UPDATE public.profiles
  SET 
    last_login_at = NOW(),
    login_count = COALESCE(login_count, 0) + 1,
    updated_at = NOW()
  WHERE id = NEW.user_id;
  
  RETURN NEW;
END;
$$;

COMMENT ON FUNCTION public.update_user_login_stats IS 
'v8.5.10: Trigger function to update login count and timestamp.';

-- âœ… Get Broker Status
CREATE OR REPLACE FUNCTION public.get_broker_status(p_broker TEXT)
RETURNS JSON 
LANGUAGE plpgsql
SECURITY DEFINER
STABLE
SET search_path = public
AS $$
DECLARE
  connection_status JSON;
  v_user_id UUID;
BEGIN
  v_user_id := auth.uid();
  
  IF v_user_id IS NULL THEN
    RETURN json_build_object('status', 'not_authenticated');
  END IF;

  SELECT json_build_object(
    'broker', bc.broker,
    'status', bc.status,
    'connected_at', bc.connected_at,
    'last_sync_at', bc.last_sync_at,
    'account_name', bc.account_name,
    'account_id', bc.account_id,
    'error_message', bc.error_message
  ) INTO connection_status
  FROM public.broker_connections bc
  WHERE bc.user_id = v_user_id AND bc.broker = p_broker;
  
  RETURN COALESCE(
    connection_status, 
    json_build_object('status', 'disconnected', 'broker', p_broker)
  );
END;
$$;

COMMENT ON FUNCTION public.get_broker_status IS 
'v8.5.10: Returns connection status for a specific broker for current user.';

-- âœ… Get Trades by Broker
CREATE OR REPLACE FUNCTION public.get_trades_by_broker()
RETURNS JSON 
LANGUAGE plpgsql
SECURITY DEFINER
STABLE
SET search_path = public
AS $$
DECLARE
  broker_stats JSON;
  v_user_id UUID;
BEGIN
  v_user_id := auth.uid();
  
  IF v_user_id IS NULL THEN
    RETURN '{}'::json;
  END IF;

  SELECT COALESCE(json_object_agg(broker, trade_count), '{}'::json) 
  INTO broker_stats
  FROM (
    SELECT 
      COALESCE(t.broker, 'manual') as broker, 
      COUNT(*) as trade_count
    FROM public.trades t
    WHERE t.user_id = v_user_id
      AND t.deleted_at IS NULL
    GROUP BY t.broker
  ) stats;
  
  RETURN broker_stats;
END;
$$;

COMMENT ON FUNCTION public.get_trades_by_broker IS 
'v8.5.10: Returns trade count grouped by broker/source for current user.';

-- âœ… Admin Get Broker Stats
CREATE OR REPLACE FUNCTION public.admin_get_broker_stats()
RETURNS JSON 
LANGUAGE plpgsql
SECURITY DEFINER
STABLE
SET search_path = public
AS $$
BEGIN
  IF NOT public.is_admin() THEN
    RAISE EXCEPTION 'Unauthorized - Admin access required';
  END IF;

  RETURN (
    SELECT json_build_object(
      'total_connections', COUNT(*),
      'active_connections', COUNT(*) FILTER (WHERE status = 'connected'),
      'failed_connections', COUNT(*) FILTER (WHERE status = 'error'),
      'pending_connections', COUNT(*) FILTER (WHERE status = 'pending'),
      'by_broker', (
        SELECT COALESCE(json_object_agg(broker, count), '{}'::json)
        FROM (
          SELECT broker, COUNT(*) as count
          FROM public.broker_connections
          GROUP BY broker
        ) broker_counts
      ),
      'recent_syncs', (
        SELECT COALESCE(json_agg(
          json_build_object(
            'user_id', bc.user_id,
            'broker', bc.broker,
            'last_sync_at', bc.last_sync_at,
            'status', bc.status
          )
        ), '[]'::json)
        FROM (
          SELECT user_id, broker, last_sync_at, status
          FROM public.broker_connections
          WHERE last_sync_at IS NOT NULL
          ORDER BY last_sync_at DESC
          LIMIT 10
        ) bc
      ),
      'generated_at', NOW()
    )
    FROM public.broker_connections
  );
END;
$$;

COMMENT ON FUNCTION public.admin_get_broker_stats IS 
'v8.5.10: Platform-wide broker connection statistics. Admin only.';

-- ===============================================
-- SECTION 13: ALL TRIGGERS + RLS
-- ===============================================

DO $$
BEGIN
  RAISE NOTICE '[13/15] Creating ALL triggers + RLS...';
END $$;

-- Profiles trigger
DROP TRIGGER IF EXISTS set_updated_at ON public.profiles;
CREATE TRIGGER set_updated_at 
  BEFORE UPDATE ON public.profiles
  FOR EACH ROW 
  EXECUTE FUNCTION public.handle_updated_at();

-- Auth trigger (new user creation)
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW
  EXECUTE FUNCTION public.handle_new_user();

-- Trades search vector trigger
DROP TRIGGER IF EXISTS trades_search_vector_update ON public.trades;
CREATE TRIGGER trades_search_vector_update
  BEFORE INSERT OR UPDATE OF notes, setup, mistake, symbol
  ON public.trades
  FOR EACH ROW
  EXECUTE FUNCTION public.update_trades_search_vector();

-- Trades updated_at trigger
DROP TRIGGER IF EXISTS set_updated_at ON public.trades;
CREATE TRIGGER set_updated_at 
  BEFORE UPDATE ON public.trades
  FOR EACH ROW 
  EXECUTE FUNCTION public.handle_updated_at();

-- Strategies trigger
DROP TRIGGER IF EXISTS set_updated_at ON public.strategies;
CREATE TRIGGER set_updated_at 
  BEFORE UPDATE ON public.strategies
  FOR EACH ROW 
  EXECUTE FUNCTION public.handle_updated_at();

-- Payment trigger
DROP TRIGGER IF EXISTS on_payment_completed ON public.payment_history;
CREATE TRIGGER on_payment_completed
  AFTER INSERT OR UPDATE ON public.payment_history
  FOR EACH ROW
  EXECUTE FUNCTION public.update_account_type_on_payment();

-- Activity/Login trigger
DROP TRIGGER IF EXISTS trigger_update_login_stats ON public.user_activity_log;
CREATE TRIGGER trigger_update_login_stats
  AFTER INSERT ON public.user_activity_log
  FOR EACH ROW 
  WHEN (NEW.action = 'LOGIN')
  EXECUTE FUNCTION public.update_user_login_stats();

-- Broker connections trigger
DROP TRIGGER IF EXISTS trigger_broker_connection_updated_at ON public.broker_connections;
CREATE TRIGGER trigger_broker_connection_updated_at
  BEFORE UPDATE ON public.broker_connections
  FOR EACH ROW 
  EXECUTE FUNCTION update_timestamp();

-- User settings trigger
DROP TRIGGER IF EXISTS trigger_user_settings_updated_at ON public.user_settings;
CREATE TRIGGER trigger_user_settings_updated_at
  BEFORE UPDATE ON public.user_settings
  FOR EACH ROW 
  EXECUTE FUNCTION update_timestamp();

-- SnapTrade activity trigger
DROP TRIGGER IF EXISTS update_snaptrade_activity_updated_at_trigger ON public.snaptrade_activity;
CREATE TRIGGER update_snaptrade_activity_updated_at_trigger
  BEFORE UPDATE ON public.snaptrade_activity
  FOR EACH ROW
  EXECUTE FUNCTION update_timestamp();

DO $$
BEGIN
  RAISE NOTICE '   âœ… All 10 triggers created';
END $$;

-- ===============================================
-- SECTION 14: HELPER FUNCTIONS FOR ADMIN MAINTENANCE
-- ===============================================

DO $$
BEGIN
  RAISE NOTICE '';
  RAISE NOTICE '[14/15] Creating helper functions for admin maintenance...';
END $$;

-- âœ… 1. Refresh Webhook Stats
CREATE OR REPLACE FUNCTION public.refresh_webhook_stats()
RETURNS TEXT
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  IF NOT public.is_admin() THEN
    RAISE EXCEPTION 'Unauthorized - Admin access required';
  END IF;
  
  REFRESH MATERIALIZED VIEW CONCURRENTLY public.webhook_stats;
  
  RETURN 'Webhook stats refreshed successfully at ' || NOW()::TEXT;
END;
$$;

COMMENT ON FUNCTION public.refresh_webhook_stats IS 
'v8.5.10: Manually refresh webhook statistics materialized view (admin only)';

-- âœ… 2. Refresh Strategy Stats
CREATE OR REPLACE FUNCTION public.refresh_strategy_stats()
RETURNS TEXT
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  IF NOT public.is_admin() THEN
    RAISE EXCEPTION 'Unauthorized - Admin access required';
  END IF;
  
  REFRESH MATERIALIZED VIEW CONCURRENTLY public.strategy_stats_view;
  
  RETURN 'Strategy stats refreshed successfully at ' || NOW()::TEXT;
END;
$$;

COMMENT ON FUNCTION public.refresh_strategy_stats IS 
'v8.5.10: Manually refresh strategy statistics materialized view (admin only)';

-- âœ… 3. Refresh All Materialized Views
CREATE OR REPLACE FUNCTION public.refresh_all_materialized_views()
RETURNS TEXT
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_refreshed INTEGER := 0;
BEGIN
  IF NOT public.is_admin() THEN
    RAISE EXCEPTION 'Unauthorized - Admin access required';
  END IF;
  
  -- Refresh each view with error handling
  BEGIN
    REFRESH MATERIALIZED VIEW CONCURRENTLY public.webhook_stats;
    v_refreshed := v_refreshed + 1;
  EXCEPTION WHEN OTHERS THEN
    RAISE WARNING 'Failed to refresh webhook_stats: %', SQLERRM;
  END;
  
  BEGIN
    REFRESH MATERIALIZED VIEW CONCURRENTLY public.strategy_stats_view;
    v_refreshed := v_refreshed + 1;
  EXCEPTION WHEN OTHERS THEN
    RAISE WARNING 'Failed to refresh strategy_stats_view: %', SQLERRM;
  END;
  
  RETURN format('Refreshed %s materialized views at %s', v_refreshed, NOW()::TEXT);
END;
$$;

COMMENT ON FUNCTION public.refresh_all_materialized_views IS 
'v8.5.10: Refresh all materialized views in one call (admin only)';

-- âœ… 4. Get Database Size
CREATE OR REPLACE FUNCTION public.get_database_size()
RETURNS TABLE (
  total_size_mb NUMERIC,
  total_size_gb NUMERIC
)
LANGUAGE plpgsql
SECURITY DEFINER
STABLE
SET search_path = public
AS $$
BEGIN
  IF NOT public.is_admin() THEN
    RAISE EXCEPTION 'Unauthorized - Admin access required';
  END IF;
  
  RETURN QUERY
  SELECT 
    ROUND(pg_database_size(current_database())::NUMERIC / 1048576, 2) as total_size_mb,
    ROUND(pg_database_size(current_database())::NUMERIC / 1073741824, 4) as total_size_gb;
END;
$$;

COMMENT ON FUNCTION public.get_database_size IS 
'v8.5.10: Returns database size in MB and GB. Admin only.';

-- âœ… 5. Get Table Sizes
CREATE OR REPLACE FUNCTION public.get_table_sizes()
RETURNS TABLE (
  table_name TEXT,
  size_mb NUMERIC,
  row_count BIGINT
)
LANGUAGE plpgsql
SECURITY DEFINER
STABLE
SET search_path = public
AS $$
BEGIN
  IF NOT public.is_admin() THEN
    RAISE EXCEPTION 'Unauthorized - Admin access required';
  END IF;
  
  RETURN QUERY
  SELECT 
    t.table_name::TEXT,
    ROUND(pg_total_relation_size(quote_ident(t.table_schema)||'.'||quote_ident(t.table_name))::NUMERIC / 1048576, 2) as size_mb,
    (xpath('/row/cnt/text()', 
      query_to_xml(format('SELECT COUNT(*) as cnt FROM %I.%I', t.table_schema, t.table_name), 
      false, true, '')))[1]::text::BIGINT as row_count
  FROM information_schema.tables t
  WHERE t.table_schema = 'public'
    AND t.table_type = 'BASE TABLE'
  ORDER BY pg_total_relation_size(quote_ident(t.table_schema)||'.'||quote_ident(t.table_name)) DESC;
END;
$$;

COMMENT ON FUNCTION public.get_table_sizes IS 
'v8.5.10: Get size and row count for all tables (admin only)';

-- âœ… 6. Get Slow Queries
CREATE OR REPLACE FUNCTION public.get_slow_queries(limit_count INTEGER DEFAULT 10)
RETURNS TABLE (
  query TEXT,
  mean_time_ms NUMERIC,
  calls BIGINT,
  total_time_ms NUMERIC
)
LANGUAGE plpgsql
SECURITY DEFINER
STABLE
SET search_path = public
AS $$
BEGIN
  IF NOT public.is_admin() THEN
    RAISE EXCEPTION 'Unauthorized - Admin access required';
  END IF;
  
  -- Check if pg_stat_statements extension is available
  IF NOT EXISTS (SELECT 1 FROM pg_extension WHERE extname = 'pg_stat_statements') THEN
    RAISE EXCEPTION 'pg_stat_statements extension is not enabled';
  END IF;
  
  RETURN QUERY
  SELECT 
    pss.query::TEXT,
    ROUND(pss.mean_exec_time::NUMERIC, 2) as mean_time_ms,
    pss.calls::BIGINT,
    ROUND(pss.total_exec_time::NUMERIC, 2) as total_time_ms
  FROM pg_stat_statements pss
  WHERE pss.query NOT LIKE '%pg_stat_statements%'
  ORDER BY pss.mean_exec_time DESC
  LIMIT limit_count;
END;
$$;

COMMENT ON FUNCTION public.get_slow_queries IS 
'v8.5.10: Get slowest queries for performance monitoring. Requires pg_stat_statements extension. (admin only)';

-- âœ… 7. Check System Health
CREATE OR REPLACE FUNCTION public.check_system_health()
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
STABLE
SET search_path = public
AS $$
DECLARE
  v_result JSONB;
  v_db_size NUMERIC;
  v_max_connections INTEGER;
  v_current_connections INTEGER;
  v_rls_count INTEGER;
  v_function_count INTEGER;
  v_matview_count INTEGER;
  v_total_users BIGINT;
  v_total_trades BIGINT;
BEGIN
  IF NOT public.is_admin() THEN
    RAISE EXCEPTION 'Unauthorized - Admin access required';
  END IF;
  
  -- Get database size in GB
  SELECT pg_database_size(current_database())::NUMERIC / 1073741824 INTO v_db_size;
  
  -- Get connection info
  SELECT setting::INTEGER INTO v_max_connections 
  FROM pg_settings WHERE name = 'max_connections';
  
  SELECT COUNT(*)::INTEGER INTO v_current_connections 
  FROM pg_stat_activity;
  
  -- Get RLS enabled tables count
  SELECT COUNT(*) INTO v_rls_count 
  FROM pg_tables 
  WHERE schemaname = 'public' AND rowsecurity = true;
  
  -- Get function count
  SELECT COUNT(*) INTO v_function_count 
  FROM pg_proc p 
  JOIN pg_namespace n ON p.pronamespace = n.oid 
  WHERE n.nspname = 'public';
  
  -- Get materialized view count
  SELECT COUNT(*) INTO v_matview_count 
  FROM pg_matviews 
  WHERE schemaname = 'public';
  
  -- Get user and trade counts
  SELECT COUNT(*) INTO v_total_users FROM public.profiles WHERE deleted_at IS NULL;
  SELECT COUNT(*) INTO v_total_trades FROM public.trades WHERE deleted_at IS NULL;
  
  v_result := jsonb_build_object(
    'database', jsonb_build_object(
      'status', CASE 
        WHEN v_db_size < 8 THEN 'healthy' 
        WHEN v_db_size < 9 THEN 'warning' 
        ELSE 'critical' 
      END,
      'size_gb', ROUND(v_db_size, 4),
      'max_size_gb', 10
    ),
    'connections', jsonb_build_object(
      'status', CASE 
        WHEN v_current_connections < (v_max_connections * 0.7) THEN 'healthy' 
        WHEN v_current_connections < (v_max_connections * 0.9) THEN 'warning' 
        ELSE 'critical' 
      END,
      'current', v_current_connections,
      'max', v_max_connections,
      'usage_percent', ROUND((v_current_connections::NUMERIC / v_max_connections * 100), 1)
    ),
    'rls', jsonb_build_object(
      'status', 'healthy',
      'enabled_tables', v_rls_count
    ),
    'functions', jsonb_build_object(
      'status', 'healthy',
      'total', v_function_count
    ),
    'materialized_views', jsonb_build_object(
      'status', 'healthy',
      'total', v_matview_count
    ),
    'data', jsonb_build_object(
      'total_users', v_total_users,
      'total_trades', v_total_trades
    ),
    'checked_at', NOW()
  );
  
  RETURN v_result;
END;
$$;

COMMENT ON FUNCTION public.check_system_health IS 
'v8.5.10: Comprehensive system health check for admin dashboard.';

-- âœ… 8. Manual Cleanup Old Data
CREATE OR REPLACE FUNCTION public.manual_cleanup_old_data()
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_rate_limits_deleted INTEGER := 0;
  v_sessions_deactivated INTEGER := 0;
  v_logs_archived INTEGER := 0;
BEGIN
  IF NOT public.is_admin() THEN
    RAISE EXCEPTION 'Unauthorized - Admin access required';
  END IF;
  
  -- Clean up old rate limits (older than 24 hours)
  DELETE FROM public.api_rate_limits 
  WHERE window_start < NOW() - INTERVAL '24 hours';
  GET DIAGNOSTICS v_rate_limits_deleted = ROW_COUNT;
  
  -- Deactivate expired impersonation sessions
  UPDATE public.admin_impersonation_sessions 
  SET is_active = false 
  WHERE expires_at < NOW() AND is_active = true;
  GET DIAGNOSTICS v_sessions_deactivated = ROW_COUNT;
  
  -- Archive old audit logs (older than 1 year)
  DELETE FROM public.admin_audit_log 
  WHERE created_at < NOW() - INTERVAL '1 year';
  GET DIAGNOSTICS v_logs_archived = ROW_COUNT;
  
  RETURN jsonb_build_object(
    'success', true,
    'rate_limits_deleted', v_rate_limits_deleted,
    'sessions_deactivated', v_sessions_deactivated,
    'logs_archived', v_logs_archived,
    'cleaned_at', NOW()
  );
END;
$$;

COMMENT ON FUNCTION public.manual_cleanup_old_data IS 
'v8.5.10: Manual cleanup of old rate limits and expired sessions. Admin only.';

-- ===============================================
-- ğŸ”¥ SECTION 15: SNAPTRADE FUNCTIONS
-- ===============================================

DO $$
BEGIN
  RAISE NOTICE '';
  RAISE NOTICE '[15/15] ğŸ”¥ Creating SnapTrade integration functions...';
END $$;

-- âœ… 15.1: Check SnapTrade Connection Status
DROP FUNCTION IF EXISTS public.is_snaptrade_connected(UUID) CASCADE;

CREATE OR REPLACE FUNCTION public.is_snaptrade_connected(p_user_id UUID)
RETURNS BOOLEAN
LANGUAGE plpgsql
SECURITY DEFINER
STABLE
SET search_path = public
AS $$
BEGIN
  RETURN EXISTS (
    SELECT 1 FROM snaptrade_users 
    WHERE user_id = p_user_id
  );
END;
$$;

COMMENT ON FUNCTION public.is_snaptrade_connected IS 
'v8.5.10: Check if user has SnapTrade connected';

-- âœ… 15.2: Get User Sync Statistics
DROP FUNCTION IF EXISTS public.get_user_sync_stats(UUID) CASCADE;

CREATE OR REPLACE FUNCTION public.get_user_sync_stats(p_user_id UUID)
RETURNS TABLE (
  total_syncs BIGINT,
  successful_syncs BIGINT,
  failed_syncs BIGINT,
  total_trades_imported BIGINT,
  last_sync_at TIMESTAMPTZ,
  last_sync_status TEXT
)
LANGUAGE plpgsql
SECURITY DEFINER
STABLE
SET search_path = public
AS $$
BEGIN
  RETURN QUERY
  SELECT 
    COUNT(*)::BIGINT as total_syncs,
    COUNT(*) FILTER (WHERE status = 'completed')::BIGINT as successful_syncs,
    COUNT(*) FILTER (WHERE status = 'failed')::BIGINT as failed_syncs,
    COALESCE(SUM(trades_imported), 0)::BIGINT as total_trades_imported,
    MAX(sync_completed_at) as last_sync_at,
    (
      SELECT ssl.status FROM snaptrade_sync_log ssl
      WHERE ssl.user_id = p_user_id 
      ORDER BY ssl.created_at DESC 
      LIMIT 1
    )::TEXT as last_sync_status
  FROM snaptrade_sync_log
  WHERE snaptrade_sync_log.user_id = p_user_id;
END;
$$;

COMMENT ON FUNCTION public.get_user_sync_stats IS 
'v8.5.10: Get comprehensive sync statistics for user';

-- âœ… 15.3: Get Latest Sync for User
DROP FUNCTION IF EXISTS public.get_latest_sync_for_user(UUID) CASCADE;

CREATE OR REPLACE FUNCTION public.get_latest_sync_for_user(p_user_id UUID)
RETURNS TABLE (
  id UUID,
  status TEXT,
  sync_started_at TIMESTAMPTZ,
  sync_completed_at TIMESTAMPTZ,
  trades_imported INTEGER,
  error_message TEXT,
  sync_type TEXT,
  duration_seconds INTEGER
)
LANGUAGE plpgsql
SECURITY DEFINER
STABLE
SET search_path = public
AS $$
BEGIN
  RETURN QUERY
  SELECT 
    ssl.id,
    ssl.status::TEXT,
    ssl.sync_started_at,
    ssl.sync_completed_at,
    ssl.trades_imported,
    ssl.error_message,
    ssl.sync_type::TEXT,
    ssl.duration_seconds
  FROM snaptrade_sync_log ssl
  WHERE ssl.user_id = p_user_id
  ORDER BY ssl.created_at DESC
  LIMIT 1;
END;
$$;

COMMENT ON FUNCTION public.get_latest_sync_for_user IS 
'v8.5.10: Get most recent sync log entry for user';

-- âœ… 15.4: Get SnapTrade Import Stats (FIXED)
DROP FUNCTION IF EXISTS public.get_snaptrade_import_stats(UUID, DATE, DATE) CASCADE;

CREATE OR REPLACE FUNCTION public.get_snaptrade_import_stats(
  p_user_id UUID,
  p_start_date DATE DEFAULT NULL,
  p_end_date DATE DEFAULT NULL
)
RETURNS TABLE (
  total_imported BIGINT,
  by_symbol JSONB,
  by_side JSONB,
  by_account JSONB,
  date_range JSONB
)
LANGUAGE plpgsql
SECURITY DEFINER
STABLE
SET search_path = public
AS $$
DECLARE
  v_start_date DATE;
  v_end_date DATE;
  v_total BIGINT;
  v_by_symbol JSONB;
  v_by_side JSONB;
  v_by_account JSONB;
BEGIN
  -- Set default date range (last 30 days)
  v_start_date := COALESCE(p_start_date, CURRENT_DATE - INTERVAL '30 days');
  v_end_date := COALESCE(p_end_date, CURRENT_DATE);
  
  -- Calculate total count
  SELECT COUNT(*) INTO v_total
  FROM trades
  WHERE user_id = p_user_id
    AND import_source = 'snaptrade'
    AND imported_at::DATE BETWEEN v_start_date AND v_end_date
    AND deleted_at IS NULL;
  
  -- Aggregate by symbol (SEPARATE QUERY)
  SELECT COALESCE(jsonb_object_agg(symbol, cnt), '{}'::jsonb)
  INTO v_by_symbol
  FROM (
    SELECT symbol, COUNT(*) as cnt
    FROM trades
    WHERE user_id = p_user_id
      AND import_source = 'snaptrade'
      AND imported_at::DATE BETWEEN v_start_date AND v_end_date
      AND deleted_at IS NULL
    GROUP BY symbol
    ORDER BY cnt DESC
  ) symbol_stats;
  
  -- Aggregate by side (SEPARATE QUERY)
  SELECT COALESCE(jsonb_object_agg(side, cnt), '{}'::jsonb)
  INTO v_by_side
  FROM (
    SELECT side, COUNT(*) as cnt
    FROM trades
    WHERE user_id = p_user_id
      AND import_source = 'snaptrade'
      AND imported_at::DATE BETWEEN v_start_date AND v_end_date
      AND deleted_at IS NULL
    GROUP BY side
  ) side_stats;
  
  -- Aggregate by account (SEPARATE QUERY)
  SELECT COALESCE(jsonb_object_agg(account_id, cnt), '{}'::jsonb)
  INTO v_by_account
  FROM (
    SELECT COALESCE(snaptrade_account_id::TEXT, 'unknown') as account_id, COUNT(*) as cnt
    FROM trades
    WHERE user_id = p_user_id
      AND import_source = 'snaptrade'
      AND imported_at::DATE BETWEEN v_start_date AND v_end_date
      AND deleted_at IS NULL
    GROUP BY snaptrade_account_id
  ) account_stats;
  
  -- Return all results
  RETURN QUERY SELECT 
    COALESCE(v_total, 0::BIGINT),
    COALESCE(v_by_symbol, '{}'::jsonb),
    COALESCE(v_by_side, '{}'::jsonb),
    COALESCE(v_by_account, '{}'::jsonb),
    jsonb_build_object(
      'start_date', v_start_date,
      'end_date', v_end_date,
      'days', (v_end_date - v_start_date)::INTEGER
    );
END;
$$;

COMMENT ON FUNCTION public.get_snaptrade_import_stats IS 
'v8.5.10: Get detailed import statistics with fixed aggregation.';

-- âœ… 15.5: Find Duplicate SnapTrade Activities
DROP FUNCTION IF EXISTS public.find_duplicate_snaptrade_activities(UUID) CASCADE;

CREATE OR REPLACE FUNCTION public.find_duplicate_snaptrade_activities(p_user_id UUID)
RETURNS TABLE (
  activity_id TEXT,
  trade_count BIGINT,
  trade_ids UUID[]
)
LANGUAGE plpgsql
SECURITY DEFINER
STABLE
SET search_path = public
AS $$
BEGIN
  RETURN QUERY
  SELECT 
    t.snaptrade_activity_id::TEXT,
    COUNT(*)::BIGINT as trade_count,
    ARRAY_AGG(t.id) as trade_ids
  FROM trades t
  WHERE t.user_id = p_user_id
    AND t.snaptrade_activity_id IS NOT NULL
    AND t.deleted_at IS NULL
  GROUP BY t.snaptrade_activity_id
  HAVING COUNT(*) > 1
  ORDER BY COUNT(*) DESC;
END;
$$;

COMMENT ON FUNCTION public.find_duplicate_snaptrade_activities IS 
'v8.5.10: Find duplicate SnapTrade activity IDs (should return empty if no duplicates)';

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- GRANT ALL PERMISSIONS
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

DO $$
BEGIN
  RAISE NOTICE 'ğŸ” Granting all permissions...';
END $$;

-- Section 11: Admin Statistics
GRANT EXECUTE ON FUNCTION public.get_platform_stats() TO authenticated;
GRANT EXECUTE ON FUNCTION public.get_user_detailed_stats(UUID) TO authenticated;
GRANT EXECUTE ON FUNCTION public.get_subscription_breakdown() TO authenticated;
GRANT EXECUTE ON FUNCTION public.get_revenue_analytics(INTEGER) TO authenticated;

-- Section 12: Activity Tracking
GRANT EXECUTE ON FUNCTION public.get_broker_status(TEXT) TO authenticated;
GRANT EXECUTE ON FUNCTION public.get_trades_by_broker() TO authenticated;
GRANT EXECUTE ON FUNCTION public.admin_get_broker_stats() TO authenticated;

-- Section 14: Helper Functions
GRANT EXECUTE ON FUNCTION public.refresh_webhook_stats() TO authenticated;
GRANT EXECUTE ON FUNCTION public.refresh_strategy_stats() TO authenticated;
GRANT EXECUTE ON FUNCTION public.refresh_all_materialized_views() TO authenticated;
GRANT EXECUTE ON FUNCTION public.get_database_size() TO authenticated;
GRANT EXECUTE ON FUNCTION public.get_table_sizes() TO authenticated;
GRANT EXECUTE ON FUNCTION public.get_slow_queries(INTEGER) TO authenticated;
GRANT EXECUTE ON FUNCTION public.check_system_health() TO authenticated;
GRANT EXECUTE ON FUNCTION public.manual_cleanup_old_data() TO authenticated;

-- Section 15: SnapTrade Functions
GRANT EXECUTE ON FUNCTION public.is_snaptrade_connected(UUID) TO authenticated;
GRANT EXECUTE ON FUNCTION public.get_user_sync_stats(UUID) TO authenticated;
GRANT EXECUTE ON FUNCTION public.get_latest_sync_for_user(UUID) TO authenticated;
GRANT EXECUTE ON FUNCTION public.get_snaptrade_import_stats(UUID, DATE, DATE) TO authenticated;
GRANT EXECUTE ON FUNCTION public.find_duplicate_snaptrade_activities(UUID) TO authenticated;

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- RLS POLICY - TRADE LIMIT ENFORCEMENT
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

DO $$
BEGIN
  RAISE NOTICE 'ğŸ”¥ Creating RLS policy for trade limits...';
END $$;

-- Drop old policies if exist
DROP POLICY IF EXISTS "trades_insert_own" ON public.trades;
DROP POLICY IF EXISTS "trades_insert_with_limits" ON public.trades;

-- Create new policy with limit enforcement
CREATE POLICY "trades_insert_with_limits"
ON public.trades
FOR INSERT
TO authenticated
WITH CHECK (
  -- Must insert own trade
  user_id = auth.uid()
  AND
  -- Must be under limit (uses can_create_trade function)
  (SELECT public.can_create_trade(auth.uid())) = TRUE
);

COMMENT ON POLICY "trades_insert_with_limits" ON public.trades IS 
'v8.5.10: Enforces ownership AND limits. FREE=10 lifetime, BASIC/TRIAL=25/month, PREMIUM=unlimited';

COMMIT;

-- ===============================================
-- END OF COMPLETE MIGRATION v8.5.10
-- ===============================================

DO $$
BEGIN
  RAISE NOTICE '';
  RAISE NOTICE 'â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—';
  RAISE NOTICE 'â•‘  âœ… COMPLETE MIGRATION v8.5.10 FINISHED!    â•‘';
  RAISE NOTICE 'â•‘     Functions + Triggers + RLS              â•‘';
  RAISE NOTICE 'â•‘     ğŸ”’ ALL CRITICAL BUGS FIXED!             â•‘';
  RAISE NOTICE 'â•‘     ğŸ”¥ WITH SNAPTRADE INTEGRATION!          â•‘';
  RAISE NOTICE 'â•‘     âŒ NO AFFILIATE FEATURES                â•‘';
  RAISE NOTICE 'â•‘     âœ… v9.4.2-SYNCED FIXES APPLIED          â•‘';
  RAISE NOTICE 'â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•';
  RAISE NOTICE '';
  RAISE NOTICE 'ğŸ“Š Summary:';
  RAISE NOTICE '   â€¢ Subscription Functions (7)';
  RAISE NOTICE '   â€¢ Portfolio Functions (1)';
  RAISE NOTICE '   â€¢ TradingView Functions (2)';
  RAISE NOTICE '   â€¢ Admin Functions (8)';
  RAISE NOTICE '   â€¢ Statistics Functions (4)';
  RAISE NOTICE '   â€¢ Impersonation Functions (3)';
  RAISE NOTICE '   â€¢ Activity Tracking (4)';
  RAISE NOTICE '   â€¢ Helper Functions (8)';
  RAISE NOTICE '   â€¢ SnapTrade Functions (5)';
  RAISE NOTICE '   â€¢ Triggers (10)';
  RAISE NOTICE '   â€¢ RLS Policy (1)';
  RAISE NOTICE '';
  RAISE NOTICE 'ğŸ”§ v9.4.2 FIXES APPLIED:';
  RAISE NOTICE '   â€¢ subscription_end_date â†’ subscription_expires_at';
  RAISE NOTICE '   â€¢ Added subscription_cancel_at_period_end';
  RAISE NOTICE '   â€¢ Removed duplicate log_admin_action versions';
  RAISE NOTICE '   â€¢ Removed duplicate search_ticker_symbols versions';
  RAISE NOTICE '   â€¢ Fixed check_subscription_status';
  RAISE NOTICE '   â€¢ Fixed process_expired_subscriptions';
  RAISE NOTICE '   â€¢ Fixed cancel_subscription';
  RAISE NOTICE '   â€¢ Fixed admin_update_subscription';
  RAISE NOTICE '';
  RAISE NOTICE 'âœ¨ Trade Limits:';
  RAISE NOTICE '   â€¢ FREE:    10 trades LIFETIME (no reset)';
  RAISE NOTICE '   â€¢ BASIC:   25 trades/month';
  RAISE NOTICE '   â€¢ TRIAL:   25 trades/month';
  RAISE NOTICE '   â€¢ PREMIUM: Unlimited';
  RAISE NOTICE '';
  RAISE NOTICE 'ğŸ‰ MIGRATION v8.5.10 COMPLETE!';
  RAISE NOTICE '   Total Functions: ~50+';
  RAISE NOTICE '   Total Triggers: 10';
  RAISE NOTICE '   Security Level: MAXIMUM ğŸ”’';
  RAISE NOTICE '';
END $$;