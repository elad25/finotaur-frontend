-- =====================================================
-- FINOTAUR COMPLETE SUBSCRIPTION & WHOP SYSTEM
-- =====================================================
-- Version: 5.0.0 UNIFIED
-- Date: 2025-11-29
-- 
-- üéØ ◊ß◊ï◊ë◊• ◊û◊ê◊ï◊ó◊ì ◊î◊õ◊ï◊ú◊ú:
--    ‚úÖ Whop Integration (v4.1.0)
--    ‚úÖ Subscription Management (v1.0.0)
--    ‚úÖ Affiliate System Complete
--    ‚úÖ Commission & Qualification System
-- 
-- üì¶ ◊™◊ï◊õ◊ü:
--    PART 1: Schema Setup (Columns, Constraints, Tables)
--    PART 2: Indexes
--    PART 3: Helper Functions
--    PART 4: RPC Functions (Frontend)
--    PART 5: Webhook Handlers
--    PART 6: Subscription Management
--    PART 7: Qualification & Cron
--    PART 8: Views
--    PART 9: RLS Policies & Grants
--    PART 10: Data Migration & Fixes
--    PART 11: Verification
-- 
-- ‚ö†Ô∏è ◊î◊®◊• ◊ê◊™ ◊î◊ß◊ï◊ë◊• ◊ë-Supabase SQL Editor
-- =====================================================
-- ============================================
-- PART 0: FIX LEGACY CONSTRAINTS
-- ============================================
-- üî• Must run BEFORE any other changes!

-- Drop problematic constraint that blocks newsletter/top_secret updates
ALTER TABLE profiles DROP CONSTRAINT IF EXISTS check_paid_has_interval;

-- Update account_type constraint to include all valid types
ALTER TABLE profiles DROP CONSTRAINT IF EXISTS profiles_account_type_check;
ALTER TABLE profiles ADD CONSTRAINT profiles_account_type_check 
  CHECK (account_type IS NULL OR account_type IN ('free', 'basic', 'premium', 'trial', 'admin', 'vip', 'newsletter', 'top_secret'));


-- ============================================
-- PART 1: SCHEMA SETUP
-- ============================================

-- ----------------------------------------
-- 1.1 PROFILES TABLE - All Columns
-- ----------------------------------------

DO $$ 
BEGIN
  -- Whop user identification
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'profiles' AND column_name = 'whop_user_id') THEN
    ALTER TABLE profiles ADD COLUMN whop_user_id TEXT;
  END IF;
  
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'profiles' AND column_name = 'whop_membership_id') THEN
    ALTER TABLE profiles ADD COLUMN whop_membership_id TEXT;
  END IF;
  
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'profiles' AND column_name = 'whop_product_id') THEN
    ALTER TABLE profiles ADD COLUMN whop_product_id TEXT;
  END IF;
  
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'profiles' AND column_name = 'whop_plan_id') THEN
    ALTER TABLE profiles ADD COLUMN whop_plan_id TEXT;
  END IF;
  
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'profiles' AND column_name = 'whop_customer_email') THEN
    ALTER TABLE profiles ADD COLUMN whop_customer_email TEXT;
  END IF;
  
  -- Payment provider
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'profiles' AND column_name = 'payment_provider') THEN
    ALTER TABLE profiles ADD COLUMN payment_provider TEXT;
  END IF;
  
  -- Subscription fields
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'profiles' AND column_name = 'subscription_interval') THEN
    ALTER TABLE profiles ADD COLUMN subscription_interval TEXT;
  END IF;
  
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'profiles' AND column_name = 'subscription_started_at') THEN
    ALTER TABLE profiles ADD COLUMN subscription_started_at TIMESTAMPTZ;
  END IF;
  
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'profiles' AND column_name = 'subscription_expires_at') THEN
    ALTER TABLE profiles ADD COLUMN subscription_expires_at TIMESTAMPTZ;
  END IF;
  
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'profiles' AND column_name = 'subscription_cancel_at_period_end') THEN
    ALTER TABLE profiles ADD COLUMN subscription_cancel_at_period_end BOOLEAN DEFAULT FALSE;
    COMMENT ON COLUMN profiles.subscription_cancel_at_period_end IS 'Whether subscription will cancel at period end';
  END IF;
  
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'profiles' AND column_name = 'billing_cycle_start') THEN
    ALTER TABLE profiles ADD COLUMN billing_cycle_start DATE;
  END IF;
  
  -- Subscription management (downgrade/cancel)
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'profiles' AND column_name = 'pending_downgrade_plan') THEN
    ALTER TABLE profiles ADD COLUMN pending_downgrade_plan TEXT;
    COMMENT ON COLUMN profiles.pending_downgrade_plan IS 'Plan to downgrade to at period end (basic, free, or null)';
  END IF;

  IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'profiles' AND column_name = 'cancellation_reason') THEN
    ALTER TABLE profiles ADD COLUMN cancellation_reason TEXT;
    COMMENT ON COLUMN profiles.cancellation_reason IS 'Reason provided when cancelling subscription';
  END IF;

-- Lifetime flag
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'profiles' AND column_name = 'is_lifetime') THEN
    ALTER TABLE profiles ADD COLUMN is_lifetime BOOLEAN DEFAULT FALSE;
    COMMENT ON COLUMN profiles.is_lifetime IS 'TRUE for lifetime accounts where trade limit never resets';
  END IF;

  -- ========================================
  -- üî• PLATFORM SUBSCRIPTION COLUMNS (NEW)
  -- ========================================
  
  -- Platform plan: free, core, pro, enterprise
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'profiles' AND column_name = 'platform_plan') THEN
    ALTER TABLE profiles ADD COLUMN platform_plan TEXT DEFAULT 'free';
  END IF;
  
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'profiles' AND column_name = 'platform_subscription_status') THEN
    ALTER TABLE profiles ADD COLUMN platform_subscription_status TEXT DEFAULT 'inactive';
  END IF;
  
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'profiles' AND column_name = 'platform_billing_interval') THEN
    ALTER TABLE profiles ADD COLUMN platform_billing_interval TEXT;
  END IF;
  
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'profiles' AND column_name = 'platform_subscription_started_at') THEN
    ALTER TABLE profiles ADD COLUMN platform_subscription_started_at TIMESTAMPTZ;
  END IF;
  
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'profiles' AND column_name = 'platform_subscription_expires_at') THEN
    ALTER TABLE profiles ADD COLUMN platform_subscription_expires_at TIMESTAMPTZ;
  END IF;
  
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'profiles' AND column_name = 'platform_cancelled_at') THEN
    ALTER TABLE profiles ADD COLUMN platform_cancelled_at TIMESTAMPTZ;
  END IF;
  
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'profiles' AND column_name = 'platform_trial_ends_at') THEN
    ALTER TABLE profiles ADD COLUMN platform_trial_ends_at TIMESTAMPTZ;
  END IF;
  
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'profiles' AND column_name = 'platform_is_in_trial') THEN
    ALTER TABLE profiles ADD COLUMN platform_is_in_trial BOOLEAN DEFAULT FALSE;
  END IF;
  
  -- üî• ONE-TIME TRIAL TRACKING
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'profiles' AND column_name = 'platform_pro_trial_used_at') THEN
    ALTER TABLE profiles ADD COLUMN platform_pro_trial_used_at TIMESTAMPTZ;
    COMMENT ON COLUMN profiles.platform_pro_trial_used_at IS 'When PRO trial was used - NULL means eligible';
  END IF;
  
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'profiles' AND column_name = 'platform_core_trial_used_at') THEN
    ALTER TABLE profiles ADD COLUMN platform_core_trial_used_at TIMESTAMPTZ;
  END IF;
  
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'profiles' AND column_name = 'platform_cancel_at_period_end') THEN
    ALTER TABLE profiles ADD COLUMN platform_cancel_at_period_end BOOLEAN DEFAULT FALSE;
  END IF;
  
  -- Platform Whop integration
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'profiles' AND column_name = 'platform_whop_user_id') THEN
    ALTER TABLE profiles ADD COLUMN platform_whop_user_id TEXT;
  END IF;
  
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'profiles' AND column_name = 'platform_whop_membership_id') THEN
    ALTER TABLE profiles ADD COLUMN platform_whop_membership_id TEXT;
  END IF;
  
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'profiles' AND column_name = 'platform_whop_product_id') THEN
    ALTER TABLE profiles ADD COLUMN platform_whop_product_id TEXT;
  END IF;
  
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'profiles' AND column_name = 'platform_whop_plan_id') THEN
    ALTER TABLE profiles ADD COLUMN platform_whop_plan_id TEXT;
  END IF;
  
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'profiles' AND column_name = 'platform_whop_customer_email') THEN
    ALTER TABLE profiles ADD COLUMN platform_whop_customer_email TEXT;
  END IF;
  
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'profiles' AND column_name = 'platform_payment_provider') THEN
    ALTER TABLE profiles ADD COLUMN platform_payment_provider TEXT;
  END IF;
  
  -- Bundle tracking
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'profiles' AND column_name = 'platform_bundle_journal_granted') THEN
    ALTER TABLE profiles ADD COLUMN platform_bundle_journal_granted BOOLEAN DEFAULT FALSE;
  END IF;
  
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'profiles' AND column_name = 'platform_bundle_newsletter_granted') THEN
    ALTER TABLE profiles ADD COLUMN platform_bundle_newsletter_granted BOOLEAN DEFAULT FALSE;
  END IF;
  
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'profiles' AND column_name = 'platform_bundle_newsletter_choice') THEN
    ALTER TABLE profiles ADD COLUMN platform_bundle_newsletter_choice TEXT;
  END IF;

END $$;

-- Constraints
ALTER TABLE profiles DROP CONSTRAINT IF EXISTS profiles_account_type_check;
ALTER TABLE profiles ADD CONSTRAINT profiles_account_type_check 
  CHECK (account_type IS NULL OR account_type IN ('free', 'basic', 'premium', 'trial', 'admin', 'vip', 'newsletter', 'top_secret'));

ALTER TABLE profiles DROP CONSTRAINT IF EXISTS profiles_payment_provider_check;
ALTER TABLE profiles ADD CONSTRAINT profiles_payment_provider_check 
  CHECK (payment_provider IS NULL OR payment_provider IN ('payplus', 'stripe', 'paypal', 'whop', 'admin_granted', 'manual'));

-- Platform constraints
ALTER TABLE profiles DROP CONSTRAINT IF EXISTS profiles_platform_plan_check;
ALTER TABLE profiles ADD CONSTRAINT profiles_platform_plan_check 
  CHECK (platform_plan IS NULL OR platform_plan IN ('free', 'core', 'pro', 'enterprise'));

ALTER TABLE profiles DROP CONSTRAINT IF EXISTS profiles_platform_subscription_status_check;
ALTER TABLE profiles ADD CONSTRAINT profiles_platform_subscription_status_check 
  CHECK (platform_subscription_status IS NULL OR platform_subscription_status IN ('active', 'inactive', 'trial', 'past_due', 'cancelled', 'expired'));

ALTER TABLE profiles DROP CONSTRAINT IF EXISTS profiles_platform_billing_interval_check;
ALTER TABLE profiles ADD CONSTRAINT profiles_platform_billing_interval_check 
  CHECK (platform_billing_interval IS NULL OR platform_billing_interval IN ('monthly', 'yearly'));

ALTER TABLE profiles DROP CONSTRAINT IF EXISTS profiles_platform_payment_provider_check;
ALTER TABLE profiles ADD CONSTRAINT profiles_platform_payment_provider_check 
  CHECK (platform_payment_provider IS NULL OR platform_payment_provider IN ('whop', 'stripe', 'manual', 'admin_granted'));

ALTER TABLE profiles DROP CONSTRAINT IF EXISTS profiles_platform_bundle_newsletter_choice_check;
ALTER TABLE profiles ADD CONSTRAINT profiles_platform_bundle_newsletter_choice_check 
  CHECK (platform_bundle_newsletter_choice IS NULL OR platform_bundle_newsletter_choice IN ('included', 'discounted', 'declined'));
-- ----------------------------------------
-- 1.2 AFFILIATE_REFERRALS TABLE - Whop Columns
-- ----------------------------------------

DO $$ 
BEGIN
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'affiliate_referrals' AND column_name = 'whop_membership_id') THEN
    ALTER TABLE affiliate_referrals ADD COLUMN whop_membership_id TEXT;
  END IF;
  
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'affiliate_referrals' AND column_name = 'whop_user_id') THEN
    ALTER TABLE affiliate_referrals ADD COLUMN whop_user_id TEXT;
  END IF;
  
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'affiliate_referrals' AND column_name = 'whop_product_id') THEN
    ALTER TABLE affiliate_referrals ADD COLUMN whop_product_id TEXT;
  END IF;
  
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'affiliate_referrals' AND column_name = 'coupon_code_used') THEN
    ALTER TABLE affiliate_referrals ADD COLUMN coupon_code_used TEXT;
  END IF;
  
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'affiliate_referrals' AND column_name = 'total_payments_usd') THEN
    ALTER TABLE affiliate_referrals ADD COLUMN total_payments_usd NUMERIC(12,2) DEFAULT 0;
  END IF;
  
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'affiliate_referrals' AND column_name = 'commission_earned_usd') THEN
    ALTER TABLE affiliate_referrals ADD COLUMN commission_earned_usd NUMERIC(12,2) DEFAULT 0;
  END IF;
END $$;


-- ----------------------------------------
-- 1.3 AFFILIATES TABLE - Additional Columns
-- ----------------------------------------

DO $$ 
BEGIN
  -- Notification settings
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'affiliates' AND column_name = 'notify_on_signup') THEN
    ALTER TABLE affiliates ADD COLUMN notify_on_signup BOOLEAN DEFAULT TRUE;
  END IF;
  
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'affiliates' AND column_name = 'notify_on_qualification') THEN
    ALTER TABLE affiliates ADD COLUMN notify_on_qualification BOOLEAN DEFAULT TRUE;
  END IF;
  
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'affiliates' AND column_name = 'notify_on_commission') THEN
    ALTER TABLE affiliates ADD COLUMN notify_on_commission BOOLEAN DEFAULT TRUE;
  END IF;
  
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'affiliates' AND column_name = 'notify_on_payout') THEN
    ALTER TABLE affiliates ADD COLUMN notify_on_payout BOOLEAN DEFAULT TRUE;
  END IF;
  
  -- Referral link
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'affiliates' AND column_name = 'referral_link') THEN
    ALTER TABLE affiliates ADD COLUMN referral_link TEXT;
  END IF;
  
  -- Last activity
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'affiliates' AND column_name = 'last_activity_at') THEN
    ALTER TABLE affiliates ADD COLUMN last_activity_at TIMESTAMPTZ DEFAULT NOW();
  END IF;
END $$;

-- Update referral links for existing affiliates
UPDATE affiliates 
SET referral_link = 'https://finotaur.com/?ref=' || affiliate_code
WHERE referral_link IS NULL AND affiliate_code IS NOT NULL;



-- ----------------------------------------
-- 1.5 WHOP PLAN MAPPING TABLE
-- ----------------------------------------

CREATE TABLE IF NOT EXISTS whop_plan_mapping (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  whop_product_id TEXT UNIQUE NOT NULL,
  whop_plan_id TEXT,
  finotaur_plan TEXT NOT NULL,
  billing_interval TEXT NOT NULL CHECK (billing_interval IN ('monthly', 'yearly')),
  price_usd NUMERIC(10,2) NOT NULL,
  max_trades INTEGER NOT NULL,
  display_name TEXT,
  is_active BOOLEAN DEFAULT TRUE,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

--- Add trial_days column if missing (must be BEFORE the INSERT)
DO $$ 
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns 
    WHERE table_name = 'whop_plan_mapping' AND column_name = 'trial_days'
  ) THEN
    ALTER TABLE whop_plan_mapping ADD COLUMN trial_days INTEGER DEFAULT 0;
  END IF;
END $$;

-- Insert/Update plan mappings
INSERT INTO whop_plan_mapping (whop_product_id, finotaur_plan, billing_interval, price_usd, max_trades, display_name, is_active, trial_days) VALUES
('prod_ZaDN418HLst3r', 'basic', 'monthly', 19.99, 25, 'Finotaur Basic Monthly', TRUE, 14),
('prod_bPwSoYGedsbyh', 'basic', 'yearly', 149.00, 25, 'Finotaur Basic Yearly', TRUE, 14),
('prod_Kq2pmLT1JyGsU', 'premium', 'monthly', 39.99, -1, 'Finotaur Premium Monthly', TRUE, 0),
('prod_vON7zlda6iuII', 'premium', 'yearly', 299.00, -1, 'Finotaur Premium Yearly', TRUE, 0)
ON CONFLICT (whop_product_id) DO UPDATE SET
  finotaur_plan = EXCLUDED.finotaur_plan,
  billing_interval = EXCLUDED.billing_interval,
  price_usd = EXCLUDED.price_usd,
  max_trades = EXCLUDED.max_trades,
  display_name = EXCLUDED.display_name,
  is_active = TRUE,
  updated_at = NOW();


-- ----------------------------------------
-- 1.6 WHOP WEBHOOK LOG TABLE
-- ----------------------------------------

CREATE TABLE IF NOT EXISTS whop_webhook_log (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  event_id TEXT UNIQUE,
  event_type TEXT,
  payload JSONB,
  processed BOOLEAN DEFAULT FALSE,
  processing_result JSONB,
  error_message TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  processed_at TIMESTAMPTZ,
  -- üî• NEW: Required by webhook handler v3.4.0
  whop_user_id TEXT,
  whop_membership_id TEXT,
  whop_product_id TEXT,
  metadata JSONB DEFAULT '{}'
);

-- Add columns if table already exists
DO $$ 
BEGIN
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'whop_webhook_log' AND column_name = 'whop_user_id') THEN
    ALTER TABLE whop_webhook_log ADD COLUMN whop_user_id TEXT;
  END IF;
  
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'whop_webhook_log' AND column_name = 'whop_membership_id') THEN
    ALTER TABLE whop_webhook_log ADD COLUMN whop_membership_id TEXT;
  END IF;
  
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'whop_webhook_log' AND column_name = 'whop_product_id') THEN
    ALTER TABLE whop_webhook_log ADD COLUMN whop_product_id TEXT;
  END IF;
  
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'whop_webhook_log' AND column_name = 'metadata') THEN
    ALTER TABLE whop_webhook_log ADD COLUMN metadata JSONB DEFAULT '{}';
  END IF;
END $$;

-- ----------------------------------------
-- 1.6.5 PLATFORM PLAN MAPPING TABLE (NEW)
-- ----------------------------------------

CREATE TABLE IF NOT EXISTS platform_plan_mapping (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  whop_plan_id TEXT NOT NULL UNIQUE,
  whop_product_id TEXT NOT NULL,
  finotaur_plan TEXT NOT NULL CHECK (finotaur_plan IN ('core', 'pro', 'enterprise')),
  billing_interval TEXT NOT NULL CHECK (billing_interval IN ('monthly', 'yearly')),
  price_usd DECIMAL(10,2) NOT NULL,
  trial_days INTEGER DEFAULT 0,
  trial_once_only BOOLEAN DEFAULT FALSE,
  includes_journal TEXT DEFAULT NULL,
  includes_newsletter TEXT DEFAULT NULL,
  is_active BOOLEAN DEFAULT TRUE,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Insert platform plan mappings (UPDATE WITH REAL WHOP IDs!)
INSERT INTO platform_plan_mapping (
  whop_plan_id, whop_product_id, finotaur_plan, billing_interval, 
  price_usd, trial_days, trial_once_only, includes_journal, includes_newsletter
) VALUES 
  ('plan_PLATFORM_CORE_MONTHLY', 'prod_PLATFORM_CORE_MONTHLY', 'core', 'monthly', 39.00, 7, FALSE, NULL, NULL),
  ('plan_PLATFORM_CORE_YEARLY', 'prod_PLATFORM_CORE_YEARLY', 'core', 'yearly', 349.00, 7, FALSE, NULL, NULL),
  ('plan_PLATFORM_PRO_MONTHLY', 'prod_PLATFORM_PRO_MONTHLY', 'pro', 'monthly', 69.00, 14, TRUE, 'premium', 'choice'),
  ('plan_PLATFORM_PRO_YEARLY', 'prod_PLATFORM_PRO_YEARLY', 'pro', 'yearly', 619.00, 14, TRUE, 'premium', 'choice'),
  ('plan_PLATFORM_ENTERPRISE', 'prod_PLATFORM_ENTERPRISE', 'enterprise', 'monthly', 0.00, 0, FALSE, 'premium', 'included')
ON CONFLICT (whop_plan_id) DO UPDATE SET
  whop_product_id = EXCLUDED.whop_product_id,
  finotaur_plan = EXCLUDED.finotaur_plan,
  billing_interval = EXCLUDED.billing_interval,
  price_usd = EXCLUDED.price_usd,
  trial_days = EXCLUDED.trial_days,
  trial_once_only = EXCLUDED.trial_once_only,
  includes_journal = EXCLUDED.includes_journal,
  includes_newsletter = EXCLUDED.includes_newsletter,
  updated_at = NOW();


-- ----------------------------------------
-- 1.6.6 PLATFORM BUNDLE BENEFITS TABLE (NEW)
-- ----------------------------------------

CREATE TABLE IF NOT EXISTS platform_bundle_benefits (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  platform_plan TEXT NOT NULL CHECK (platform_plan IN ('core', 'pro', 'enterprise')),
  benefit_type TEXT NOT NULL,
  benefit_value TEXT NOT NULL,
  is_active BOOLEAN DEFAULT TRUE,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  UNIQUE(platform_plan, benefit_type)
);

INSERT INTO platform_bundle_benefits (platform_plan, benefit_type, benefit_value) VALUES
  ('pro', 'journal_plan', 'premium'),
  ('pro', 'newsletter_choice', 'true'),
  ('enterprise', 'journal_plan', 'premium'),
  ('enterprise', 'newsletter_included', 'true'),
  ('enterprise', 'top_secret_included', 'true')
ON CONFLICT (platform_plan, benefit_type) DO UPDATE SET
  benefit_value = EXCLUDED.benefit_value,
  is_active = TRUE;


-- ----------------------------------------
-- 1.6.7 PLATFORM WEBHOOK LOG TABLE (NEW)
-- ----------------------------------------

CREATE TABLE IF NOT EXISTS platform_webhook_log (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  event_id TEXT NOT NULL UNIQUE,
  event_type TEXT NOT NULL,
  whop_user_id TEXT,
  whop_membership_id TEXT,
  whop_product_id TEXT,
  whop_plan_id TEXT,
  user_id UUID REFERENCES profiles(id),
  user_email TEXT,
  payload JSONB NOT NULL,
  processed BOOLEAN DEFAULT FALSE,
  processing_result TEXT,
  error_message TEXT,
  processed_at TIMESTAMPTZ,
  metadata JSONB DEFAULT '{}',
  finotaur_user_id TEXT,
  subscription_category TEXT,
  affiliate_code TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_platform_webhook_log_event_id ON platform_webhook_log(event_id);
CREATE INDEX IF NOT EXISTS idx_platform_webhook_log_event_type ON platform_webhook_log(event_type);
CREATE INDEX IF NOT EXISTS idx_platform_webhook_log_whop_membership_id ON platform_webhook_log(whop_membership_id);
CREATE INDEX IF NOT EXISTS idx_platform_webhook_log_user_id ON platform_webhook_log(user_id);
CREATE INDEX IF NOT EXISTS idx_platform_webhook_log_created_at ON platform_webhook_log(created_at);


-- ----------------------------------------
-- 1.6.8 PLATFORM SUBSCRIPTION EVENTS TABLE (NEW)
-- ----------------------------------------

CREATE TABLE IF NOT EXISTS platform_subscription_events (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES profiles(id),
  event_type TEXT NOT NULL,
  old_plan TEXT,
  new_plan TEXT,
  reason TEXT,
  metadata JSONB DEFAULT '{}',
  created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_platform_events_user_id ON platform_subscription_events(user_id);
CREATE INDEX IF NOT EXISTS idx_platform_events_event_type ON platform_subscription_events(event_type);
CREATE INDEX IF NOT EXISTS idx_platform_events_created_at ON platform_subscription_events(created_at);
-- ----------------------------------------
-- 1.7 SUBSCRIPTION_EVENTS TABLE (Audit)
-- ----------------------------------------

CREATE TABLE IF NOT EXISTS subscription_events (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  event_type TEXT NOT NULL,
  old_plan TEXT,
  new_plan TEXT,
  reason TEXT,
  scheduled_at TIMESTAMPTZ,
  processed_at TIMESTAMPTZ,
  metadata JSONB DEFAULT '{}',
  created_at TIMESTAMPTZ DEFAULT NOW(),
  
  CONSTRAINT valid_event_type CHECK (
    event_type IN (
      'upgrade',
      'downgrade',
      'downgrade_scheduled',
      'cancel_scheduled',
      'cancelled',
      'reactivated',
      'payment_failed',
      'payment_succeeded',
      'trial_started',
      'trial_ended'
    )
  )
);


-- ============================================
-- PART 2: INDEXES
-- ============================================

-- Profiles indexes
CREATE INDEX IF NOT EXISTS idx_profiles_whop_user_id ON profiles(whop_user_id) WHERE whop_user_id IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_profiles_whop_membership_id ON profiles(whop_membership_id) WHERE whop_membership_id IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_profiles_payment_provider ON profiles(payment_provider) WHERE payment_provider IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_profiles_account_type ON profiles(account_type);
CREATE INDEX IF NOT EXISTS idx_profiles_subscription_status ON profiles(subscription_status);
CREATE INDEX IF NOT EXISTS idx_profiles_email_lower ON profiles(LOWER(email));
CREATE INDEX IF NOT EXISTS idx_profiles_pending_downgrade ON profiles(pending_downgrade_plan) WHERE pending_downgrade_plan IS NOT NULL;

-- Affiliate referrals indexes
CREATE INDEX IF NOT EXISTS idx_referrals_whop_membership ON affiliate_referrals(whop_membership_id) WHERE whop_membership_id IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_referrals_whop_user ON affiliate_referrals(whop_user_id) WHERE whop_user_id IS NOT NULL;

-- Affiliate clicks indexes
CREATE INDEX IF NOT EXISTS idx_affiliate_clicks_affiliate_id ON affiliate_clicks(affiliate_id);
CREATE INDEX IF NOT EXISTS idx_affiliate_clicks_created_at ON affiliate_clicks(created_at DESC);
CREATE INDEX IF NOT EXISTS idx_affiliate_clicks_ip_hash ON affiliate_clicks(ip_hash);
CREATE INDEX IF NOT EXISTS idx_affiliate_clicks_converted ON affiliate_clicks(converted) WHERE converted = TRUE;

-- Webhook log indexes
CREATE INDEX IF NOT EXISTS idx_whop_webhook_log_event_id ON whop_webhook_log(event_id) WHERE event_id IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_whop_webhook_log_event_type ON whop_webhook_log(event_type);
CREATE INDEX IF NOT EXISTS idx_whop_webhook_log_created ON whop_webhook_log(created_at DESC);

-- Subscription events indexes
CREATE INDEX IF NOT EXISTS idx_subscription_events_user_id ON subscription_events(user_id);
CREATE INDEX IF NOT EXISTS idx_subscription_events_type ON subscription_events(event_type);
CREATE INDEX IF NOT EXISTS idx_subscription_events_scheduled ON subscription_events(scheduled_at) WHERE processed_at IS NULL;
CREATE INDEX IF NOT EXISTS idx_subscription_events_created ON subscription_events(created_at DESC);

-- Platform indexes
CREATE INDEX IF NOT EXISTS idx_profiles_platform_plan ON profiles(platform_plan);
CREATE INDEX IF NOT EXISTS idx_profiles_platform_subscription_status ON profiles(platform_subscription_status);
CREATE INDEX IF NOT EXISTS idx_profiles_platform_whop_membership_id ON profiles(platform_whop_membership_id);
CREATE INDEX IF NOT EXISTS idx_profiles_platform_expires_at ON profiles(platform_subscription_expires_at);


-- ============================================
-- PART 3: HELPER FUNCTIONS
-- ============================================

-- ----------------------------------------
-- 3.1 Get Commission Rate
-- ----------------------------------------

DROP FUNCTION IF EXISTS get_commission_rate(TEXT, TEXT);

CREATE OR REPLACE FUNCTION get_commission_rate(
  p_tier TEXT,
  p_subscription_type TEXT DEFAULT 'monthly'
)
RETURNS NUMERIC
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_config_rates JSONB;
  v_annual_rate NUMERIC;
  v_rate NUMERIC;
BEGIN
  -- For yearly subscriptions: fixed 15%
  IF p_subscription_type = 'yearly' THEN
    SELECT (config_value->>'rate')::numeric INTO v_annual_rate
    FROM affiliate_config
    WHERE config_key = 'annual_commission_rate';
    
    RETURN COALESCE(v_annual_rate, 0.15);
  END IF;
  
  -- For monthly: get from tier config
  SELECT config_value INTO v_config_rates
  FROM affiliate_config
  WHERE config_key = 'commission_rates';
  
  IF v_config_rates IS NOT NULL THEN
    v_rate := (v_config_rates->p_tier->>'rate')::numeric;
  END IF;
  
  -- Defaults if config not found
  IF v_rate IS NULL THEN
    v_rate := CASE p_tier
      WHEN 'tier_3' THEN 0.20
      WHEN 'tier_2' THEN 0.15
      ELSE 0.10  -- tier_1 default
    END;
  END IF;
  
  RETURN v_rate;
END;
$$;


-- ----------------------------------------
-- 3.2 Get Finotaur Plan from Whop Product ID
-- ----------------------------------------

DROP FUNCTION IF EXISTS get_finotaur_plan_from_whop(TEXT);

CREATE OR REPLACE FUNCTION get_finotaur_plan_from_whop(p_whop_product_id TEXT)
RETURNS TABLE (
  finotaur_plan TEXT,
  billing_interval TEXT,
  price_usd NUMERIC,
  max_trades INTEGER,
  display_name TEXT
)
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  RETURN QUERY
  SELECT 
    wpm.finotaur_plan, 
    wpm.billing_interval, 
    wpm.price_usd, 
    CASE WHEN wpm.max_trades = -1 THEN 999999 ELSE wpm.max_trades END as max_trades,
    wpm.display_name
  FROM whop_plan_mapping wpm
  WHERE wpm.whop_product_id = p_whop_product_id 
    AND wpm.is_active = TRUE;
END;
$$;
-- ----------------------------------------
-- 3.3 Get Product Trial Days (DYNAMIC)
-- ----------------------------------------

CREATE OR REPLACE FUNCTION get_product_trial_days(p_product_id TEXT)
RETURNS INTEGER
LANGUAGE plpgsql
STABLE
AS $$
BEGIN
  RETURN COALESCE(
    (SELECT trial_days FROM whop_plan_mapping 
     WHERE whop_product_id = p_product_id AND is_active = TRUE),
    0
  );
END;
$$;
-- ----------------------------------------
-- 4.3 Track Referral Signup
-- (Used by useAffiliate.ts - trackReferralSignup)
-- ----------------------------------------

DROP FUNCTION IF EXISTS track_referral_signup(TEXT, UUID, TEXT, TEXT, TEXT, TEXT, NUMERIC, UUID, NUMERIC, NUMERIC);

CREATE OR REPLACE FUNCTION track_referral_signup(
  p_affiliate_code TEXT,
  p_user_id UUID,
  p_user_email TEXT,
  p_subscription_id TEXT DEFAULT NULL,
  p_subscription_plan TEXT DEFAULT NULL,
  p_subscription_type TEXT DEFAULT 'monthly',
  p_subscription_price NUMERIC DEFAULT NULL,
  p_click_id UUID DEFAULT NULL,
  p_discount_percent NUMERIC DEFAULT 0,
  p_discount_amount NUMERIC DEFAULT 0
)
RETURNS UUID
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_affiliate RECORD;
  v_referral_id UUID;
  v_existing_referral UUID;
BEGIN
  SELECT * INTO v_affiliate
  FROM affiliates
  WHERE (UPPER(affiliate_code) = UPPER(p_affiliate_code) OR UPPER(coupon_code) = UPPER(p_affiliate_code))
    AND status = 'active';
  
  IF v_affiliate IS NULL OR v_affiliate.user_id = p_user_id THEN
    RETURN NULL;  -- Not found or self-referral
  END IF;
  
  -- Check for existing referral
  SELECT id INTO v_existing_referral FROM affiliate_referrals WHERE referred_user_id = p_user_id;
  
  IF v_existing_referral IS NOT NULL THEN
    UPDATE affiliate_referrals SET
      subscription_id = COALESCE(p_subscription_id, subscription_id),
      subscription_plan = COALESCE(p_subscription_plan, subscription_plan),
      subscription_type = COALESCE(p_subscription_type, subscription_type),
      subscription_price_usd = COALESCE(p_subscription_price, subscription_price_usd),
      updated_at = NOW()
    WHERE id = v_existing_referral;
    RETURN v_existing_referral;
  END IF;
  
  -- Create new referral
  INSERT INTO affiliate_referrals (
    affiliate_id, referred_user_id, referred_user_email, click_id, signup_date, signup_plan,
    discount_percent, discount_amount_usd, subscription_id, subscription_plan, subscription_type,
    subscription_price_usd, status, commission_eligible
  ) VALUES (
    v_affiliate.id, p_user_id, p_user_email, p_click_id, NOW(), COALESCE(p_subscription_plan, 'free'),
    COALESCE(p_discount_percent, 0), COALESCE(p_discount_amount, 0), p_subscription_id, p_subscription_plan,
    p_subscription_type, p_subscription_price, 'pending', TRUE
  )
  RETURNING id INTO v_referral_id;
  
  -- Update click if provided
  IF p_click_id IS NOT NULL THEN
    UPDATE affiliate_clicks SET converted = TRUE, converted_at = NOW(), referral_id = v_referral_id
    WHERE id = p_click_id;
  END IF;
  
  -- Update affiliate stats & log
  UPDATE affiliates SET total_signups = COALESCE(total_signups, 0) + 1, last_activity_at = NOW()
  WHERE id = v_affiliate.id;
  
  INSERT INTO affiliate_activity_log (affiliate_id, activity_type, description, metadata, is_system_action)
  VALUES (v_affiliate.id, 'new_signup', 'New signup: ' || p_user_email,
    jsonb_build_object('user_email', p_user_email, 'plan', p_subscription_plan, 'type', p_subscription_type, 'click_id', p_click_id), TRUE);
  
  RETURN v_referral_id;
END;
$$;

-- ----------------------------------------
-- 4.6 Get Subscription Cancellation Status
-- ----------------------------------------

DROP FUNCTION IF EXISTS get_subscription_cancellation_status(UUID);

CREATE OR REPLACE FUNCTION get_subscription_cancellation_status(p_user_id UUID)
RETURNS TABLE (
  is_pending_cancellation BOOLEAN,
  pending_downgrade_plan TEXT,
  expires_at TIMESTAMPTZ,
  current_plan TEXT,
  cancellation_reason TEXT
)
LANGUAGE plpgsql
STABLE
SECURITY DEFINER
AS $$
BEGIN
  RETURN QUERY
  SELECT 
    COALESCE(p.subscription_cancel_at_period_end, FALSE),
    p.pending_downgrade_plan,
    p.subscription_expires_at,
    p.account_type,
    p.cancellation_reason
  FROM profiles p WHERE p.id = p_user_id;
END;
$$;


-- ============================================
-- PART 5: WEBHOOK HANDLERS
-- ============================================
-- ============================================
-- PART 5.1: ACTIVATE WHOP SUBSCRIPTION
-- ============================================
-- Version: 7.0.0 PRODUCTION READY
-- Date: 2025-12-19
-- 
-- üî• FIX: Added p_finotaur_user_id parameter
-- üî• FIX: Multi-method user lookup (finotaur_id ‚Üí email ‚Üí membership)
-- üî• FIX: Retry logic for race conditions
-- üî• FIX: Removed auto-create (FK constraint to auth.users)
-- ============================================

-- Drop ALL old signatures to avoid conflicts
DROP FUNCTION IF EXISTS activate_whop_subscription(TEXT, TEXT, TEXT, TEXT, TEXT, UUID);
DROP FUNCTION IF EXISTS activate_whop_subscription(TEXT, TEXT, TEXT, TEXT, TEXT, TEXT);
DROP FUNCTION IF EXISTS activate_whop_subscription(TEXT, TEXT, TEXT, TEXT, TEXT, TEXT, UUID);

CREATE OR REPLACE FUNCTION activate_whop_subscription(
  p_user_email TEXT,
  p_whop_user_id TEXT,
  p_whop_membership_id TEXT,
  p_whop_product_id TEXT,
  p_finotaur_user_id TEXT DEFAULT NULL,    -- üî• From checkout metadata
  p_affiliate_code TEXT DEFAULT NULL,
  p_click_id UUID DEFAULT NULL
)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_user_id UUID;
  v_plan_info RECORD;
  v_subscription_ends_at TIMESTAMPTZ;
  v_max_trades INTEGER;
  v_affiliate_id UUID;
  v_referral_id UUID;
  v_retry_count INTEGER := 0;
  v_lookup_method TEXT := 'none';
  v_old_plan TEXT;
BEGIN
  -- ========================================
  -- STEP 1: Find User (MULTIPLE METHODS)
  -- Priority: finotaur_user_id ‚Üí email ‚Üí whop_customer_email ‚Üí membership_id ‚Üí retry
  -- ========================================
  
  -- Method 1: Try finotaur_user_id from metadata (BEST - user logged in during checkout)
  IF p_finotaur_user_id IS NOT NULL AND p_finotaur_user_id != '' THEN
    BEGIN
      SELECT id INTO v_user_id 
      FROM profiles 
      WHERE id = p_finotaur_user_id::UUID;
      
      IF v_user_id IS NOT NULL THEN
        v_lookup_method := 'finotaur_user_id';
        RAISE NOTICE '‚úÖ Found user by finotaur_user_id: %', v_user_id;
      END IF;
    EXCEPTION WHEN OTHERS THEN
      RAISE NOTICE '‚ö†Ô∏è Invalid finotaur_user_id format: %', p_finotaur_user_id;
    END;
  END IF;
  
  -- Method 2: Try exact email match (user registered with same email)
  IF v_user_id IS NULL AND p_user_email IS NOT NULL AND p_user_email != '' THEN
    SELECT id INTO v_user_id 
    FROM profiles 
    WHERE LOWER(email) = LOWER(p_user_email);
    
    IF v_user_id IS NOT NULL THEN
      v_lookup_method := 'email_exact';
      RAISE NOTICE '‚úÖ Found user by email: %', v_user_id;
    END IF;
  END IF;
  
  -- Method 3: Try whop_customer_email (returning customer with different Whop email)
  IF v_user_id IS NULL AND p_user_email IS NOT NULL AND p_user_email != '' THEN
    SELECT id INTO v_user_id 
    FROM profiles 
    WHERE LOWER(whop_customer_email) = LOWER(p_user_email);
    
    IF v_user_id IS NOT NULL THEN
      v_lookup_method := 'whop_customer_email';
      RAISE NOTICE '‚úÖ Found user by whop_customer_email: %', v_user_id;
    END IF;
  END IF;
  
  -- Method 4: Try membership_id (renewal/reactivation of existing subscription)
  IF v_user_id IS NULL AND p_whop_membership_id IS NOT NULL THEN
    SELECT id INTO v_user_id 
    FROM profiles 
    WHERE whop_membership_id = p_whop_membership_id;
    
    IF v_user_id IS NOT NULL THEN
      v_lookup_method := 'whop_membership_id';
      RAISE NOTICE '‚úÖ Found user by membership_id: %', v_user_id;
    END IF;
  END IF;
  
  -- Method 5: Retry with delay (race condition - user might be registering right now)
  IF v_user_id IS NULL AND p_user_email IS NOT NULL AND p_user_email != '' THEN
    LOOP
      EXIT WHEN v_retry_count >= 3;  -- Max 3 retries = 6 seconds total
      
      v_retry_count := v_retry_count + 1;
      RAISE NOTICE '‚è≥ User not found, retry % of 3 in 2 seconds...', v_retry_count;
      PERFORM pg_sleep(2);
      
      -- Try all methods again after delay
      SELECT id INTO v_user_id 
      FROM profiles 
      WHERE LOWER(email) = LOWER(p_user_email)
         OR LOWER(whop_customer_email) = LOWER(p_user_email);
      
      EXIT WHEN v_user_id IS NOT NULL;
    END LOOP;
    
    IF v_user_id IS NOT NULL THEN
      v_lookup_method := 'email_retry_' || v_retry_count;
      RAISE NOTICE '‚úÖ Found user after % retries: %', v_retry_count, v_user_id;
    END IF;
  END IF;
  
  -- ========================================
  -- STEP 2: User NOT found = Return Error
  -- (Cannot auto-create due to FK constraint to auth.users)
  -- ========================================
  
  IF v_user_id IS NULL THEN
    RETURN jsonb_build_object(
      'success', false, 
      'error', 'User not found. User must register on Finotaur before purchasing.',
      'error_code', 'USER_NOT_FOUND',
      'lookup_attempted', jsonb_build_object(
        'finotaur_user_id', p_finotaur_user_id,
        'email', p_user_email,
        'membership_id', p_whop_membership_id
      ),
      'retries', v_retry_count,
      'suggestion', 'Ensure checkout URL includes finotaur_user_id in metadata, or user registers with same email before purchase'
    );
  END IF;
  
  -- ========================================
  -- STEP 3: Get Plan Info from Mapping
  -- ========================================
  
  SELECT * INTO v_plan_info 
  FROM whop_plan_mapping 
  WHERE whop_product_id = p_whop_product_id AND is_active = TRUE;
  
  IF v_plan_info IS NULL THEN
    RETURN jsonb_build_object(
      'success', false, 
      'error', 'Unknown Whop product ID: ' || p_whop_product_id,
      'error_code', 'UNKNOWN_PRODUCT',
      'user_id', v_user_id,
      'lookup_method', v_lookup_method
    );
  END IF;
  
  -- Calculate subscription end date
-- Calculate subscription end date (accounting for trial period)
  v_subscription_ends_at := CASE 
    WHEN COALESCE(v_plan_info.trial_days, 0) > 0 THEN NOW() + (v_plan_info.trial_days || ' days')::INTERVAL
    WHEN v_plan_info.billing_interval = 'monthly' THEN NOW() + INTERVAL '1 month' 
    ELSE NOW() + INTERVAL '1 year' 
  END;
  
  -- Calculate max trades (-1 means unlimited)
  v_max_trades := CASE 
    WHEN v_plan_info.max_trades = -1 THEN 999999 
    ELSE v_plan_info.max_trades 
  END;
  
  -- Get old plan for logging
  SELECT account_type INTO v_old_plan FROM profiles WHERE id = v_user_id;
  
  -- ========================================
  -- STEP 4: Update User Profile
  -- ========================================
  
  UPDATE profiles SET
    -- Subscription info
    account_type = v_plan_info.finotaur_plan,
    subscription_status = 'active',
    subscription_interval = v_plan_info.billing_interval,
    subscription_started_at = COALESCE(subscription_started_at, NOW()),
    subscription_expires_at = v_subscription_ends_at,
    subscription_cancel_at_period_end = FALSE,
    pending_downgrade_plan = NULL,
    cancellation_reason = NULL,
    -- Whop identifiers
    whop_user_id = p_whop_user_id,
    whop_membership_id = p_whop_membership_id,
    whop_product_id = p_whop_product_id,
    whop_customer_email = p_user_email,
    -- Payment info
    payment_provider = 'whop',
    -- Trade limits
    max_trades = v_max_trades,
    current_month_trades_count = 0,
    billing_cycle_start = CURRENT_DATE,
    -- Timestamp
    updated_at = NOW()
  WHERE id = v_user_id;
  
  -- ========================================
  -- STEP 5: Log Subscription Event
  -- ========================================
  
  INSERT INTO subscription_events (
    user_id, event_type, old_plan, new_plan, metadata
  ) VALUES (
    v_user_id,
    'payment_succeeded',
    COALESCE(v_old_plan, 'free'),
    v_plan_info.finotaur_plan,
    jsonb_build_object(
      'whop_membership_id', p_whop_membership_id,
      'whop_product_id', p_whop_product_id,
      'whop_user_id', p_whop_user_id,
      'lookup_method', v_lookup_method,
      'retries_needed', v_retry_count,
      'finotaur_user_id_provided', p_finotaur_user_id IS NOT NULL,
      'price_usd', v_plan_info.price_usd
    )
  );
  
  -- ========================================
  -- STEP 6: Process Affiliate if Provided
  -- ========================================
  
  IF p_affiliate_code IS NOT NULL AND p_affiliate_code != '' THEN
    -- Find affiliate by code or coupon
    SELECT id INTO v_affiliate_id FROM affiliates
    WHERE (UPPER(affiliate_code) = UPPER(p_affiliate_code) OR UPPER(coupon_code) = UPPER(p_affiliate_code)) 
      AND status = 'active';
    
    IF v_affiliate_id IS NOT NULL THEN
      -- Check for existing referral
      SELECT id INTO v_referral_id FROM affiliate_referrals WHERE referred_user_id = v_user_id;
      
      IF v_referral_id IS NOT NULL THEN
        -- Update existing referral
        UPDATE affiliate_referrals SET
          whop_membership_id = p_whop_membership_id,
          whop_user_id = p_whop_user_id,
          whop_product_id = p_whop_product_id,
          subscription_plan = v_plan_info.finotaur_plan,
          subscription_type = v_plan_info.billing_interval,
          subscription_price_usd = v_plan_info.price_usd,
          subscription_started_at = NOW(),
          coupon_code_used = p_affiliate_code,
          updated_at = NOW()
        WHERE id = v_referral_id;
      ELSE
        -- Create new referral
        INSERT INTO affiliate_referrals (
          affiliate_id, referred_user_id, referred_user_email, click_id, 
          signup_date, signup_plan, coupon_code_used,
          whop_membership_id, whop_user_id, whop_product_id, 
          subscription_plan, subscription_type, subscription_price_usd, 
          subscription_started_at, status, commission_eligible
        ) VALUES (
          v_affiliate_id, v_user_id, p_user_email, p_click_id, 
          NOW(), v_plan_info.finotaur_plan, p_affiliate_code,
          p_whop_membership_id, p_whop_user_id, p_whop_product_id, 
          v_plan_info.finotaur_plan, v_plan_info.billing_interval, v_plan_info.price_usd, 
          NOW(), 'pending', TRUE
        )
        RETURNING id INTO v_referral_id;
        
        -- Update affiliate stats
        UPDATE affiliates SET 
          total_signups = COALESCE(total_signups, 0) + 1, 
          last_activity_at = NOW(), 
          updated_at = NOW()
        WHERE id = v_affiliate_id;
        
        -- Log activity
        INSERT INTO affiliate_activity_log (affiliate_id, activity_type, description, metadata, is_system_action)
        VALUES (v_affiliate_id, 'new_signup', 
          'New signup via Whop: ' || p_user_email || ' (' || v_plan_info.finotaur_plan || ')',
          jsonb_build_object(
            'user_email', p_user_email, 
            'plan', v_plan_info.finotaur_plan, 
            'interval', v_plan_info.billing_interval,
            'price_usd', v_plan_info.price_usd,
            'coupon_code', p_affiliate_code
          ), 
          TRUE
        );
      END IF;
    END IF;
  END IF;
  
  -- ========================================
  -- STEP 7: Return Success Result
  -- ========================================
  
  RETURN jsonb_build_object(
    'success', true, 
    'user_id', v_user_id, 
    'email', p_user_email,
    'plan', v_plan_info.finotaur_plan,
    'interval', v_plan_info.billing_interval, 
    'price_usd', v_plan_info.price_usd,
    'expires_at', v_subscription_ends_at,
    'max_trades', v_max_trades,
    'lookup_method', v_lookup_method,
    'retries_needed', v_retry_count,
    'affiliate_id', v_affiliate_id, 
    'referral_id', v_referral_id,
    'old_plan', v_old_plan
  );
  
EXCEPTION WHEN OTHERS THEN
  RETURN jsonb_build_object(
    'success', false, 
    'error', SQLERRM,
    'sqlstate', SQLSTATE,
    'email', p_user_email,
    'finotaur_user_id', p_finotaur_user_id,
    'lookup_method', v_lookup_method,
    'retries', v_retry_count
  );
END;
$$;

-- ============================================
-- GRANTS
-- ============================================

GRANT EXECUTE ON FUNCTION activate_whop_subscription(TEXT, TEXT, TEXT, TEXT, TEXT, TEXT, UUID) TO service_role;
GRANT EXECUTE ON FUNCTION activate_whop_subscription(TEXT, TEXT, TEXT, TEXT, TEXT, TEXT, UUID) TO authenticated;

-- ============================================
-- VERIFICATION
-- ============================================

SELECT '========== PART 5.1 v7.0.0 VERIFICATION ==========' as section;

SELECT 
  'FUNCTION EXISTS' as check_type,
  CASE WHEN EXISTS (SELECT 1 FROM pg_proc WHERE proname = 'activate_whop_subscription') 
    THEN '‚úÖ' ELSE '‚ùå' END as status;

SELECT 
  'SIGNATURE CHECK' as check_type,
  pg_get_function_arguments(oid) as function_args
FROM pg_proc 
WHERE proname = 'activate_whop_subscription';

SELECT 
  'GRANTS CHECK' as check_type,
  CASE WHEN EXISTS (
    SELECT 1 FROM information_schema.routine_privileges 
    WHERE routine_name = 'activate_whop_subscription' AND grantee = 'service_role'
  ) THEN '‚úÖ service_role' ELSE '‚ùå missing' END as status;

SELECT 'üéâ PART 5.1 v7.0.0 PRODUCTION READY!' as status;

-- ----------------------------------------
-- 5.2 Deactivate Whop Subscription (UNIFIED)
-- Handles both cancellation and downgrade
-- ----------------------------------------

DROP FUNCTION IF EXISTS deactivate_whop_subscription(TEXT);

CREATE OR REPLACE FUNCTION deactivate_whop_subscription(p_whop_membership_id TEXT)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_user_id UUID;
  v_user_email TEXT;
  v_old_plan TEXT;
  v_pending_plan TEXT;
  v_new_plan TEXT;
  v_referral_id UUID;
  v_affiliate_id UUID;
  v_new_max_trades INTEGER;
BEGIN
  -- Find user
  SELECT id, email, account_type, pending_downgrade_plan 
  INTO v_user_id, v_user_email, v_old_plan, v_pending_plan
  FROM profiles WHERE whop_membership_id = p_whop_membership_id;
  
  IF v_user_id IS NULL THEN
    RETURN jsonb_build_object('success', false, 'error', 'User not found for membership: ' || p_whop_membership_id);
  END IF;
  
  -- Determine target plan (use pending_downgrade_plan if set, otherwise free)
  v_new_plan := COALESCE(v_pending_plan, 'free');
  v_new_max_trades := CASE v_new_plan WHEN 'basic' THEN 25 WHEN 'premium' THEN 999999 ELSE 10 END;
  
  -- Update profile
  UPDATE profiles SET
    account_type = v_new_plan,
    subscription_status = CASE WHEN v_new_plan = 'free' THEN 'cancelled' ELSE 'pending_resubscribe' END,
    subscription_cancel_at_period_end = FALSE,
    pending_downgrade_plan = NULL,
    cancellation_reason = NULL,
    max_trades = v_new_max_trades,
    whop_membership_id = CASE WHEN v_new_plan = 'free' THEN NULL ELSE whop_membership_id END,
    whop_product_id = CASE WHEN v_new_plan = 'free' THEN NULL ELSE whop_product_id END,
    updated_at = NOW()
  WHERE id = v_user_id;
  
  -- Log event
  INSERT INTO subscription_events (user_id, event_type, old_plan, new_plan, processed_at, metadata)
  VALUES (v_user_id, 'cancelled', v_old_plan, v_new_plan, NOW(),
    jsonb_build_object('whop_membership_id', p_whop_membership_id, 'was_scheduled_downgrade', v_pending_plan IS NOT NULL));
  
  -- Update affiliate referral (only if going to free = churn)
  IF v_new_plan = 'free' THEN
    SELECT id, affiliate_id INTO v_referral_id, v_affiliate_id
    FROM affiliate_referrals WHERE referred_user_id = v_user_id OR whop_membership_id = p_whop_membership_id;
    
    IF v_referral_id IS NOT NULL THEN
      UPDATE affiliate_referrals SET status = 'churned', churned_at = NOW(), subscription_cancelled_at = NOW(), updated_at = NOW()
      WHERE id = v_referral_id;
      
      UPDATE affiliates SET total_active_customers = GREATEST(0, COALESCE(total_active_customers, 0) - 1), updated_at = NOW()
      WHERE id = v_affiliate_id;
      
      INSERT INTO affiliate_activity_log (affiliate_id, activity_type, description, metadata, is_system_action)
      VALUES (v_affiliate_id, 'referral_churned', 'Customer ' || v_user_email || ' subscription ended',
        jsonb_build_object('whop_membership_id', p_whop_membership_id, 'user_email', v_user_email, 'old_plan', v_old_plan, 'was_scheduled_downgrade', v_pending_plan IS NOT NULL), true);
    END IF;
  END IF;
  
  RETURN jsonb_build_object(
    'success', true, 'user_id', v_user_id, 'email', v_user_email,
    'old_plan', v_old_plan, 'new_plan', v_new_plan,
    'was_scheduled_downgrade', v_pending_plan IS NOT NULL, 'referral_updated', v_referral_id IS NOT NULL
  );
END;
$$;


-- ----------------------------------------
-- 5.3 Handle Whop Payment
-- (payment.succeeded - recurring and first)
-- ----------------------------------------

DROP FUNCTION IF EXISTS handle_whop_payment(TEXT, NUMERIC, BOOLEAN, TEXT);

CREATE OR REPLACE FUNCTION handle_whop_payment(
  p_whop_membership_id TEXT,
  p_payment_amount NUMERIC,
  p_is_first_payment BOOLEAN DEFAULT FALSE,
  p_promo_code TEXT DEFAULT NULL
)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_user_id UUID;
  v_user_email TEXT;
  v_subscription_type TEXT;
  v_referral RECORD;
  v_affiliate RECORD;
  v_commission_rate NUMERIC;
  v_commission_amount NUMERIC;
  v_referral_id UUID;
  v_commission_type_val commission_type;
BEGIN
  -- Get user info
  SELECT id, email, subscription_interval INTO v_user_id, v_user_email, v_subscription_type
  FROM profiles WHERE whop_membership_id = p_whop_membership_id;
  
  -- Find existing referral
  SELECT ar.*, a.commission_enabled, a.affiliate_type, a.current_tier, a.id as aff_id, a.user_id as aff_user_id
  INTO v_referral
  FROM affiliate_referrals ar
  JOIN affiliates a ON ar.affiliate_id = a.id
  WHERE ar.whop_membership_id = p_whop_membership_id OR ar.referred_user_id = v_user_id;
  
  -- If no referral but promo code provided, try to create one
  IF v_referral IS NULL AND p_promo_code IS NOT NULL AND v_user_id IS NOT NULL THEN
    SELECT * INTO v_affiliate FROM affiliates
    WHERE (UPPER(affiliate_code) = UPPER(p_promo_code) OR UPPER(coupon_code) = UPPER(p_promo_code))
      AND status = 'active' AND commission_enabled = true;
    
    IF v_affiliate IS NOT NULL AND v_affiliate.user_id != v_user_id THEN
      v_commission_rate := get_commission_rate(COALESCE(v_affiliate.current_tier::text, 'tier_1'), COALESCE(v_subscription_type, 'monthly'));
      v_commission_amount := ROUND(p_payment_amount * v_commission_rate, 2);
      v_commission_type_val := CASE WHEN v_subscription_type = 'yearly' THEN 'annual_upfront' ELSE 'monthly_recurring' END;
      
      INSERT INTO affiliate_referrals (
        affiliate_id, referred_user_id, referred_user_email, signup_date, whop_membership_id,
        first_payment_amount_usd, first_payment_date, total_payments_usd, status,
        verification_start, verification_end, commission_eligible, coupon_code_used, subscription_type
      ) VALUES (
        v_affiliate.id, v_user_id, v_user_email, NOW(), p_whop_membership_id,
        p_payment_amount, NOW(), p_payment_amount, 'verification_pending',
        NOW(), NOW() + INTERVAL '7 days', true, p_promo_code, v_subscription_type
      ) RETURNING id INTO v_referral_id;
      
      UPDATE affiliates SET total_signups = COALESCE(total_signups, 0) + 1, last_activity_at = NOW() WHERE id = v_affiliate.id;
      
      INSERT INTO affiliate_commissions (
        affiliate_id, referral_id, commission_type, commission_month, base_amount_usd,
        commission_rate, commission_amount_usd, tier_at_time, status, month_number
      ) VALUES (
        v_affiliate.id, v_referral_id, v_commission_type_val, date_trunc('month', NOW())::date,
        p_payment_amount, v_commission_rate, v_commission_amount, v_affiliate.current_tier, 'pending', 1
      );
      
      UPDATE affiliates SET
        total_pending_usd = COALESCE(total_pending_usd, 0) + v_commission_amount,
        total_earnings_usd = COALESCE(total_earnings_usd, 0) + v_commission_amount
      WHERE id = v_affiliate.id;
      
      UPDATE affiliate_referrals SET commission_earned_usd = v_commission_amount WHERE id = v_referral_id;
      
      INSERT INTO affiliate_activity_log (affiliate_id, activity_type, description, metadata, is_system_action)
      VALUES (v_affiliate.id, 'first_payment_received',
        'First payment of $' || p_payment_amount || ' (' || COALESCE(v_subscription_type, 'monthly') || '), commission: $' || v_commission_amount,
        jsonb_build_object('user_email', v_user_email, 'amount', p_payment_amount, 'promo_code', p_promo_code,
          'commission_rate', v_commission_rate, 'commission_amount', v_commission_amount), true);
      
      RETURN jsonb_build_object('success', true, 'message', 'New referral and commission created',
        'referral_id', v_referral_id, 'commission_amount', v_commission_amount, 'commission_rate', v_commission_rate);
    END IF;
  END IF;
  
  IF v_referral IS NULL THEN
    RETURN jsonb_build_object('success', true, 'message', 'No affiliate referral found for this payment');
  END IF;
  
  IF NOT v_referral.commission_enabled OR v_referral.affiliate_type != 'regular' THEN
    RETURN jsonb_build_object('success', true, 'message', 'Affiliate not eligible for commission');
  END IF;
  
  v_commission_rate := get_commission_rate(COALESCE(v_referral.current_tier::text, 'tier_1'), COALESCE(v_subscription_type, 'monthly'));
  v_commission_type_val := CASE WHEN v_subscription_type = 'yearly' THEN 'annual_upfront' ELSE 'monthly_recurring' END;
  
  -- First payment
  IF p_is_first_payment AND v_referral.first_payment_date IS NULL THEN
    v_commission_amount := ROUND(p_payment_amount * v_commission_rate, 2);
    
    UPDATE affiliate_referrals SET
      status = 'verification_pending', first_payment_amount_usd = p_payment_amount, first_payment_date = NOW(),
      verification_start = NOW(), verification_end = NOW() + INTERVAL '7 days',
      total_payments_usd = COALESCE(total_payments_usd, 0) + p_payment_amount,
      subscription_type = v_subscription_type, updated_at = NOW()
    WHERE id = v_referral.id;
    
    INSERT INTO affiliate_commissions (
      affiliate_id, referral_id, commission_type, commission_month, base_amount_usd,
      commission_rate, commission_amount_usd, tier_at_time, status, month_number
    ) VALUES (v_referral.affiliate_id, v_referral.id, v_commission_type_val, date_trunc('month', NOW())::date,
      p_payment_amount, v_commission_rate, v_commission_amount, v_referral.current_tier, 'pending', 1);
    
    UPDATE affiliates SET
      total_pending_usd = COALESCE(total_pending_usd, 0) + v_commission_amount,
      total_earnings_usd = COALESCE(total_earnings_usd, 0) + v_commission_amount, last_activity_at = NOW()
    WHERE id = v_referral.affiliate_id;
    
    UPDATE affiliate_referrals SET commission_earned_usd = COALESCE(commission_earned_usd, 0) + v_commission_amount
    WHERE id = v_referral.id;
    
    INSERT INTO affiliate_activity_log (affiliate_id, activity_type, description, metadata, is_system_action)
    VALUES (v_referral.affiliate_id, 'first_payment_received',
      'First payment of $' || p_payment_amount || ', commission: $' || v_commission_amount,
      jsonb_build_object('amount', p_payment_amount, 'commission', v_commission_amount, 'rate', v_commission_rate), true);
    
    RETURN jsonb_build_object('success', true, 'message', 'First payment recorded, commission created',
      'referral_id', v_referral.id, 'commission_amount', v_commission_amount, 'verification_ends', NOW() + INTERVAL '7 days');
  END IF;
  
  -- Recurring payment for qualified referrals
  IF v_referral.status = 'qualified' AND v_referral.commission_eligible THEN
    UPDATE affiliate_referrals SET total_payments_usd = COALESCE(total_payments_usd, 0) + p_payment_amount, updated_at = NOW()
    WHERE id = v_referral.id;
    
    IF v_subscription_type = 'monthly' AND COALESCE(v_referral.months_commissioned, 0) < 12 THEN
      v_commission_amount := ROUND(p_payment_amount * v_commission_rate, 2);
      
      INSERT INTO affiliate_commissions (
        affiliate_id, referral_id, commission_type, commission_month, base_amount_usd,
        commission_rate, commission_amount_usd, tier_at_time, status, month_number
      ) VALUES (v_referral.affiliate_id, v_referral.id, 'monthly_recurring', date_trunc('month', NOW())::date,
        p_payment_amount, v_commission_rate, v_commission_amount, v_referral.current_tier, 'pending',
        COALESCE(v_referral.months_commissioned, 0) + 1);
      
      UPDATE affiliate_referrals SET
        months_commissioned = COALESCE(months_commissioned, 0) + 1,
        commission_earned_usd = COALESCE(commission_earned_usd, 0) + v_commission_amount
      WHERE id = v_referral.id;
      
      UPDATE affiliates SET
        total_pending_usd = COALESCE(total_pending_usd, 0) + v_commission_amount,
        total_earnings_usd = COALESCE(total_earnings_usd, 0) + v_commission_amount, last_activity_at = NOW()
      WHERE id = v_referral.affiliate_id;
      
      RETURN jsonb_build_object('success', true, 'message', 'Recurring payment and commission recorded',
        'referral_id', v_referral.id, 'commission_amount', v_commission_amount, 'month_number', COALESCE(v_referral.months_commissioned, 0) + 1);
    END IF;
  END IF;
  
  RETURN jsonb_build_object('success', true, 'message', 'Payment recorded', 'referral_id', v_referral.id, 'referral_status', v_referral.status);
END;
$$;
-- ============================================
-- PART 6: SUBSCRIPTION MANAGEMENT
-- ============================================

-- ----------------------------------------
-- 6.1 Undo Pending Cancellation
-- ----------------------------------------

DROP FUNCTION IF EXISTS undo_pending_cancellation(UUID);

CREATE OR REPLACE FUNCTION undo_pending_cancellation(p_user_id UUID)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_profile RECORD;
BEGIN
  SELECT * INTO v_profile FROM profiles WHERE id = p_user_id;
  
  IF v_profile IS NULL THEN
    RETURN jsonb_build_object('success', false, 'error', 'User not found');
  END IF;
  
  IF NOT COALESCE(v_profile.subscription_cancel_at_period_end, FALSE) THEN
    RETURN jsonb_build_object('success', false, 'error', 'No pending cancellation to undo');
  END IF;
  
  UPDATE profiles SET
    subscription_cancel_at_period_end = FALSE,
    pending_downgrade_plan = NULL,
    cancellation_reason = NULL,
    updated_at = NOW()
  WHERE id = p_user_id;
  
  INSERT INTO subscription_events (user_id, event_type, old_plan, new_plan, metadata)
  VALUES (p_user_id, 'reactivated', v_profile.pending_downgrade_plan, v_profile.account_type,
    jsonb_build_object('action', 'undo_cancellation'));
  
  RETURN jsonb_build_object('success', true, 'message', 'Cancellation has been undone. Your subscription will continue.', 'plan', v_profile.account_type);
END;
$$;


-- ============================================
-- PART 7: QUALIFICATION & CRON
-- ============================================

-- ----------------------------------------
-- 7.1 Qualify Verified Referrals
-- (Runs daily via Cron to qualify after 7 days)
-- ----------------------------------------

DROP FUNCTION IF EXISTS qualify_verified_referrals();

CREATE OR REPLACE FUNCTION qualify_verified_referrals()
RETURNS TABLE(referrals_qualified INTEGER, commissions_confirmed INTEGER)
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_referrals_qualified INTEGER := 0;
  v_commissions_confirmed INTEGER := 0;
BEGIN
  -- Move referrals to qualified after 7 days
  WITH qualified AS (
    UPDATE affiliate_referrals SET
      status = 'qualified', qualified_at = NOW(), commission_eligible = TRUE,
      commission_start_date = NOW(), commission_end_date = NOW() + INTERVAL '12 months', updated_at = NOW()
    WHERE status = 'verification_pending' AND verification_end <= NOW() AND churned_at IS NULL
    RETURNING id, affiliate_id
  )
  SELECT COUNT(*) INTO v_referrals_qualified FROM qualified;

  -- Update affiliate stats
  UPDATE affiliates a SET
    total_qualified_referrals = (SELECT COUNT(*) FROM affiliate_referrals ar WHERE ar.affiliate_id = a.id AND ar.status = 'qualified'),
    total_active_customers = (SELECT COUNT(*) FROM affiliate_referrals ar WHERE ar.affiliate_id = a.id AND ar.status IN ('qualified', 'verification_pending') AND ar.churned_at IS NULL),
    updated_at = NOW()
  WHERE EXISTS (SELECT 1 FROM affiliate_referrals ar WHERE ar.affiliate_id = a.id AND ar.status = 'qualified' AND ar.qualified_at >= NOW() - INTERVAL '1 minute');

  -- Confirm commissions
  WITH confirmed AS (
    UPDATE affiliate_commissions ac SET status = 'confirmed', confirmed_at = NOW(), updated_at = NOW()
    FROM affiliate_referrals ar
    WHERE ac.referral_id = ar.id AND ac.status = 'pending' AND ar.status = 'qualified'
    RETURNING ac.id, ac.affiliate_id, ac.commission_amount_usd
  )
  SELECT COUNT(*) INTO v_commissions_confirmed FROM confirmed;

  -- Update pending totals
  UPDATE affiliates a SET
    total_pending_usd = GREATEST(0, COALESCE(total_pending_usd, 0) - COALESCE((
      SELECT SUM(commission_amount_usd) FROM affiliate_commissions 
      WHERE affiliate_id = a.id AND status = 'confirmed' AND confirmed_at >= NOW() - INTERVAL '1 minute'
    ), 0)),
    updated_at = NOW()
  WHERE id IN (SELECT DISTINCT affiliate_id FROM affiliate_commissions WHERE status = 'confirmed' AND confirmed_at >= NOW() - INTERVAL '1 minute');

  -- Log activity
  INSERT INTO affiliate_activity_log (affiliate_id, activity_type, description, metadata, is_system_action)
  SELECT ar.affiliate_id, 'referral_qualified', 'Referral ' || ar.referred_user_email || ' completed 7-day verification',
    jsonb_build_object('referral_id', ar.id, 'user_email', ar.referred_user_email, 'first_payment', ar.first_payment_amount_usd), true
  FROM affiliate_referrals ar WHERE ar.status = 'qualified' AND ar.qualified_at >= NOW() - INTERVAL '1 minute';

  RETURN QUERY SELECT v_referrals_qualified, v_commissions_confirmed;
END;
$$;


-- ----------------------------------------
-- 7.2 Manual Task Runner
-- ----------------------------------------

CREATE OR REPLACE FUNCTION run_daily_affiliate_tasks()
RETURNS TEXT
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_result RECORD;
BEGIN
  SELECT * INTO v_result FROM qualify_verified_referrals();
  RETURN 'Qualified: ' || v_result.referrals_qualified || ', Confirmed: ' || v_result.commissions_confirmed;
END;
$$;


-- ============================================
-- PART 8: VIEWS
-- ============================================

-- ----------------------------------------
-- 8.1 Affiliate Dashboard Summary View
-- ----------------------------------------

DROP VIEW IF EXISTS affiliate_dashboard_summary;

CREATE OR REPLACE VIEW affiliate_dashboard_summary AS
SELECT 
  a.id as affiliate_id, a.user_id, a.display_name, a.email, a.affiliate_code, a.coupon_code, a.referral_link,
  a.status, a.current_tier, a.discount_tier, a.affiliate_type, a.commission_enabled,
  COALESCE(a.total_clicks, 0) as total_clicks,
  COALESCE(a.total_signups, 0) as total_signups,
  COALESCE(a.total_qualified_referrals, 0) as total_qualified_referrals,
  COALESCE(a.total_active_customers, 0) as total_active_customers,
  CASE WHEN COALESCE(a.total_clicks, 0) > 0 THEN ROUND((COALESCE(a.total_signups, 0)::numeric / a.total_clicks) * 100, 2) ELSE 0 END as signup_conversion_rate,
  CASE WHEN COALESCE(a.total_signups, 0) > 0 THEN ROUND((COALESCE(a.total_qualified_referrals, 0)::numeric / a.total_signups) * 100, 2) ELSE 0 END as qualification_rate,
  COALESCE(a.total_earnings_usd, 0) as total_earnings_usd,
  COALESCE(a.total_pending_usd, 0) as total_pending_usd,
  COALESCE(a.total_paid_usd, 0) as total_paid_usd,
  CASE a.current_tier WHEN 'tier_3' THEN 0.20 WHEN 'tier_2' THEN 0.15 ELSE 0.10 END as current_commission_rate,
  CASE a.current_tier WHEN 'tier_1' THEN GREATEST(0, 20 - COALESCE(a.total_qualified_referrals, 0)) WHEN 'tier_2' THEN GREATEST(0, 75 - COALESCE(a.total_qualified_referrals, 0)) ELSE 0 END as clients_to_next_tier,
  COALESCE(a.notify_on_signup, TRUE) as notify_on_signup,
  COALESCE(a.notify_on_qualification, TRUE) as notify_on_qualification,
  COALESCE(a.notify_on_commission, TRUE) as notify_on_commission,
  COALESCE(a.notify_on_payout, TRUE) as notify_on_payout,
  a.paypal_email, a.payment_method, a.activated_at, a.last_activity_at, a.created_at, a.updated_at
FROM affiliates a WHERE a.status IN ('active', 'inactive');



-- ============================================
-- get_user_subscription_status v3.0.0 WITH PLATFORM
-- Returns ALL fields including Platform subscription
-- ============================================

DROP FUNCTION IF EXISTS get_user_subscription_status(UUID);

CREATE OR REPLACE FUNCTION get_user_subscription_status(p_user_id UUID)
RETURNS TABLE (
  -- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  -- JOURNAL SUBSCRIPTION FIELDS (existing)
  -- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  account_type TEXT,
  subscription_status TEXT,
  subscription_interval TEXT,
  subscription_expires_at TIMESTAMPTZ,
  subscription_started_at TIMESTAMPTZ,
  subscription_cancel_at_period_end BOOLEAN,
  pending_downgrade_plan TEXT,
  cancellation_reason TEXT,
  is_lifetime BOOLEAN,
  
  -- Trade limits
  max_trades INTEGER,
  current_month_trades_count INTEGER,
  trade_count INTEGER,
  
  -- Computed trade fields
  remaining INTEGER,
  used INTEGER,
  plan TEXT,
  reset_date DATE,
  
  -- Billing
  billing_cycle_start DATE,
  current_month_active_days INTEGER,
  
  -- Payment provider
  payment_provider TEXT,
  
  -- Whop identifiers (Journal)
  whop_user_id TEXT,
  whop_membership_id TEXT,
  whop_product_id TEXT,
  whop_plan_id TEXT,
  whop_customer_email TEXT,
  
  -- Portfolio & Risk
  initial_portfolio NUMERIC,
  current_portfolio NUMERIC,
  portfolio_size NUMERIC,
  total_pnl NUMERIC,
  risk_mode TEXT,
  risk_percentage NUMERIC,
  fixed_risk_amount NUMERIC,
  
  -- User role
  role TEXT,
  
  -- Newsletter fields
  newsletter_paid BOOLEAN,
  newsletter_status TEXT,
  newsletter_expires_at TIMESTAMPTZ,
  
  -- Top Secret fields
  top_secret_enabled BOOLEAN,
  top_secret_status TEXT,
  top_secret_expires_at TIMESTAMPTZ,
  
  -- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  -- üî• PLATFORM SUBSCRIPTION FIELDS (NEW)
  -- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  platform_plan TEXT,
  platform_subscription_status TEXT,
  platform_billing_interval TEXT,
  platform_subscription_started_at TIMESTAMPTZ,
  platform_subscription_expires_at TIMESTAMPTZ,
  platform_trial_ends_at TIMESTAMPTZ,
  platform_is_in_trial BOOLEAN,
  platform_trial_days_remaining INTEGER,
  platform_cancel_at_period_end BOOLEAN,
  platform_cancelled_at TIMESTAMPTZ,
  platform_whop_membership_id TEXT,
  platform_pro_trial_eligible BOOLEAN,
  platform_core_trial_eligible BOOLEAN,
  platform_bundle_journal_granted BOOLEAN,
  platform_bundle_newsletter_granted BOOLEAN,
  platform_bundle_newsletter_choice TEXT
)
LANGUAGE plpgsql
STABLE
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_platform_trial_days_remaining INTEGER;
BEGIN
  -- Calculate Platform trial days remaining
  SELECT 
    CASE 
      WHEN p.platform_is_in_trial AND p.platform_trial_ends_at IS NOT NULL 
      THEN GREATEST(0, EXTRACT(DAY FROM (p.platform_trial_ends_at - NOW()))::INTEGER)
      ELSE NULL
    END
  INTO v_platform_trial_days_remaining
  FROM profiles p
  WHERE p.id = p_user_id;

  RETURN QUERY
  SELECT 
    -- Basic subscription info
    COALESCE(p.account_type, 'free')::TEXT,
    p.subscription_status::TEXT,
    p.subscription_interval::TEXT,
    p.subscription_expires_at,
    p.subscription_started_at,
    COALESCE(p.subscription_cancel_at_period_end, FALSE),
    p.pending_downgrade_plan::TEXT,
    p.cancellation_reason::TEXT,
    COALESCE(p.is_lifetime, FALSE),
    
    -- Trade limits
    COALESCE(p.max_trades, 10),
    COALESCE(p.current_month_trades_count, 0),
    COALESCE(p.trade_count, 0),
    
    -- Computed trade fields
    GREATEST(0, COALESCE(p.max_trades, 10) - COALESCE(p.current_month_trades_count, 0))::INTEGER,
    COALESCE(p.current_month_trades_count, 0)::INTEGER,
    COALESCE(p.account_type, 'free')::TEXT,
    (COALESCE(p.billing_cycle_start, DATE_TRUNC('month', NOW())::DATE) + INTERVAL '1 month')::DATE,
    
    -- Billing
    COALESCE(p.billing_cycle_start, DATE_TRUNC('month', NOW())::DATE),
    COALESCE(p.current_month_active_days, 0),
    
    -- Payment provider
    p.payment_provider::TEXT,
    
    -- Whop identifiers (Journal)
    p.whop_user_id::TEXT,
    p.whop_membership_id::TEXT,
    p.whop_product_id::TEXT,
    p.whop_plan_id::TEXT,
    p.whop_customer_email::TEXT,
    
    -- Portfolio & Risk
    COALESCE(p.initial_portfolio, 10000)::NUMERIC,
    COALESCE(p.current_portfolio, 10000)::NUMERIC,
    COALESCE(p.portfolio_size, 10000)::NUMERIC,
    COALESCE(p.total_pnl, 0)::NUMERIC,
    COALESCE(p.risk_mode, 'percentage')::TEXT,
    COALESCE(p.risk_percentage, 1.0)::NUMERIC,
    p.fixed_risk_amount::NUMERIC,
    
    -- User role
    COALESCE(p.role, 'user')::TEXT,
    
    -- Newsletter
    COALESCE(p.newsletter_paid, FALSE),
    COALESCE(p.newsletter_status, 'inactive')::TEXT,
    p.newsletter_expires_at,
    
    -- Top Secret
    COALESCE(p.top_secret_enabled, FALSE),
    COALESCE(p.top_secret_status, 'inactive')::TEXT,
    p.top_secret_expires_at,
    
    -- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    -- üî• PLATFORM FIELDS
    -- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    COALESCE(p.platform_plan, 'free')::TEXT,
    COALESCE(p.platform_subscription_status, 'inactive')::TEXT,
    p.platform_billing_interval::TEXT,
    p.platform_subscription_started_at,
    p.platform_subscription_expires_at,
    p.platform_trial_ends_at,
    COALESCE(p.platform_is_in_trial, FALSE),
    v_platform_trial_days_remaining,
    COALESCE(p.platform_cancel_at_period_end, FALSE),
    p.platform_cancelled_at,
    p.platform_whop_membership_id::TEXT,
    
    -- Trial eligibility (NULL = eligible, NOT NULL = already used)
    (p.platform_pro_trial_used_at IS NULL),
    (p.platform_core_trial_used_at IS NULL),
    
    -- Bundle status
    COALESCE(p.platform_bundle_journal_granted, FALSE),
    COALESCE(p.platform_bundle_newsletter_granted, FALSE),
    p.platform_bundle_newsletter_choice::TEXT
    
  FROM profiles p
  WHERE p.id = p_user_id;
END;
$$;

-- Grants for get_user_subscription_status
GRANT EXECUTE ON FUNCTION get_user_subscription_status(UUID) TO authenticated;
GRANT EXECUTE ON FUNCTION get_user_subscription_status(UUID) TO anon;
GRANT EXECUTE ON FUNCTION get_user_subscription_status(UUID) TO service_role;
-- ============================================
-- validate_affiliate_code
-- ============================================

DROP FUNCTION IF EXISTS validate_affiliate_code(TEXT);

CREATE OR REPLACE FUNCTION validate_affiliate_code(p_code TEXT)
RETURNS TABLE (
  is_valid BOOLEAN,
  affiliate_id UUID,
  discount_percent NUMERIC,
  affiliate_name TEXT
)
LANGUAGE plpgsql
STABLE
SECURITY DEFINER
AS $$
BEGIN
  RETURN QUERY
  SELECT 
    TRUE as is_valid,
    a.id as affiliate_id,
    COALESCE(a.discount_percent, 0) as discount_percent,
    a.display_name as affiliate_name
  FROM affiliates a
  WHERE (UPPER(a.affiliate_code) = UPPER(p_code) OR UPPER(a.coupon_code) = UPPER(p_code))
    AND a.status = 'active';
    
  -- If no rows returned, return invalid
  IF NOT FOUND THEN
    RETURN QUERY SELECT FALSE, NULL::UUID, 0::NUMERIC, NULL::TEXT;
  END IF;
END;
$$;


-- ============================================
-- record_affiliate_click
-- ============================================

DROP FUNCTION IF EXISTS record_affiliate_click(TEXT, TEXT, TEXT, TEXT, TEXT, TEXT, TEXT, TEXT, TEXT);

CREATE OR REPLACE FUNCTION record_affiliate_click(
  p_affiliate_code TEXT,
  p_ip_hash TEXT DEFAULT NULL,
  p_user_agent TEXT DEFAULT NULL,
  p_referrer_url TEXT DEFAULT NULL,
  p_landing_page TEXT DEFAULT NULL,
  p_utm_source TEXT DEFAULT NULL,
  p_utm_medium TEXT DEFAULT NULL,
  p_utm_campaign TEXT DEFAULT NULL,
  p_utm_content TEXT DEFAULT NULL
)
RETURNS UUID
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_affiliate_id UUID;
  v_click_id UUID;
BEGIN
  -- Find affiliate
  SELECT id INTO v_affiliate_id
  FROM affiliates
  WHERE (UPPER(affiliate_code) = UPPER(p_affiliate_code) OR UPPER(coupon_code) = UPPER(p_affiliate_code))
    AND status = 'active';
  
  IF v_affiliate_id IS NULL THEN
    RETURN NULL;
  END IF;
  
  -- Insert click
  INSERT INTO affiliate_clicks (
    affiliate_id, ip_hash, user_agent, referrer_url, landing_page,
    utm_source, utm_medium, utm_campaign, utm_content
  ) VALUES (
    v_affiliate_id, p_ip_hash, p_user_agent, p_referrer_url, p_landing_page,
    p_utm_source, p_utm_medium, p_utm_campaign, p_utm_content
  )
  RETURNING id INTO v_click_id;
  
  -- Update affiliate stats
  UPDATE affiliates SET 
    total_clicks = COALESCE(total_clicks, 0) + 1,
    last_activity_at = NOW()
  WHERE id = v_affiliate_id;
  
  RETURN v_click_id;
END;
$$;


-- ============================================
-- get_affiliate_analytics
-- ============================================

DROP FUNCTION IF EXISTS get_affiliate_analytics(UUID, DATE, DATE);

CREATE OR REPLACE FUNCTION get_affiliate_analytics(
  p_affiliate_id UUID,
  p_start_date DATE DEFAULT NULL,
  p_end_date DATE DEFAULT NULL
)
RETURNS TABLE (
  total_clicks BIGINT,
  total_signups BIGINT,
  total_conversions BIGINT,
  total_revenue NUMERIC,
  total_commission NUMERIC
)
LANGUAGE plpgsql
STABLE
SECURITY DEFINER
AS $$
BEGIN
  RETURN QUERY
  SELECT 
    COALESCE(a.total_clicks, 0)::BIGINT,
    COALESCE(a.total_signups, 0)::BIGINT,
    COALESCE(a.total_qualified_referrals, 0)::BIGINT,
    COALESCE(a.total_earnings_usd, 0)::NUMERIC,
    COALESCE(a.total_earnings_usd, 0)::NUMERIC
  FROM affiliates a
  WHERE a.id = p_affiliate_id;
END;
$$;
-- ============================================
-- PART 9: RLS POLICIES & GRANTS
-- ============================================

-- Enable RLS
ALTER TABLE whop_plan_mapping ENABLE ROW LEVEL SECURITY;
ALTER TABLE whop_webhook_log ENABLE ROW LEVEL SECURITY;
ALTER TABLE affiliate_clicks ENABLE ROW LEVEL SECURITY;
ALTER TABLE subscription_events ENABLE ROW LEVEL SECURITY;

-- Plan mapping policies
DROP POLICY IF EXISTS "Public can read active plan mapping" ON whop_plan_mapping;
CREATE POLICY "Public can read active plan mapping" ON whop_plan_mapping FOR SELECT USING (is_active = TRUE);

DROP POLICY IF EXISTS "Admin full access to plan mapping" ON whop_plan_mapping;
CREATE POLICY "Admin full access to plan mapping" ON whop_plan_mapping FOR ALL 
  USING (EXISTS (SELECT 1 FROM profiles WHERE id = auth.uid() AND role IN ('admin', 'super_admin')));

-- Webhook log policies
DROP POLICY IF EXISTS "Admin access to webhook log" ON whop_webhook_log;
CREATE POLICY "Admin access to webhook log" ON whop_webhook_log FOR ALL 
  USING (EXISTS (SELECT 1 FROM profiles WHERE id = auth.uid() AND role IN ('admin', 'super_admin')));

DROP POLICY IF EXISTS "Service role access to webhook log" ON whop_webhook_log;
CREATE POLICY "Service role access to webhook log" ON whop_webhook_log FOR ALL USING (auth.role() = 'service_role');

-- Affiliate clicks policies
DROP POLICY IF EXISTS "Affiliates can view own clicks" ON affiliate_clicks;
CREATE POLICY "Affiliates can view own clicks" ON affiliate_clicks FOR SELECT 
  USING (EXISTS (SELECT 1 FROM affiliates WHERE id = affiliate_id AND user_id = auth.uid()));

DROP POLICY IF EXISTS "Service role can insert clicks" ON affiliate_clicks;
CREATE POLICY "Service role can insert clicks" ON affiliate_clicks FOR INSERT WITH CHECK (TRUE);

DROP POLICY IF EXISTS "Public can insert clicks" ON affiliate_clicks;
CREATE POLICY "Public can insert clicks" ON affiliate_clicks FOR INSERT WITH CHECK (TRUE);

-- Subscription events policies
DROP POLICY IF EXISTS "Users can view own subscription events" ON subscription_events;
CREATE POLICY "Users can view own subscription events" ON subscription_events FOR SELECT USING (auth.uid() = user_id);

DROP POLICY IF EXISTS "Service role can manage subscription events" ON subscription_events;
CREATE POLICY "Service role can manage subscription events" ON subscription_events FOR ALL USING (TRUE);

-- Grants
GRANT EXECUTE ON FUNCTION get_user_subscription_status(UUID) TO authenticated, anon;
GRANT EXECUTE ON FUNCTION get_finotaur_plan_from_whop(TEXT) TO authenticated, anon;
GRANT EXECUTE ON FUNCTION get_product_trial_days(TEXT) TO authenticated, service_role;
GRANT EXECUTE ON FUNCTION get_commission_rate(TEXT, TEXT) TO authenticated, service_role;
GRANT EXECUTE ON FUNCTION validate_affiliate_code(TEXT) TO authenticated, anon;
GRANT EXECUTE ON FUNCTION record_affiliate_click(TEXT, TEXT, TEXT, TEXT, TEXT, TEXT, TEXT, TEXT, TEXT) TO authenticated, anon;
GRANT EXECUTE ON FUNCTION track_referral_signup(TEXT, UUID, TEXT, TEXT, TEXT, TEXT, NUMERIC, UUID, NUMERIC, NUMERIC) TO authenticated, service_role;
GRANT EXECUTE ON FUNCTION get_affiliate_analytics(UUID, DATE, DATE) TO authenticated;
GRANT EXECUTE ON FUNCTION activate_whop_subscription(TEXT, TEXT, TEXT, TEXT, TEXT, TEXT, UUID) TO service_role;
GRANT EXECUTE ON FUNCTION deactivate_whop_subscription(TEXT) TO service_role;
GRANT EXECUTE ON FUNCTION handle_whop_payment(TEXT, NUMERIC, BOOLEAN, TEXT) TO service_role;
GRANT EXECUTE ON FUNCTION qualify_verified_referrals() TO service_role;
GRANT EXECUTE ON FUNCTION get_subscription_cancellation_status(UUID) TO authenticated;
GRANT EXECUTE ON FUNCTION undo_pending_cancellation(UUID) TO authenticated;

GRANT SELECT ON whop_plan_mapping TO authenticated, anon;
GRANT ALL ON whop_webhook_log TO service_role;
GRANT SELECT ON affiliate_dashboard_summary TO authenticated;
GRANT SELECT, INSERT ON affiliate_clicks TO authenticated, anon;
GRANT SELECT ON subscription_events TO authenticated;
GRANT ALL ON subscription_events TO service_role;


-- ============================================
-- PART 10: DATA MIGRATION & FIXES
-- ============================================

-- Fix existing webhook logs
UPDATE whop_webhook_log
SET event_type = payload->>'type'
WHERE (event_type = 'unknown' OR event_type IS NULL) AND payload->>'type' IS NOT NULL;

-- Fix profiles for users with payments but still 'free'
WITH paid_users AS (
  SELECT DISTINCT ON (LOWER(payload->'data'->'user'->>'email'))
    payload->'data'->'user'->>'email' as email,
    payload->'data'->'product'->>'id' as product_id,
    payload->'data'->'membership'->>'id' as membership_id,
    payload->'data'->'user'->>'id' as whop_user_id,
    payload->'data'->'promo_code'->>'code' as promo_code,
    (payload->'data'->>'subtotal')::numeric as amount,
    created_at as payment_date
  FROM whop_webhook_log
  WHERE payload->>'type' = 'payment.succeeded' AND payload->'data'->'user'->>'email' IS NOT NULL
  ORDER BY LOWER(payload->'data'->'user'->>'email'), created_at DESC
)
UPDATE profiles p SET
  account_type = wpm.finotaur_plan,
  subscription_status = 'active',
  subscription_interval = wpm.billing_interval,
  subscription_started_at = pu.payment_date,
  subscription_expires_at = CASE WHEN wpm.billing_interval = 'monthly' THEN pu.payment_date + INTERVAL '1 month' ELSE pu.payment_date + INTERVAL '1 year' END,
  subscription_cancel_at_period_end = false,
  whop_user_id = pu.whop_user_id,
  whop_membership_id = pu.membership_id,
  whop_product_id = pu.product_id,
  whop_customer_email = pu.email,
  payment_provider = 'whop',
  max_trades = CASE WHEN wpm.max_trades = -1 THEN 999999 ELSE wpm.max_trades END,
  current_month_trades_count = 0,
  billing_cycle_start = pu.payment_date::date,
  updated_at = NOW()
FROM paid_users pu
JOIN whop_plan_mapping wpm ON wpm.whop_product_id = pu.product_id
WHERE LOWER(p.email) = LOWER(pu.email) AND (p.account_type = 'free' OR p.account_type IS NULL);

-- Create referrals for users with promo codes
WITH promo_payments AS (
  SELECT DISTINCT ON (LOWER(payload->'data'->'user'->>'email'))
    payload->'data'->'user'->>'email' as email,
    payload->'data'->'product'->>'id' as product_id,
    payload->'data'->'membership'->>'id' as membership_id,
    payload->'data'->'user'->>'id' as whop_user_id,
    payload->'data'->'promo_code'->>'code' as promo_code,
    (payload->'data'->>'subtotal')::numeric as amount,
    created_at as payment_date
  FROM whop_webhook_log
  WHERE payload->>'type' = 'payment.succeeded' AND payload->'data'->'promo_code'->>'code' IS NOT NULL
  ORDER BY LOWER(payload->'data'->'user'->>'email'), created_at DESC
)
INSERT INTO affiliate_referrals (
  affiliate_id, referred_user_id, referred_user_email, signup_date, signup_plan, coupon_code_used,
  subscription_plan, subscription_type, subscription_price_usd, subscription_started_at,
  first_payment_amount_usd, first_payment_date, total_payments_usd, status,
  verification_start, verification_end, commission_eligible, whop_membership_id, whop_user_id, whop_product_id
)
SELECT 
  a.id, p.id, pp.email, pp.payment_date, wpm.finotaur_plan, pp.promo_code,
  wpm.finotaur_plan, wpm.billing_interval, pp.amount, pp.payment_date,
  pp.amount, pp.payment_date, pp.amount, 'verification_pending'::referral_status,
  pp.payment_date, pp.payment_date + INTERVAL '7 days', true, pp.membership_id, pp.whop_user_id, pp.product_id
FROM promo_payments pp
JOIN profiles p ON LOWER(p.email) = LOWER(pp.email)
JOIN affiliates a ON (UPPER(a.affiliate_code) = UPPER(pp.promo_code) OR UPPER(a.coupon_code) = UPPER(pp.promo_code))
JOIN whop_plan_mapping wpm ON wpm.whop_product_id = pp.product_id
WHERE a.status = 'active' AND a.user_id != p.id
  AND NOT EXISTS (SELECT 1 FROM affiliate_referrals ar WHERE ar.referred_user_id = p.id);

-- Create commissions for new referrals
INSERT INTO affiliate_commissions (
  affiliate_id, referral_id, commission_type, commission_month, base_amount_usd,
  commission_rate, commission_amount_usd, tier_at_time, status, month_number
)
SELECT 
  ar.affiliate_id, ar.id,
  CASE WHEN ar.subscription_type = 'yearly' THEN 'annual_upfront'::commission_type ELSE 'monthly_recurring'::commission_type END,
  date_trunc('month', ar.first_payment_date)::date, ar.first_payment_amount_usd,
  get_commission_rate(a.current_tier::text, COALESCE(ar.subscription_type, 'monthly')),
  ROUND(ar.first_payment_amount_usd * get_commission_rate(a.current_tier::text, COALESCE(ar.subscription_type, 'monthly')), 2),
  a.current_tier, 'pending'::commission_status, 1
FROM affiliate_referrals ar
JOIN affiliates a ON a.id = ar.affiliate_id
WHERE ar.created_at >= NOW() - INTERVAL '5 minutes'
  AND NOT EXISTS (SELECT 1 FROM affiliate_commissions ac WHERE ac.referral_id = ar.id);

-- Update affiliate stats
UPDATE affiliates a SET
  total_signups = (SELECT COUNT(*) FROM affiliate_referrals ar WHERE ar.affiliate_id = a.id),
  total_pending_usd = (SELECT COALESCE(SUM(commission_amount_usd), 0) FROM affiliate_commissions ac WHERE ac.affiliate_id = a.id AND ac.status = 'pending'),
  total_earnings_usd = (SELECT COALESCE(SUM(commission_amount_usd), 0) FROM affiliate_commissions ac WHERE ac.affiliate_id = a.id),
  last_activity_at = NOW(), updated_at = NOW()
WHERE EXISTS (SELECT 1 FROM affiliate_referrals ar WHERE ar.affiliate_id = a.id);


-- ============================================
-- PART 11: VERIFICATION
-- ============================================

SELECT '========== VERIFICATION RESULTS ==========' as section;

-- Check columns
SELECT 
  'COLUMNS' as check_type,
  CASE WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'profiles' AND column_name = 'pending_downgrade_plan') THEN '‚úÖ' ELSE '‚ùå' END as pending_downgrade_plan,
  CASE WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'profiles' AND column_name = 'cancellation_reason') THEN '‚úÖ' ELSE '‚ùå' END as cancellation_reason,
  CASE WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'profiles' AND column_name = 'whop_membership_id') THEN '‚úÖ' ELSE '‚ùå' END as whop_membership_id;

-- Check tables
SELECT 
  'TABLES' as check_type,
  CASE WHEN EXISTS (SELECT 1 FROM pg_tables WHERE tablename = 'subscription_events') THEN '‚úÖ' ELSE '‚ùå' END as subscription_events,
  CASE WHEN EXISTS (SELECT 1 FROM pg_tables WHERE tablename = 'whop_webhook_log') THEN '‚úÖ' ELSE '‚ùå' END as whop_webhook_log,
  CASE WHEN EXISTS (SELECT 1 FROM pg_tables WHERE tablename = 'whop_plan_mapping') THEN '‚úÖ' ELSE '‚ùå' END as whop_plan_mapping,
  CASE WHEN EXISTS (SELECT 1 FROM pg_tables WHERE tablename = 'affiliate_clicks') THEN '‚úÖ' ELSE '‚ùå' END as affiliate_clicks;

-- Check functions
SELECT 
  'FUNCTIONS' as check_type,
  CASE WHEN EXISTS (SELECT 1 FROM pg_proc WHERE proname = 'get_user_subscription_status') THEN '‚úÖ' ELSE '‚ùå' END as get_user_subscription_status,
  CASE WHEN EXISTS (SELECT 1 FROM pg_proc WHERE proname = 'validate_affiliate_code') THEN '‚úÖ' ELSE '‚ùå' END as validate_affiliate_code,
  CASE WHEN EXISTS (SELECT 1 FROM pg_proc WHERE proname = 'activate_whop_subscription') THEN '‚úÖ' ELSE '‚ùå' END as activate_whop_subscription,
  CASE WHEN EXISTS (SELECT 1 FROM pg_proc WHERE proname = 'deactivate_whop_subscription') THEN '‚úÖ' ELSE '‚ùå' END as deactivate_whop_subscription,
  CASE WHEN EXISTS (SELECT 1 FROM pg_proc WHERE proname = 'handle_whop_payment') THEN '‚úÖ' ELSE '‚ùå' END as handle_whop_payment,
  CASE WHEN EXISTS (SELECT 1 FROM pg_proc WHERE proname = 'qualify_verified_referrals') THEN '‚úÖ' ELSE '‚ùå' END as qualify_verified_referrals,
  CASE WHEN EXISTS (SELECT 1 FROM pg_proc WHERE proname = 'undo_pending_cancellation') THEN '‚úÖ' ELSE '‚ùå' END as undo_pending_cancellation;

-- Check view
SELECT 
  'VIEW' as check_type,
  CASE WHEN EXISTS (SELECT 1 FROM pg_views WHERE viewname = 'affiliate_dashboard_summary') THEN '‚úÖ' ELSE '‚ùå' END as affiliate_dashboard_summary;

-- Plan mapping count
SELECT 'PLANS' as check_type, COUNT(*)::TEXT || ' active plans' as status FROM whop_plan_mapping WHERE is_active = TRUE;

-- Commission rates test
SELECT 'COMMISSION RATES' as check_type,
  'tier_1: ' || get_commission_rate('tier_1', 'monthly')::text || ', ' ||
  'tier_2: ' || get_commission_rate('tier_2', 'monthly')::text || ', ' ||
  'tier_3: ' || get_commission_rate('tier_3', 'monthly')::text || ', ' ||
  'annual: ' || get_commission_rate('tier_1', 'yearly')::text as rates;

-- Summary stats
SELECT 
  'SUMMARY' as check_type,
  (SELECT COUNT(*) FROM profiles WHERE payment_provider = 'whop' AND account_type != 'free') as paid_users,
  (SELECT COUNT(*) FROM affiliate_referrals) as total_referrals,
  (SELECT COUNT(*) FROM affiliate_referrals WHERE status = 'verification_pending') as pending_verification,
  (SELECT COUNT(*) FROM affiliate_commissions) as total_commissions,
  (SELECT COALESCE(SUM(commission_amount_usd), 0) FROM affiliate_commissions WHERE status = 'pending') as pending_commission_usd;
-- =====================================================
-- FINOTAUR NEWSLETTER (WAR ZONE) - WHOP INTEGRATION
-- =====================================================
-- Version: 1.1.0 (FIXED)
-- Date: 2025-12-03
-- 
-- ‚úÖ Product ID: prod_qlaV5Uu6LZlYn
-- ‚úÖ Plan ID: plan_LCBG5yJpoNtW3
-- =====================================================
-- ============================================
-- PART 11.5: USER CREATION TRIGGER (FIXED)
-- ============================================
-- Version: 2.0.0
-- Date: 2025-12-13
-- 
-- ◊™◊ô◊ß◊ï◊ü: ◊î◊ï◊°◊§◊™ newsletter_unsubscribe_token + error handling
-- ============================================

CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_affiliate_code TEXT;
  v_display_name TEXT;
BEGIN
  -- Generate display name
  v_display_name := COALESCE(
    NEW.raw_user_meta_data->>'display_name',
    NEW.raw_user_meta_data->>'full_name',
    NEW.raw_user_meta_data->>'name',
    split_part(NEW.email, '@', 1)
  );
  
  -- Generate unique affiliate code
  v_affiliate_code := UPPER(LEFT(COALESCE(v_display_name, 'USR'), 3)) || 
                      LPAD(FLOOR(RANDOM() * 10000)::TEXT, 4, '0');
  
  -- Ensure uniqueness (retry if exists)
  WHILE EXISTS (SELECT 1 FROM public.profiles WHERE affiliate_code = v_affiliate_code) LOOP
    v_affiliate_code := UPPER(LEFT(COALESCE(v_display_name, 'USR'), 3)) || 
                        LPAD(FLOOR(RANDOM() * 10000)::TEXT, 4, '0');
  END LOOP;

  INSERT INTO public.profiles (
    id, 
    email, 
    display_name,
    affiliate_code,
    account_type, 
    max_trades, 
    trade_count, 
    billing_cycle_start,
    current_portfolio, 
    total_pnl, 
    initial_portfolio,
    portfolio_size,
    risk_mode,
    risk_percentage,
    role,
    is_banned,
    -- Newsletter fields
    newsletter_unsubscribe_token,
    newsletter_enabled,
    newsletter_status,
    -- Timestamps
    created_at,
    updated_at
  ) VALUES (
    NEW.id,
    NEW.email,
    v_display_name,
    v_affiliate_code,
    'free',
    10,
    0,
    CURRENT_DATE,
    10000,
    0,
    10000,
    10000,
    'percentage',
    1.0,
    'user',
    FALSE,
    -- Newsletter defaults
    encode(gen_random_bytes(32), 'hex'),
    FALSE,
    'inactive',
    -- Timestamps
    NOW(),
    NOW()
  )
  ON CONFLICT (id) DO UPDATE SET
    email = EXCLUDED.email,
    display_name = COALESCE(profiles.display_name, EXCLUDED.display_name),
    affiliate_code = COALESCE(profiles.affiliate_code, EXCLUDED.affiliate_code),
    newsletter_unsubscribe_token = COALESCE(profiles.newsletter_unsubscribe_token, EXCLUDED.newsletter_unsubscribe_token),
    updated_at = NOW();
  
  RETURN NEW;
  
EXCEPTION WHEN OTHERS THEN
  -- Log error but don't fail the signup
  RAISE WARNING 'handle_new_user error for %: % (SQLSTATE: %)', 
    NEW.email, SQLERRM, SQLSTATE;
  RETURN NEW;
END;
$$;

-- Ensure trigger exists
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW
  EXECUTE FUNCTION public.handle_new_user();

-- Verification
SELECT '========== USER CREATION TRIGGER ==========' as section;

SELECT 
  'FUNCTION' as check_type,
  CASE WHEN EXISTS (SELECT 1 FROM pg_proc WHERE proname = 'handle_new_user') 
    THEN '‚úÖ' ELSE '‚ùå' END as status;

SELECT 
  'TRIGGER' as check_type,
  CASE WHEN EXISTS (
    SELECT 1 FROM pg_trigger WHERE tgname = 'on_auth_user_created'
  ) THEN '‚úÖ' ELSE '‚ùå' END as status;

-- ===============================================
-- PART 12: SUPABASE REALTIME FOR ADMIN DASHBOARD
-- ===============================================

DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_publication_tables 
    WHERE pubname = 'supabase_realtime' AND tablename = 'profiles'
  ) THEN
    ALTER PUBLICATION supabase_realtime ADD TABLE public.profiles;
    RAISE NOTICE '‚úÖ Added profiles to supabase_realtime';
  ELSE
    RAISE NOTICE '‚ÑπÔ∏è profiles already in supabase_realtime';
  END IF;
END $$;

DO $$
DECLARE
  v_current_identity CHAR(1);
BEGIN
  SELECT relreplident INTO v_current_identity 
  FROM pg_class WHERE relname = 'profiles';
  
  IF v_current_identity != 'f' THEN
    ALTER TABLE public.profiles REPLICA IDENTITY FULL;
    RAISE NOTICE '‚úÖ Set REPLICA IDENTITY FULL on profiles';
  ELSE
    RAISE NOTICE '‚ÑπÔ∏è profiles already has REPLICA IDENTITY FULL';
  END IF;
END $$;

CREATE INDEX IF NOT EXISTS idx_profiles_realtime_updates 
ON public.profiles(account_type, subscription_status, updated_at DESC);

SELECT 'REALTIME SETUP' as check_type,
  CASE WHEN EXISTS (
    SELECT 1 FROM pg_publication_tables 
    WHERE pubname = 'supabase_realtime' AND tablename = 'profiles'
  ) THEN '‚úÖ profiles in realtime' ELSE '‚ùå NOT in realtime' END as publication_status,
  CASE WHEN (SELECT relreplident FROM pg_class WHERE relname = 'profiles') = 'f' 
  THEN '‚úÖ REPLICA IDENTITY FULL' ELSE '‚ùå NOT FULL' END as replica_identity;


-- ============================================
-- PART 13: NEWSLETTER SCHEMA
-- ============================================

DO $$ 
BEGIN
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'whop_plan_mapping' AND column_name = 'whop_plan_id') THEN
    ALTER TABLE whop_plan_mapping ADD COLUMN whop_plan_id TEXT;
    COMMENT ON COLUMN whop_plan_mapping.whop_plan_id IS 'Whop Plan ID for checkout URLs';
  END IF;
END $$;

-- ----------------------------------------
-- 13.1 PROFILES TABLE - Newsletter Columns
-- ----------------------------------------

DO $$ 
BEGIN
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'profiles' AND column_name = 'newsletter_enabled') THEN
    ALTER TABLE profiles ADD COLUMN newsletter_enabled BOOLEAN DEFAULT FALSE;
    COMMENT ON COLUMN profiles.newsletter_enabled IS 'Whether user has active newsletter subscription';
  END IF;
  
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'profiles' AND column_name = 'newsletter_whop_membership_id') THEN
    ALTER TABLE profiles ADD COLUMN newsletter_whop_membership_id TEXT;
    COMMENT ON COLUMN profiles.newsletter_whop_membership_id IS 'Whop membership ID for newsletter subscription';
  END IF;
  
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'profiles' AND column_name = 'newsletter_started_at') THEN
    ALTER TABLE profiles ADD COLUMN newsletter_started_at TIMESTAMPTZ;
    COMMENT ON COLUMN profiles.newsletter_started_at IS 'When newsletter subscription started';
  END IF;
  
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'profiles' AND column_name = 'newsletter_expires_at') THEN
    ALTER TABLE profiles ADD COLUMN newsletter_expires_at TIMESTAMPTZ;
    COMMENT ON COLUMN profiles.newsletter_expires_at IS 'Newsletter subscription expiration/next billing date';
  END IF;
  
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'profiles' AND column_name = 'newsletter_trial_ends_at') THEN
    ALTER TABLE profiles ADD COLUMN newsletter_trial_ends_at TIMESTAMPTZ;
    COMMENT ON COLUMN profiles.newsletter_trial_ends_at IS '7-day free trial end date';
  END IF;
  
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'profiles' AND column_name = 'newsletter_cancel_at_period_end') THEN
    ALTER TABLE profiles ADD COLUMN newsletter_cancel_at_period_end BOOLEAN DEFAULT FALSE;
    COMMENT ON COLUMN profiles.newsletter_cancel_at_period_end IS 'Whether newsletter will cancel at period end';
  END IF;
  
IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'profiles' AND column_name = 'newsletter_status') THEN
    ALTER TABLE profiles ADD COLUMN newsletter_status TEXT DEFAULT 'inactive';
    COMMENT ON COLUMN profiles.newsletter_status IS 'Newsletter subscription status: inactive, trial, active, cancelled';
  END IF;
  
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'profiles' AND column_name = 'newsletter_unsubscribed_at') THEN
    ALTER TABLE profiles ADD COLUMN newsletter_unsubscribed_at TIMESTAMPTZ;
    COMMENT ON COLUMN profiles.newsletter_unsubscribed_at IS 'When subscription was cancelled';
  END IF;
END $$;

ALTER TABLE profiles DROP CONSTRAINT IF EXISTS profiles_newsletter_status_check;
ALTER TABLE profiles ADD CONSTRAINT profiles_newsletter_status_check 
  CHECK (newsletter_status IS NULL OR newsletter_status IN ('inactive', 'trial', 'active', 'cancelled'));


-- ----------------------------------------
-- 13.2 NEWSLETTER INDEXES
-- ----------------------------------------

CREATE INDEX IF NOT EXISTS idx_profiles_newsletter_enabled 
ON profiles(newsletter_enabled) WHERE newsletter_enabled = TRUE;

CREATE INDEX IF NOT EXISTS idx_profiles_newsletter_membership 
ON profiles(newsletter_whop_membership_id) WHERE newsletter_whop_membership_id IS NOT NULL;

CREATE INDEX IF NOT EXISTS idx_profiles_newsletter_status 
ON profiles(newsletter_status) WHERE newsletter_status != 'inactive';

CREATE INDEX IF NOT EXISTS idx_profiles_newsletter_trial 
ON profiles(newsletter_trial_ends_at) WHERE newsletter_trial_ends_at IS NOT NULL;


-- ----------------------------------------
-- 13.3 WHOP PLAN MAPPING - Newsletter Entry
-- ----------------------------------------
INSERT INTO whop_plan_mapping (
  whop_product_id, 
  whop_plan_id,
  finotaur_plan, 
  billing_interval, 
  price_usd, 
  max_trades, 
  display_name, 
  is_active,
  trial_days
) VALUES (
  'prod_qlaV5Uu6LZlYn',
  'plan_LCBG5yJpoNtW3',
  'newsletter',
  'monthly',
  39.00,
  0,
  'War Zone Intelligence Newsletter',
  TRUE,
  7
)
ON CONFLICT (whop_product_id) DO UPDATE SET
  whop_plan_id = EXCLUDED.whop_plan_id,
  finotaur_plan = EXCLUDED.finotaur_plan,
  billing_interval = EXCLUDED.billing_interval,
  price_usd = EXCLUDED.price_usd,
  max_trades = EXCLUDED.max_trades,
  display_name = EXCLUDED.display_name,
  is_active = TRUE,
  trial_days = EXCLUDED.trial_days,
  updated_at = NOW();
-- ============================================
-- PART 14: NEWSLETTER FUNCTIONS - v6.0.0 SYNCED
-- ============================================
-- Date: 2025-12-13
-- 
-- üî• CRITICAL: Function signatures MUST match webhook calls
-- All finotaur_user_id params are TEXT (not UUID)
-- ============================================


-- ----------------------------------------
-- 14.0 Helper: Is Newsletter Product
-- ----------------------------------------

DROP FUNCTION IF EXISTS is_newsletter_product(TEXT);

CREATE OR REPLACE FUNCTION is_newsletter_product(p_product_id TEXT)
RETURNS BOOLEAN
LANGUAGE plpgsql
IMMUTABLE
AS $$
BEGIN
  RETURN p_product_id = 'prod_qlaV5Uu6LZlYn';
END;
$$;


-- ----------------------------------------
-- 14.1 Activate Newsletter Subscription
-- Called on: membership.activated, membership.went_valid
-- ----------------------------------------

DROP FUNCTION IF EXISTS activate_newsletter_subscription(TEXT, TEXT, TEXT, TEXT, UUID);
DROP FUNCTION IF EXISTS activate_newsletter_subscription(TEXT, TEXT, TEXT, TEXT, TEXT);

CREATE OR REPLACE FUNCTION activate_newsletter_subscription(
  p_user_email TEXT,
  p_whop_user_id TEXT,
  p_whop_membership_id TEXT,
  p_whop_product_id TEXT,
  p_finotaur_user_id TEXT DEFAULT NULL
)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_user_id UUID;
  v_is_first_time BOOLEAN;
  v_is_new_user BOOLEAN := FALSE;
  v_trial_days INTEGER;
  v_trial_ends_at TIMESTAMPTZ;
  v_expires_at TIMESTAMPTZ;
  v_status TEXT;
  v_new_user_id UUID;
  v_display_name TEXT;
  v_affiliate_code TEXT;
BEGIN
  -- ========================================
  -- STEP 1: Find User (multiple lookup methods)
  -- ========================================
  
  -- Try finotaur_user_id first (internal signup)
  IF p_finotaur_user_id IS NOT NULL AND p_finotaur_user_id != '' THEN
    BEGIN
      SELECT id INTO v_user_id 
      FROM profiles 
      WHERE id = p_finotaur_user_id::UUID;
      
      IF v_user_id IS NOT NULL THEN
        RAISE NOTICE '‚úÖ Found user by finotaur_user_id: %', v_user_id;
      END IF;
    EXCEPTION WHEN OTHERS THEN
      RAISE NOTICE '‚ö†Ô∏è Invalid finotaur_user_id format: %', p_finotaur_user_id;
    END;
  END IF;
  
  -- Try email (fallback)
  IF v_user_id IS NULL AND p_user_email IS NOT NULL AND p_user_email != '' THEN
    SELECT id INTO v_user_id 
    FROM profiles 
    WHERE LOWER(email) = LOWER(p_user_email);
    
    IF v_user_id IS NOT NULL THEN
      RAISE NOTICE '‚úÖ Found user by email: %', v_user_id;
    END IF;
  END IF;
  
  -- Try membership_id (for recurring events)
  IF v_user_id IS NULL AND p_whop_membership_id IS NOT NULL THEN
    SELECT id INTO v_user_id 
    FROM profiles 
    WHERE newsletter_whop_membership_id = p_whop_membership_id;
    
    IF v_user_id IS NOT NULL THEN
      RAISE NOTICE '‚úÖ Found user by membership_id: %', v_user_id;
    END IF;
  END IF;
  
  -- ========================================
  -- STEP 2: Create New User if Not Found
  -- ========================================
  IF v_user_id IS NULL THEN
    IF p_user_email IS NULL OR p_user_email = '' THEN
      RETURN jsonb_build_object(
        'success', false,
        'error', 'No email provided and user not found',
        'lookup_attempted', jsonb_build_object(
          'finotaur_user_id', p_finotaur_user_id,
          'email', p_user_email,
          'membership_id', p_whop_membership_id
        )
      );
    END IF;
    
    v_new_user_id := gen_random_uuid();
    v_display_name := SPLIT_PART(p_user_email, '@', 1);
    v_affiliate_code := UPPER(LEFT(v_display_name, 3)) || LPAD(FLOOR(RANDOM() * 10000)::TEXT, 4, '0');
    
    WHILE EXISTS (SELECT 1 FROM profiles WHERE affiliate_code = v_affiliate_code) LOOP
      v_affiliate_code := UPPER(LEFT(v_display_name, 3)) || LPAD(FLOOR(RANDOM() * 10000)::TEXT, 4, '0');
    END LOOP;
    
    INSERT INTO profiles (
      id, email, display_name, affiliate_code,
      account_type, subscription_status, max_trades,
      role, is_banned, onboarding_completed,
      newsletter_unsubscribe_token,
      created_at, updated_at
    ) VALUES (
      v_new_user_id, LOWER(p_user_email), v_display_name, v_affiliate_code,
      'free', NULL, 10,
      'user', FALSE, FALSE,
      encode(gen_random_bytes(32), 'hex'),
      NOW(), NOW()
    );
    
    v_user_id := v_new_user_id;
    v_is_new_user := TRUE;
    RAISE NOTICE 'üÜï Created new user: % with email: %', v_user_id, p_user_email;
  END IF;
  
  -- ========================================
  -- STEP 3: Check if First Time Subscriber
  -- ========================================
  SELECT 
    newsletter_started_at IS NULL OR newsletter_status = 'inactive' OR newsletter_status IS NULL
  INTO v_is_first_time
  FROM profiles 
  WHERE id = v_user_id;
  
  v_is_first_time := COALESCE(v_is_first_time, TRUE);
  
-- ========================================
-- STEP 4: DYNAMIC TRIAL CALCULATION
-- ========================================

v_trial_days := get_product_trial_days(p_whop_product_id);

IF v_trial_days > 0 AND v_is_first_time THEN
  v_trial_ends_at := NOW() + (v_trial_days || ' days')::INTERVAL;
  v_status := 'trial';
  v_expires_at := v_trial_ends_at;
ELSE
  v_trial_ends_at := NULL;
  v_status := 'active';
  v_expires_at := NOW() + INTERVAL '1 month';
END IF;
  -- ========================================
  -- STEP 5: Update Newsletter Fields ONLY
  -- ========================================
  UPDATE profiles SET
    newsletter_enabled = TRUE,
    newsletter_whop_membership_id = p_whop_membership_id,
    newsletter_started_at = COALESCE(newsletter_started_at, NOW()),
    newsletter_expires_at = v_expires_at,
    newsletter_trial_ends_at = CASE 
      WHEN v_is_first_time THEN v_trial_ends_at 
      ELSE newsletter_trial_ends_at 
    END,
    newsletter_cancel_at_period_end = FALSE,
    newsletter_status = v_status,
    updated_at = NOW()
  WHERE id = v_user_id;
  
  -- ========================================
  -- STEP 6: Log Event
  -- ========================================
  INSERT INTO subscription_events (
    user_id, event_type, old_plan, new_plan, metadata
  ) VALUES (
    v_user_id,
    CASE 
      WHEN v_is_new_user THEN 'newsletter_signup_new_user'
      WHEN v_is_first_time THEN 'trial_started'
      ELSE 'payment_succeeded'
    END,
    'none', 'newsletter',
    jsonb_build_object(
      'whop_membership_id', p_whop_membership_id,
      'whop_product_id', p_whop_product_id,
      'whop_user_id', p_whop_user_id,
      'is_new_user', v_is_new_user,
      'is_first_time', v_is_first_time,
      'trial_ends_at', v_trial_ends_at,
      'subscription_type', 'newsletter'
    )
  );
  
  -- ========================================
  -- STEP 7: Return Result
  -- ========================================
  RETURN jsonb_build_object(
    'success', true,
    'user_id', v_user_id,
    'email', p_user_email,
    'newsletter_status', v_status,
    'is_new_user', v_is_new_user,
    'is_new_trial', v_is_first_time,
    'trial_ends_at', v_trial_ends_at,
    'expires_at', v_expires_at
  );
  
EXCEPTION WHEN OTHERS THEN
  RETURN jsonb_build_object(
    'success', false,
    'error', SQLERRM,
    'sqlstate', SQLSTATE,
    'email', p_user_email,
    'finotaur_user_id', p_finotaur_user_id
  );
END;
$$;


-- ----------------------------------------
-- 14.2 Handle Newsletter Payment
-- Called on: payment.succeeded (after trial)
-- ----------------------------------------

DROP FUNCTION IF EXISTS handle_newsletter_payment(TEXT, TEXT, TEXT, TEXT, NUMERIC, UUID);
DROP FUNCTION IF EXISTS handle_newsletter_payment(TEXT, TEXT, TEXT, TEXT, NUMERIC, TEXT);

CREATE OR REPLACE FUNCTION handle_newsletter_payment(
  p_user_email TEXT,
  p_whop_user_id TEXT,
  p_whop_membership_id TEXT,
  p_whop_product_id TEXT,
  p_payment_amount NUMERIC,
  p_finotaur_user_id TEXT DEFAULT NULL
)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_user_id UUID;
  v_was_in_trial BOOLEAN;
  v_old_status TEXT;
  v_expires_at TIMESTAMPTZ;
  v_trial_ends_at TIMESTAMPTZ;
BEGIN

  -- Find user by multiple methods
  IF p_finotaur_user_id IS NOT NULL AND p_finotaur_user_id != '' THEN
    BEGIN
      SELECT id INTO v_user_id FROM profiles WHERE id = p_finotaur_user_id::UUID;
    EXCEPTION WHEN OTHERS THEN NULL;
    END;
  END IF;
  
  IF v_user_id IS NULL AND p_whop_membership_id IS NOT NULL THEN
    SELECT id INTO v_user_id FROM profiles WHERE newsletter_whop_membership_id = p_whop_membership_id;
  END IF;
  
  IF v_user_id IS NULL AND p_user_email IS NOT NULL AND p_user_email != '' THEN
    SELECT id INTO v_user_id FROM profiles WHERE LOWER(email) = LOWER(p_user_email);
  END IF;
  
  IF v_user_id IS NULL THEN
    RETURN jsonb_build_object(
      'success', false,
      'error', 'User not found for payment',
      'lookup_attempted', jsonb_build_object(
        'finotaur_user_id', p_finotaur_user_id,
        'email', p_user_email,
        'membership_id', p_whop_membership_id
      )
    );
  END IF;
  
  -- Get current status and trial info
SELECT 
  newsletter_status, 
  newsletter_status = 'trial',
  newsletter_trial_ends_at
INTO v_old_status, v_was_in_trial, v_trial_ends_at
FROM profiles WHERE id = v_user_id;

-- ========================================
-- üî• FIX: Check if this is a $0 trial payment
-- If payment is $0 and user is in trial, DON'T change status
-- ========================================

IF COALESCE(p_payment_amount, 0) = 0 THEN
  -- $0 payment = trial signup, don't change trial status
  RETURN jsonb_build_object(
    'success', true,
    'user_id', v_user_id,
    'newsletter_status', COALESCE(v_old_status, 'trial'),
    'message', 'Trial signup - $0 payment, status unchanged',
    'payment_amount', p_payment_amount,
    'is_trial_payment', true
  );
END IF;

-- ========================================
-- Real payment (> $0) - convert trial to active
-- ========================================

v_expires_at := NOW() + INTERVAL '1 month';

-- Update newsletter fields ONLY
UPDATE profiles SET
  newsletter_enabled = TRUE,
  newsletter_status = 'active',
  newsletter_expires_at = v_expires_at,
  newsletter_cancel_at_period_end = FALSE,
  newsletter_paid = TRUE,
  newsletter_paid_at = NOW(),
  updated_at = NOW()
WHERE id = v_user_id;
  
  -- Log event
  INSERT INTO subscription_events (
    user_id, event_type, old_plan, new_plan, metadata
  ) VALUES (
    v_user_id,
    CASE WHEN v_was_in_trial THEN 'trial_ended' ELSE 'payment_succeeded' END,
    COALESCE(v_old_status, 'none'), 'newsletter',
    jsonb_build_object(
      'whop_membership_id', p_whop_membership_id,
      'payment_amount', p_payment_amount,
      'was_in_trial', v_was_in_trial,
      'subscription_type', 'newsletter'
    )
  );
  
  RETURN jsonb_build_object(
    'success', true,
    'user_id', v_user_id,
    'newsletter_status', 'active',
    'was_in_trial', COALESCE(v_was_in_trial, FALSE),
    'previous_status', v_old_status,
    'expires_at', v_expires_at,
    'payment_amount', p_payment_amount
  );
  
EXCEPTION WHEN OTHERS THEN
  RETURN jsonb_build_object('success', false, 'error', SQLERRM, 'sqlstate', SQLSTATE);
END;
$$;


-- ----------------------------------------
-- 14.3 Deactivate Newsletter Subscription
-- Called on: membership.deactivated/canceled/went_invalid
-- ----------------------------------------

DROP FUNCTION IF EXISTS deactivate_newsletter_subscription(TEXT);

CREATE OR REPLACE FUNCTION deactivate_newsletter_subscription(p_whop_membership_id TEXT)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_user_id UUID;
  v_user_email TEXT;
  v_previous_status TEXT;
BEGIN
  SELECT id, email, newsletter_status 
  INTO v_user_id, v_user_email, v_previous_status
  FROM profiles 
  WHERE newsletter_whop_membership_id = p_whop_membership_id;
  
  IF v_user_id IS NULL THEN
    RETURN jsonb_build_object(
      'success', false,
      'error', 'User not found for membership: ' || p_whop_membership_id
    );
  END IF;
  
  -- Update newsletter fields ONLY (does NOT touch journal subscription)
  UPDATE profiles SET
    newsletter_enabled = FALSE,
    newsletter_status = 'cancelled',
    newsletter_cancel_at_period_end = FALSE,
    newsletter_unsubscribed_at = NOW(),
    updated_at = NOW()
  WHERE id = v_user_id;
  
  -- Log event
  INSERT INTO subscription_events (
    user_id, event_type, old_plan, new_plan, processed_at, metadata
  ) VALUES (
    v_user_id, 'cancelled', COALESCE(v_previous_status, 'active'), 'none', NOW(),
    jsonb_build_object(
      'whop_membership_id', p_whop_membership_id,
      'previous_status', v_previous_status,
      'subscription_type', 'newsletter'
    )
  );
  
  RETURN jsonb_build_object(
    'success', true,
    'user_id', v_user_id,
    'email', v_user_email,
    'previous_status', v_previous_status,
    'new_status', 'cancelled'
  );
  
EXCEPTION WHEN OTHERS THEN
  RETURN jsonb_build_object('success', false, 'error', SQLERRM, 'sqlstate', SQLSTATE);
END;
$$;


-- ----------------------------------------
-- 14.4 Get Newsletter Status (for frontend)
-- ----------------------------------------

DROP FUNCTION IF EXISTS get_newsletter_status(UUID);

CREATE OR REPLACE FUNCTION get_newsletter_status(p_user_id UUID)
RETURNS TABLE (
  newsletter_enabled BOOLEAN,
  newsletter_status TEXT,
  newsletter_whop_membership_id TEXT,
  newsletter_started_at TIMESTAMPTZ,
  newsletter_expires_at TIMESTAMPTZ,
  newsletter_trial_ends_at TIMESTAMPTZ,
  newsletter_cancel_at_period_end BOOLEAN,
  days_until_expiry INTEGER,
  days_until_trial_ends INTEGER,
  is_in_trial BOOLEAN,
  is_active BOOLEAN
)
LANGUAGE plpgsql
STABLE
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  RETURN QUERY
  SELECT 
    COALESCE(p.newsletter_enabled, FALSE),
    COALESCE(p.newsletter_status, 'inactive'),
    p.newsletter_whop_membership_id,
    p.newsletter_started_at,
    p.newsletter_expires_at,
    p.newsletter_trial_ends_at,
    COALESCE(p.newsletter_cancel_at_period_end, FALSE),
    CASE 
      WHEN p.newsletter_expires_at IS NOT NULL 
      THEN GREATEST(0, EXTRACT(DAY FROM p.newsletter_expires_at - NOW())::INTEGER)
      ELSE NULL
    END,
    CASE 
      WHEN p.newsletter_trial_ends_at IS NOT NULL 
      THEN GREATEST(0, EXTRACT(DAY FROM p.newsletter_trial_ends_at - NOW())::INTEGER)
      ELSE NULL
    END,
    COALESCE(p.newsletter_status, 'inactive') = 'trial',
    COALESCE(p.newsletter_enabled, FALSE) = TRUE 
      AND COALESCE(p.newsletter_status, 'inactive') IN ('active', 'trial')
  FROM profiles p
  WHERE p.id = p_user_id;
END;
$$;


-- ============================================
-- GRANTS
-- ============================================

GRANT EXECUTE ON FUNCTION is_newsletter_product(TEXT) TO service_role, authenticated;
GRANT EXECUTE ON FUNCTION activate_newsletter_subscription(TEXT, TEXT, TEXT, TEXT, TEXT) TO service_role;
GRANT EXECUTE ON FUNCTION handle_newsletter_payment(TEXT, TEXT, TEXT, TEXT, NUMERIC, TEXT) TO service_role;
GRANT EXECUTE ON FUNCTION deactivate_newsletter_subscription(TEXT) TO service_role;
GRANT EXECUTE ON FUNCTION get_newsletter_status(UUID) TO authenticated, service_role;

DROP FUNCTION IF EXISTS cancel_newsletter_subscription(UUID);

CREATE OR REPLACE FUNCTION cancel_newsletter_subscription(p_user_id UUID)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_profile RECORD;
  v_membership_id TEXT;
BEGIN
  SELECT 
    newsletter_status,
    newsletter_whop_membership_id,
    newsletter_expires_at
  INTO v_profile
  FROM profiles 
  WHERE id = p_user_id;
  
  IF v_profile IS NULL THEN
    RETURN jsonb_build_object('success', false, 'error', 'User not found');
  END IF;
  
  IF v_profile.newsletter_status NOT IN ('active', 'trial') THEN
    RETURN jsonb_build_object('success', false, 'error', 'No active subscription to cancel');
  END IF;
  
  v_membership_id := v_profile.newsletter_whop_membership_id;
  
  UPDATE profiles SET
    newsletter_cancel_at_period_end = TRUE,
    updated_at = NOW()
  WHERE id = p_user_id;
  
  INSERT INTO subscription_events (
    user_id, event_type, old_plan, new_plan, scheduled_at, metadata
  ) VALUES (
    p_user_id, 
    'cancel_scheduled', 
    'newsletter', 
    'none',
    v_profile.newsletter_expires_at,
    jsonb_build_object(
      'whop_membership_id', v_membership_id,
      'cancelled_by', 'user',
      'subscription_type', 'newsletter'
    )
  );
  
  RETURN jsonb_build_object(
    'success', true,
    'message', 'Subscription will be cancelled at period end',
    'membership_id', v_membership_id,
    'access_until', v_profile.newsletter_expires_at
  );
  
EXCEPTION WHEN OTHERS THEN
  RETURN jsonb_build_object('success', false, 'error', SQLERRM);
END;
$$;

GRANT EXECUTE ON FUNCTION cancel_newsletter_subscription(UUID) TO authenticated, service_role;


-- ----------------------------------------
-- 14.6 Reactivate Newsletter Subscription
-- (Undo pending cancellation)
-- ----------------------------------------

DROP FUNCTION IF EXISTS reactivate_newsletter_subscription(UUID);

CREATE OR REPLACE FUNCTION reactivate_newsletter_subscription(p_user_id UUID)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_profile RECORD;
BEGIN
  SELECT 
    newsletter_status,
    newsletter_cancel_at_period_end,
    newsletter_whop_membership_id
  INTO v_profile
  FROM profiles 
  WHERE id = p_user_id;
  
  IF v_profile IS NULL THEN
    RETURN jsonb_build_object('success', false, 'error', 'User not found');
  END IF;
  
  IF NOT COALESCE(v_profile.newsletter_cancel_at_period_end, FALSE) THEN
    RETURN jsonb_build_object('success', false, 'error', 'No pending cancellation to undo');
  END IF;
  
  UPDATE profiles SET
    newsletter_cancel_at_period_end = FALSE,
    updated_at = NOW()
  WHERE id = p_user_id;
  
  INSERT INTO subscription_events (
    user_id, event_type, old_plan, new_plan, metadata
  ) VALUES (
    p_user_id, 
    'reactivated', 
    'cancelling', 
    'newsletter',
    jsonb_build_object(
      'whop_membership_id', v_profile.newsletter_whop_membership_id,
      'subscription_type', 'newsletter'
    )
  );
  
  RETURN jsonb_build_object(
    'success', true,
    'message', 'Subscription reactivated successfully'
  );
  
EXCEPTION WHEN OTHERS THEN
  RETURN jsonb_build_object('success', false, 'error', SQLERRM);
END;
$$;

GRANT EXECUTE ON FUNCTION reactivate_newsletter_subscription(UUID) TO authenticated, service_role;



-- ============================================
-- VERIFICATION
-- ============================================

SELECT '========== PART 14 v6.0.0 VERIFICATION ==========' as section;

SELECT 
  'FUNCTIONS' as check_type,
  CASE WHEN EXISTS (SELECT 1 FROM pg_proc WHERE proname = 'is_newsletter_product') THEN '‚úÖ' ELSE '‚ùå' END as is_newsletter_product,
  CASE WHEN EXISTS (SELECT 1 FROM pg_proc WHERE proname = 'activate_newsletter_subscription') THEN '‚úÖ' ELSE '‚ùå' END as activate,
  CASE WHEN EXISTS (SELECT 1 FROM pg_proc WHERE proname = 'handle_newsletter_payment') THEN '‚úÖ' ELSE '‚ùå' END as handle_payment,
  CASE WHEN EXISTS (SELECT 1 FROM pg_proc WHERE proname = 'deactivate_newsletter_subscription') THEN '‚úÖ' ELSE '‚ùå' END as deactivate,
  CASE WHEN EXISTS (SELECT 1 FROM pg_proc WHERE proname = 'get_newsletter_status') THEN '‚úÖ' ELSE '‚ùå' END as get_status;

-- Check function signature
SELECT 
  'activate_newsletter_subscription SIGNATURE' as check_type,
  pg_get_function_arguments(oid) as args
FROM pg_proc 
WHERE proname = 'activate_newsletter_subscription';

SELECT 'üéâ PART 14 v6.0.0 COMPLETE!' as status;

-- =====================================================
-- TOP SECRET PRODUCT - WHOP INTEGRATION
-- =====================================================
-- Version: 1.0.0
-- Date: 2025-12-20
-- 
-- üî• Product Details:
-- - Product ID: prod_nl6YXbLp4t5pz
-- - Monthly Plan ID: plan_9VxdBaa2Z5KQy ($35/month)
-- - Yearly Plan ID: plan_YoeD6wWBxss7Q ($300/year)
-- - Discord: Auto-managed by Whop
-- 
-- ‚ö†Ô∏è ADD THIS SECTION AFTER PART 14 (NEWSLETTER FUNCTIONS)
--    AND BEFORE PART 15 (GRANTS & PERMISSIONS)
--    IN YOUR MAIN DATABASE FILE
-- =====================================================


-- ============================================
-- PART 14.5: TOP SECRET SCHEMA
-- ============================================

-- ----------------------------------------
-- 14.5.1 UPDATE CONSTRAINTS
-- ----------------------------------------

-- Update whop_plan_mapping constraint to include top_secret
ALTER TABLE whop_plan_mapping DROP CONSTRAINT IF EXISTS whop_plan_mapping_finotaur_plan_check;
-- First fix any invalid values
UPDATE whop_plan_mapping
SET finotaur_plan = 'basic'
WHERE finotaur_plan NOT IN ('free', 'basic', 'premium', 'trial', 'newsletter', 'top_secret')
   OR finotaur_plan IS NULL;

-- Then add the constraint
ALTER TABLE whop_plan_mapping DROP CONSTRAINT IF EXISTS whop_plan_mapping_finotaur_plan_check;
ALTER TABLE whop_plan_mapping ADD CONSTRAINT whop_plan_mapping_finotaur_plan_check 
  CHECK (finotaur_plan IN ('free', 'basic', 'premium', 'trial', 'newsletter', 'top_secret'));


-- ----------------------------------------
-- 14.5.2 WHOP PLAN MAPPING - Top Secret Entry
-- ----------------------------------------

-- Add metadata column if not exists
DO $$ 
BEGIN
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'whop_plan_mapping' AND column_name = 'metadata') THEN
    ALTER TABLE whop_plan_mapping ADD COLUMN metadata JSONB DEFAULT '{}';
  END IF;
END $$;

INSERT INTO whop_plan_mapping (
  whop_product_id, 
  whop_plan_id,
  finotaur_plan, 
  billing_interval, 
  price_usd, 
  max_trades, 
  display_name, 
  is_active,
  trial_days,
  metadata
) VALUES (
  'prod_nl6YXbLp4t5pz',
  'plan_9VxdBaa2Z5KQy',  -- Monthly plan ID (default)
  'top_secret',
  'monthly',
  70.00,
  0,  -- No trade limits (content product)
  'Top Secret',
  TRUE,
  14,
  '{"yearly_plan_id": "plan_YoeD6wWBxss7Q", "yearly_price": 300.00}'::jsonb
)
ON CONFLICT (whop_product_id) DO UPDATE SET
  whop_plan_id = EXCLUDED.whop_plan_id,
  finotaur_plan = EXCLUDED.finotaur_plan,
  billing_interval = EXCLUDED.billing_interval,
  price_usd = EXCLUDED.price_usd,
  max_trades = EXCLUDED.max_trades,
  display_name = EXCLUDED.display_name,
  is_active = TRUE,
  metadata = EXCLUDED.metadata,
  updated_at = NOW();


-- ----------------------------------------
-- 14.5.3 PROFILES TABLE - Top Secret Columns
-- ----------------------------------------

DO $$ 
BEGIN
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'profiles' AND column_name = 'top_secret_enabled') THEN
    ALTER TABLE profiles ADD COLUMN top_secret_enabled BOOLEAN DEFAULT FALSE;
    COMMENT ON COLUMN profiles.top_secret_enabled IS 'Whether user has active Top Secret subscription';
  END IF;
  
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'profiles' AND column_name = 'top_secret_whop_membership_id') THEN
    ALTER TABLE profiles ADD COLUMN top_secret_whop_membership_id TEXT;
    COMMENT ON COLUMN profiles.top_secret_whop_membership_id IS 'Whop membership ID for Top Secret subscription';
  END IF;
  
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'profiles' AND column_name = 'top_secret_started_at') THEN
    ALTER TABLE profiles ADD COLUMN top_secret_started_at TIMESTAMPTZ;
    COMMENT ON COLUMN profiles.top_secret_started_at IS 'When Top Secret subscription started';
  END IF;
  
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'profiles' AND column_name = 'top_secret_expires_at') THEN
    ALTER TABLE profiles ADD COLUMN top_secret_expires_at TIMESTAMPTZ;
    COMMENT ON COLUMN profiles.top_secret_expires_at IS 'Top Secret subscription expiration/next billing date';
  END IF;
  
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'profiles' AND column_name = 'top_secret_interval') THEN
    ALTER TABLE profiles ADD COLUMN top_secret_interval TEXT;
    COMMENT ON COLUMN profiles.top_secret_interval IS 'Top Secret billing interval: monthly or yearly';
  END IF;
  
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'profiles' AND column_name = 'top_secret_cancel_at_period_end') THEN
    ALTER TABLE profiles ADD COLUMN top_secret_cancel_at_period_end BOOLEAN DEFAULT FALSE;
    COMMENT ON COLUMN profiles.top_secret_cancel_at_period_end IS 'Whether Top Secret will cancel at period end';
  END IF;

  IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'profiles' AND column_name = 'top_secret_status') THEN
    ALTER TABLE profiles ADD COLUMN top_secret_status TEXT DEFAULT 'inactive';
    COMMENT ON COLUMN profiles.top_secret_status IS 'Top Secret subscription status: inactive, active, cancelled';
  END IF;
  
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'profiles' AND column_name = 'top_secret_unsubscribed_at') THEN
    ALTER TABLE profiles ADD COLUMN top_secret_unsubscribed_at TIMESTAMPTZ;
    COMMENT ON COLUMN profiles.top_secret_unsubscribed_at IS 'When Top Secret subscription was cancelled';
  END IF;
END $$;

-- Add constraints
ALTER TABLE profiles DROP CONSTRAINT IF EXISTS profiles_top_secret_status_check;
ALTER TABLE profiles ADD CONSTRAINT profiles_top_secret_status_check 
  CHECK (top_secret_status IS NULL OR top_secret_status IN ('inactive', 'active', 'cancelled'));

ALTER TABLE profiles DROP CONSTRAINT IF EXISTS profiles_top_secret_interval_check;
ALTER TABLE profiles ADD CONSTRAINT profiles_top_secret_interval_check 
  CHECK (top_secret_interval IS NULL OR top_secret_interval IN ('monthly', 'yearly'));


-- ----------------------------------------
-- 14.5.4 TOP SECRET INDEXES
-- ----------------------------------------

CREATE INDEX IF NOT EXISTS idx_profiles_top_secret_enabled 
ON profiles(top_secret_enabled) WHERE top_secret_enabled = TRUE;

CREATE INDEX IF NOT EXISTS idx_profiles_top_secret_membership 
ON profiles(top_secret_whop_membership_id) WHERE top_secret_whop_membership_id IS NOT NULL;

CREATE INDEX IF NOT EXISTS idx_profiles_top_secret_status 
ON profiles(top_secret_status) WHERE top_secret_status != 'inactive';


-- ============================================
-- 14.5.5 TOP SECRET FUNCTIONS
-- ============================================

-- ----------------------------------------
-- Helper: Is Top Secret Product
-- ----------------------------------------

DROP FUNCTION IF EXISTS is_top_secret_product(TEXT);

CREATE OR REPLACE FUNCTION is_top_secret_product(p_product_id TEXT)
RETURNS BOOLEAN
LANGUAGE plpgsql
IMMUTABLE
AS $$
BEGIN
  RETURN p_product_id = 'prod_nl6YXbLp4t5pz';
END;
$$;


-- ----------------------------------------
-- Activate Top Secret Subscription
-- Called on: membership.activated, membership.went_valid, first payment
-- ----------------------------------------

DROP FUNCTION IF EXISTS activate_top_secret_subscription(TEXT, TEXT, TEXT, TEXT, TEXT, TEXT);

CREATE OR REPLACE FUNCTION activate_top_secret_subscription(
  p_user_email TEXT,
  p_whop_user_id TEXT,
  p_whop_membership_id TEXT,
  p_whop_product_id TEXT,
  p_whop_plan_id TEXT,
  p_finotaur_user_id TEXT DEFAULT NULL
)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_user_id UUID;
  v_interval TEXT;
  v_price NUMERIC;
  v_expires_at TIMESTAMPTZ;
  v_is_new_user BOOLEAN := FALSE;
  v_new_user_id UUID;
  v_display_name TEXT;
  v_affiliate_code TEXT;
BEGIN
  -- ========================================
  -- STEP 1: Determine interval from plan_id
  -- ========================================
  
  IF p_whop_plan_id = 'plan_YoeD6wWBxss7Q' THEN
    v_interval := 'yearly';
    v_price := 300.00;
    v_expires_at := NOW() + INTERVAL '1 year';
  ELSE
    v_interval := 'monthly';
    v_price := 35.00;
    v_expires_at := NOW() + INTERVAL '1 month';
  END IF;

  -- ========================================
  -- STEP 2: Find User (multiple lookup methods)
  -- ========================================
  
  -- Try finotaur_user_id first
  IF p_finotaur_user_id IS NOT NULL AND p_finotaur_user_id != '' THEN
    BEGIN
      SELECT id INTO v_user_id 
      FROM profiles 
      WHERE id = p_finotaur_user_id::UUID;
    EXCEPTION WHEN OTHERS THEN
      NULL;
    END;
  END IF;
  
  -- Try email
  IF v_user_id IS NULL AND p_user_email IS NOT NULL AND p_user_email != '' THEN
    SELECT id INTO v_user_id 
    FROM profiles 
    WHERE LOWER(email) = LOWER(p_user_email);
  END IF;
  
  -- Try membership_id (for recurring)
  IF v_user_id IS NULL AND p_whop_membership_id IS NOT NULL THEN
    SELECT id INTO v_user_id 
    FROM profiles 
    WHERE top_secret_whop_membership_id = p_whop_membership_id;
  END IF;
  
  -- ========================================
  -- STEP 3: Create New User if Not Found
  -- ========================================
  
  IF v_user_id IS NULL THEN
    IF p_user_email IS NULL OR p_user_email = '' THEN
      RETURN jsonb_build_object(
        'success', false,
        'error', 'No email provided and user not found'
      );
    END IF;
    
    v_new_user_id := gen_random_uuid();
    v_display_name := SPLIT_PART(p_user_email, '@', 1);
    v_affiliate_code := UPPER(LEFT(v_display_name, 3)) || LPAD(FLOOR(RANDOM() * 10000)::TEXT, 4, '0');
    
    WHILE EXISTS (SELECT 1 FROM profiles WHERE affiliate_code = v_affiliate_code) LOOP
      v_affiliate_code := UPPER(LEFT(v_display_name, 3)) || LPAD(FLOOR(RANDOM() * 10000)::TEXT, 4, '0');
    END LOOP;
    
    INSERT INTO profiles (
      id, email, display_name, affiliate_code,
      account_type, subscription_status, max_trades,
      role, is_banned, onboarding_completed,
      newsletter_unsubscribe_token,
      created_at, updated_at
    ) VALUES (
      v_new_user_id, LOWER(p_user_email), v_display_name, v_affiliate_code,
      'free', NULL, 10,
      'user', FALSE, FALSE,
      encode(gen_random_bytes(32), 'hex'),
      NOW(), NOW()
    );
    
    v_user_id := v_new_user_id;
    v_is_new_user := TRUE;
    RAISE NOTICE 'üÜï Created new user: % with email: %', v_user_id, p_user_email;
  END IF;
  
  -- ========================================
  -- STEP 4: Update Top Secret Fields + Platform FREE
  -- (Does NOT touch newsletter or journal subscription)
  -- ========================================
  
 UPDATE profiles SET
    -- Top Secret fields
    top_secret_enabled = TRUE,
    top_secret_whop_membership_id = p_whop_membership_id,
    top_secret_started_at = COALESCE(top_secret_started_at, NOW()),
    top_secret_expires_at = v_expires_at,
    top_secret_interval = v_interval,
    top_secret_cancel_at_period_end = FALSE,
    top_secret_status = 'active',
    top_secret_unsubscribed_at = NULL,
    -- üî• Platform FREE - only if user has no platform subscription
    platform_plan = CASE 
      WHEN platform_plan IS NULL OR platform_plan = '' THEN 'free'
      ELSE platform_plan  -- Keep existing plan (core/pro/enterprise)
    END,
    platform_subscription_status = CASE 
      WHEN platform_subscription_status IS NULL OR platform_subscription_status = 'inactive' THEN 'active'
      ELSE platform_subscription_status  -- Keep existing status
    END,
    updated_at = NOW()
  WHERE id = v_user_id;
  
  -- ========================================
  -- STEP 5: Log Event
  -- ========================================
  
  INSERT INTO subscription_events (
    user_id, event_type, old_plan, new_plan, metadata
  ) VALUES (
    v_user_id,
    'payment_succeeded',
    'none',
    'top_secret',
    jsonb_build_object(
      'whop_membership_id', p_whop_membership_id,
      'whop_product_id', p_whop_product_id,
      'whop_plan_id', p_whop_plan_id,
      'whop_user_id', p_whop_user_id,
      'interval', v_interval,
      'price_usd', v_price,
      'is_new_user', v_is_new_user,
      'subscription_type', 'top_secret'
    )
  );
  
  -- ========================================
  -- STEP 6: Return Result
  -- ========================================
  
  RETURN jsonb_build_object(
    'success', true,
    'user_id', v_user_id,
    'email', p_user_email,
    'interval', v_interval,
    'price_usd', v_price,
    'expires_at', v_expires_at,
    'top_secret_status', 'active',
    'is_new_user', v_is_new_user
  );
  
EXCEPTION WHEN OTHERS THEN
  RETURN jsonb_build_object(
    'success', false,
    'error', SQLERRM,
    'sqlstate', SQLSTATE,
    'email', p_user_email,
    'finotaur_user_id', p_finotaur_user_id
  );
END;
$$;


-- ----------------------------------------
-- Handle Top Secret Payment
-- Called on: payment.succeeded (after first payment)
-- ----------------------------------------

DROP FUNCTION IF EXISTS handle_top_secret_payment(TEXT, TEXT, TEXT, TEXT, TEXT, NUMERIC, TEXT);

CREATE OR REPLACE FUNCTION handle_top_secret_payment(
  p_user_email TEXT,
  p_whop_user_id TEXT,
  p_whop_membership_id TEXT,
  p_whop_product_id TEXT,
  p_whop_plan_id TEXT,
  p_payment_amount NUMERIC,
  p_finotaur_user_id TEXT DEFAULT NULL
)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_user_id UUID;
  v_interval TEXT;
  v_expires_at TIMESTAMPTZ;
  v_old_status TEXT;
BEGIN
  -- Determine interval from plan_id
  IF p_whop_plan_id = 'plan_YoeD6wWBxss7Q' THEN
    v_interval := 'yearly';
    v_expires_at := NOW() + INTERVAL '1 year';
  ELSE
    v_interval := 'monthly';
    v_expires_at := NOW() + INTERVAL '1 month';
  END IF;

  -- Find user by multiple methods
  IF p_finotaur_user_id IS NOT NULL AND p_finotaur_user_id != '' THEN
    BEGIN
      SELECT id INTO v_user_id FROM profiles WHERE id = p_finotaur_user_id::UUID;
    EXCEPTION WHEN OTHERS THEN NULL;
    END;
  END IF;
  
  IF v_user_id IS NULL AND p_whop_membership_id IS NOT NULL THEN
    SELECT id INTO v_user_id FROM profiles WHERE top_secret_whop_membership_id = p_whop_membership_id;
  END IF;
  
  IF v_user_id IS NULL AND p_user_email IS NOT NULL AND p_user_email != '' THEN
    SELECT id INTO v_user_id FROM profiles WHERE LOWER(email) = LOWER(p_user_email);
  END IF;
  
  IF v_user_id IS NULL THEN
    RETURN jsonb_build_object(
      'success', false,
      'error', 'User not found for payment'
    );
  END IF;
  
  -- Get current status
  SELECT top_secret_status INTO v_old_status FROM profiles WHERE id = v_user_id;
  
  -- Update Top Secret fields ONLY
  UPDATE profiles SET
    top_secret_enabled = TRUE,
    top_secret_status = 'active',
    top_secret_expires_at = v_expires_at,
    top_secret_interval = v_interval,
    top_secret_cancel_at_period_end = FALSE,
    updated_at = NOW()
  WHERE id = v_user_id;
  
  -- Log event
  INSERT INTO subscription_events (
    user_id, event_type, old_plan, new_plan, metadata
  ) VALUES (
    v_user_id,
    'payment_succeeded',
    COALESCE(v_old_status, 'none'),
    'top_secret',
    jsonb_build_object(
      'whop_membership_id', p_whop_membership_id,
      'payment_amount', p_payment_amount,
      'interval', v_interval,
      'subscription_type', 'top_secret'
    )
  );
  
  RETURN jsonb_build_object(
    'success', true,
    'user_id', v_user_id,
    'top_secret_status', 'active',
    'previous_status', v_old_status,
    'expires_at', v_expires_at,
    'interval', v_interval,
    'payment_amount', p_payment_amount
  );
  
EXCEPTION WHEN OTHERS THEN
  RETURN jsonb_build_object('success', false, 'error', SQLERRM, 'sqlstate', SQLSTATE);
END;
$$;


-- ----------------------------------------
-- Deactivate Top Secret Subscription
-- Called on: membership.deactivated/canceled/went_invalid
-- ----------------------------------------

DROP FUNCTION IF EXISTS deactivate_top_secret_subscription(TEXT);

CREATE OR REPLACE FUNCTION deactivate_top_secret_subscription(p_whop_membership_id TEXT)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_user_id UUID;
  v_user_email TEXT;
  v_previous_status TEXT;
BEGIN
  SELECT id, email, top_secret_status 
  INTO v_user_id, v_user_email, v_previous_status
  FROM profiles 
  WHERE top_secret_whop_membership_id = p_whop_membership_id;
  
  IF v_user_id IS NULL THEN
    RETURN jsonb_build_object(
      'success', false,
      'error', 'User not found for membership: ' || p_whop_membership_id
    );
  END IF;
  
  -- Update Top Secret fields ONLY (does NOT touch newsletter or journal subscription)
  UPDATE profiles SET
    top_secret_enabled = FALSE,
    top_secret_status = 'cancelled',
    top_secret_cancel_at_period_end = FALSE,
    top_secret_unsubscribed_at = NOW(),
    updated_at = NOW()
  WHERE id = v_user_id;
  
  -- Log event
  INSERT INTO subscription_events (
    user_id, event_type, old_plan, new_plan, processed_at, metadata
  ) VALUES (
    v_user_id, 'cancelled', COALESCE(v_previous_status, 'active'), 'none', NOW(),
    jsonb_build_object(
      'whop_membership_id', p_whop_membership_id,
      'previous_status', v_previous_status,
      'subscription_type', 'top_secret'
    )
  );
  
  RETURN jsonb_build_object(
    'success', true,
    'user_id', v_user_id,
    'email', v_user_email,
    'previous_status', v_previous_status,
    'new_status', 'cancelled'
  );
  
EXCEPTION WHEN OTHERS THEN
  RETURN jsonb_build_object('success', false, 'error', SQLERRM, 'sqlstate', SQLSTATE);
END;
$$;


-- ----------------------------------------
-- Get Top Secret Status (for frontend)
-- ----------------------------------------

DROP FUNCTION IF EXISTS get_top_secret_status(UUID);

CREATE OR REPLACE FUNCTION get_top_secret_status(p_user_id UUID)
RETURNS TABLE (
  top_secret_enabled BOOLEAN,
  top_secret_status TEXT,
  top_secret_whop_membership_id TEXT,
  top_secret_started_at TIMESTAMPTZ,
  top_secret_expires_at TIMESTAMPTZ,
  top_secret_interval TEXT,
  top_secret_cancel_at_period_end BOOLEAN,
  days_until_expiry INTEGER,
  is_active BOOLEAN
)
LANGUAGE plpgsql
STABLE
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  RETURN QUERY
  SELECT 
    COALESCE(p.top_secret_enabled, FALSE),
    COALESCE(p.top_secret_status, 'inactive'),
    p.top_secret_whop_membership_id,
    p.top_secret_started_at,
    p.top_secret_expires_at,
    p.top_secret_interval,
    COALESCE(p.top_secret_cancel_at_period_end, FALSE),
    CASE 
      WHEN p.top_secret_expires_at IS NOT NULL 
      THEN GREATEST(0, EXTRACT(DAY FROM p.top_secret_expires_at - NOW())::INTEGER)
      ELSE NULL
    END,
    COALESCE(p.top_secret_enabled, FALSE) = TRUE 
      AND COALESCE(p.top_secret_status, 'inactive') = 'active'
  FROM profiles p
  WHERE p.id = p_user_id;
END;
$$;


-- ----------------------------------------
-- Cancel Top Secret Subscription (User initiated)
-- ----------------------------------------

DROP FUNCTION IF EXISTS cancel_top_secret_subscription(UUID);

CREATE OR REPLACE FUNCTION cancel_top_secret_subscription(p_user_id UUID)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_profile RECORD;
  v_membership_id TEXT;
BEGIN
  SELECT 
    top_secret_status,
    top_secret_whop_membership_id,
    top_secret_expires_at
  INTO v_profile
  FROM profiles 
  WHERE id = p_user_id;
  
  IF v_profile IS NULL THEN
    RETURN jsonb_build_object('success', false, 'error', 'User not found');
  END IF;
  
  IF v_profile.top_secret_status != 'active' THEN
    RETURN jsonb_build_object('success', false, 'error', 'No active subscription to cancel');
  END IF;
  
  v_membership_id := v_profile.top_secret_whop_membership_id;
  
  UPDATE profiles SET
    top_secret_cancel_at_period_end = TRUE,
    updated_at = NOW()
  WHERE id = p_user_id;
  
  INSERT INTO subscription_events (
    user_id, event_type, old_plan, new_plan, scheduled_at, metadata
  ) VALUES (
    p_user_id, 
    'cancel_scheduled', 
    'top_secret', 
    'none',
    v_profile.top_secret_expires_at,
    jsonb_build_object(
      'whop_membership_id', v_membership_id,
      'cancelled_by', 'user',
      'subscription_type', 'top_secret'
    )
  );
  
  RETURN jsonb_build_object(
    'success', true,
    'message', 'Subscription will be cancelled at period end',
    'membership_id', v_membership_id,
    'access_until', v_profile.top_secret_expires_at
  );
  
EXCEPTION WHEN OTHERS THEN
  RETURN jsonb_build_object('success', false, 'error', SQLERRM);
END;
$$;


-- ----------------------------------------
-- Reactivate Top Secret Subscription
-- (Undo pending cancellation)
-- ----------------------------------------

DROP FUNCTION IF EXISTS reactivate_top_secret_subscription(UUID);

CREATE OR REPLACE FUNCTION reactivate_top_secret_subscription(p_user_id UUID)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_profile RECORD;
BEGIN
  SELECT 
    top_secret_status,
    top_secret_cancel_at_period_end,
    top_secret_whop_membership_id
  INTO v_profile
  FROM profiles 
  WHERE id = p_user_id;
  
  IF v_profile IS NULL THEN
    RETURN jsonb_build_object('success', false, 'error', 'User not found');
  END IF;
  
  IF NOT COALESCE(v_profile.top_secret_cancel_at_period_end, FALSE) THEN
    RETURN jsonb_build_object('success', false, 'error', 'No pending cancellation to undo');
  END IF;
  
  UPDATE profiles SET
    top_secret_cancel_at_period_end = FALSE,
    updated_at = NOW()
  WHERE id = p_user_id;
  
  INSERT INTO subscription_events (
    user_id, event_type, old_plan, new_plan, metadata
  ) VALUES (
    p_user_id, 
    'reactivated', 
    'cancelling', 
    'top_secret',
    jsonb_build_object(
      'whop_membership_id', v_profile.top_secret_whop_membership_id,
      'subscription_type', 'top_secret'
    )
  );
  
  RETURN jsonb_build_object(
    'success', true,
    'message', 'Subscription reactivated successfully'
  );
  
EXCEPTION WHEN OTHERS THEN
  RETURN jsonb_build_object('success', false, 'error', SQLERRM);
END;
$$;


-- ============================================
-- GRANTS FOR TOP SECRET FUNCTIONS
-- ============================================

GRANT EXECUTE ON FUNCTION is_top_secret_product(TEXT) TO service_role, authenticated;
GRANT EXECUTE ON FUNCTION activate_top_secret_subscription(TEXT, TEXT, TEXT, TEXT, TEXT, TEXT) TO service_role;
GRANT EXECUTE ON FUNCTION handle_top_secret_payment(TEXT, TEXT, TEXT, TEXT, TEXT, NUMERIC, TEXT) TO service_role;
GRANT EXECUTE ON FUNCTION deactivate_top_secret_subscription(TEXT) TO service_role;
GRANT EXECUTE ON FUNCTION get_top_secret_status(UUID) TO authenticated, service_role;
GRANT EXECUTE ON FUNCTION cancel_top_secret_subscription(UUID) TO authenticated, service_role;
GRANT EXECUTE ON FUNCTION reactivate_top_secret_subscription(UUID) TO authenticated, service_role;


-- ============================================
-- VERIFICATION
-- ============================================

SELECT '========== TOP SECRET v1.0.0 VERIFICATION ==========' as section;

SELECT 
  'TOP SECRET COLUMNS' as check_type,
  CASE WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'profiles' AND column_name = 'top_secret_enabled') THEN '‚úÖ' ELSE '‚ùå' END as top_secret_enabled,
  CASE WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'profiles' AND column_name = 'top_secret_whop_membership_id') THEN '‚úÖ' ELSE '‚ùå' END as top_secret_membership_id,
  CASE WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'profiles' AND column_name = 'top_secret_status') THEN '‚úÖ' ELSE '‚ùå' END as top_secret_status,
  CASE WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'profiles' AND column_name = 'top_secret_interval') THEN '‚úÖ' ELSE '‚ùå' END as top_secret_interval,
  CASE WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'profiles' AND column_name = 'top_secret_expires_at') THEN '‚úÖ' ELSE '‚ùå' END as top_secret_expires_at;

SELECT 
  'TOP SECRET FUNCTIONS' as check_type,
  CASE WHEN EXISTS (SELECT 1 FROM pg_proc WHERE proname = 'is_top_secret_product') THEN '‚úÖ' ELSE '‚ùå' END as is_top_secret_product,
  CASE WHEN EXISTS (SELECT 1 FROM pg_proc WHERE proname = 'activate_top_secret_subscription') THEN '‚úÖ' ELSE '‚ùå' END as activate,
  CASE WHEN EXISTS (SELECT 1 FROM pg_proc WHERE proname = 'handle_top_secret_payment') THEN '‚úÖ' ELSE '‚ùå' END as handle_payment,
  CASE WHEN EXISTS (SELECT 1 FROM pg_proc WHERE proname = 'deactivate_top_secret_subscription') THEN '‚úÖ' ELSE '‚ùå' END as deactivate,
  CASE WHEN EXISTS (SELECT 1 FROM pg_proc WHERE proname = 'get_top_secret_status') THEN '‚úÖ' ELSE '‚ùå' END as get_status,
  CASE WHEN EXISTS (SELECT 1 FROM pg_proc WHERE proname = 'cancel_top_secret_subscription') THEN '‚úÖ' ELSE '‚ùå' END as cancel,
  CASE WHEN EXISTS (SELECT 1 FROM pg_proc WHERE proname = 'reactivate_top_secret_subscription') THEN '‚úÖ' ELSE '‚ùå' END as reactivate;

SELECT 
  'TOP SECRET PLAN' as check_type,
  CASE WHEN EXISTS (SELECT 1 FROM whop_plan_mapping WHERE finotaur_plan = 'top_secret' AND is_active = TRUE) THEN '‚úÖ Found' ELSE '‚ùå Missing' END as status,
  (SELECT whop_product_id FROM whop_plan_mapping WHERE finotaur_plan = 'top_secret' LIMIT 1) as product_id,
  (SELECT whop_plan_id FROM whop_plan_mapping WHERE finotaur_plan = 'top_secret' LIMIT 1) as plan_id;

SELECT 
  'PRODUCT CHECK' as check_type,
  is_top_secret_product('prod_nl6YXbLp4t5pz') as is_top_secret_correct,
  is_top_secret_product('prod_qlaV5Uu6LZlYn') as is_newsletter_not_top_secret;

SELECT 'üéâ TOP SECRET v1.0.0 COMPLETE!' as status;



-- ============================================
-- PART 15: GRANTS & PERMISSIONS
-- ============================================

GRANT EXECUTE ON FUNCTION activate_newsletter_subscription(TEXT, TEXT, TEXT, TEXT, TEXT) TO service_role;
GRANT EXECUTE ON FUNCTION deactivate_newsletter_subscription(TEXT) TO service_role;
GRANT EXECUTE ON FUNCTION handle_newsletter_payment(TEXT, TEXT, TEXT, TEXT, NUMERIC, TEXT) TO service_role;
GRANT EXECUTE ON FUNCTION get_newsletter_status(UUID) TO authenticated;
GRANT EXECUTE ON FUNCTION is_newsletter_product(TEXT) TO service_role, authenticated;


-- ============================================
-- PART 16: VERIFICATION
-- ============================================

SELECT '========== NEWSLETTER VERIFICATION ==========' as section;

SELECT 
  'WHOP_PLAN_MAPPING FIX' as check_type,
  CASE WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'whop_plan_mapping' AND column_name = 'whop_plan_id') THEN '‚úÖ whop_plan_id exists' ELSE '‚ùå whop_plan_id missing' END as status;

SELECT 
  'NEWSLETTER COLUMNS' as check_type,
  CASE WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'profiles' AND column_name = 'newsletter_enabled') THEN '‚úÖ' ELSE '‚ùå' END as newsletter_enabled,
  CASE WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'profiles' AND column_name = 'newsletter_whop_membership_id') THEN '‚úÖ' ELSE '‚ùå' END as newsletter_membership_id,
  CASE WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'profiles' AND column_name = 'newsletter_status') THEN '‚úÖ' ELSE '‚ùå' END as newsletter_status,
  CASE WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'profiles' AND column_name = 'newsletter_trial_ends_at') THEN '‚úÖ' ELSE '‚ùå' END as newsletter_trial_ends_at;

SELECT 
  'NEWSLETTER FUNCTIONS' as check_type,
  CASE WHEN EXISTS (SELECT 1 FROM pg_proc WHERE proname = 'activate_newsletter_subscription') THEN '‚úÖ' ELSE '‚ùå' END as activate_newsletter,
  CASE WHEN EXISTS (SELECT 1 FROM pg_proc WHERE proname = 'deactivate_newsletter_subscription') THEN '‚úÖ' ELSE '‚ùå' END as deactivate_newsletter,
  CASE WHEN EXISTS (SELECT 1 FROM pg_proc WHERE proname = 'handle_newsletter_payment') THEN '‚úÖ' ELSE '‚ùå' END as handle_newsletter_payment,
  CASE WHEN EXISTS (SELECT 1 FROM pg_proc WHERE proname = 'get_newsletter_status') THEN '‚úÖ' ELSE '‚ùå' END as get_newsletter_status,
  CASE WHEN EXISTS (SELECT 1 FROM pg_proc WHERE proname = 'is_newsletter_product') THEN '‚úÖ' ELSE '‚ùå' END as is_newsletter_product,
  CASE WHEN EXISTS (SELECT 1 FROM pg_proc WHERE proname = 'cancel_newsletter_subscription') THEN '‚úÖ' ELSE '‚ùå' END as cancel_newsletter,
  CASE WHEN EXISTS (SELECT 1 FROM pg_proc WHERE proname = 'reactivate_newsletter_subscription') THEN '‚úÖ' ELSE '‚ùå' END as reactivate_newsletter;

SELECT 
  'NEWSLETTER PLAN' as check_type,
  CASE WHEN EXISTS (SELECT 1 FROM whop_plan_mapping WHERE finotaur_plan = 'newsletter' AND is_active = TRUE) THEN '‚úÖ Found' ELSE '‚ùå Missing' END as status,
  (SELECT whop_product_id FROM whop_plan_mapping WHERE finotaur_plan = 'newsletter' LIMIT 1) as product_id,
  (SELECT whop_plan_id FROM whop_plan_mapping WHERE finotaur_plan = 'newsletter' LIMIT 1) as plan_id;

SELECT 
  'PRODUCT CHECK' as check_type,
  is_newsletter_product('prod_qlaV5Uu6LZlYn') as is_newsletter_prod_qlaV5Uu6LZlYn,
  is_newsletter_product('prod_ZaDN418HLst3r') as is_newsletter_basic_monthly;
-- =====================================================
-- NEWSLETTER ADMIN FIX - v4.0.0 COMPLETE
-- =====================================================
-- ◊™◊ô◊ß◊ï◊ü: get_newsletter_users + get_newsletter_stats + newsletter_send_logs
-- Date: 2025-12-13
-- 
-- ◊î◊®◊• ◊ê◊™ ◊õ◊ú ◊î◊ß◊ï◊ë◊• ◊ë-Supabase SQL Editor
-- =====================================================

-- =====================================================
-- PART 17: NEWSLETTER ADMIN FUNCTIONS - v5.0.0 FIXED
-- =====================================================
-- Date: 2025-12-13
-- Fix: Removed admin check that fails from Frontend context
-- =====================================================


-- ============================================
-- 17.1 get_newsletter_users - FIXED
-- ============================================

DROP FUNCTION IF EXISTS get_newsletter_users();

CREATE OR REPLACE FUNCTION get_newsletter_users()
RETURNS TABLE (
  id UUID,
  email TEXT,
  display_name TEXT,
  account_type TEXT,
  newsletter_enabled BOOLEAN,
  newsletter_status TEXT,
  newsletter_started_at TIMESTAMPTZ,
  newsletter_expires_at TIMESTAMPTZ,
  newsletter_trial_ends_at TIMESTAMPTZ,
  created_at TIMESTAMPTZ
)
LANGUAGE plpgsql
STABLE
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_caller_role TEXT;
BEGIN
  -- Get caller's role (returns NULL if not found)
  SELECT role INTO v_caller_role 
  FROM profiles 
  WHERE profiles.id = auth.uid();

  -- Allow if: admin/super_admin OR service_role OR no auth context (edge function)
  IF v_caller_role IS NOT NULL AND v_caller_role NOT IN ('admin', 'super_admin') THEN
    RAISE EXCEPTION 'Access denied: Admin only';
  END IF;

  RETURN QUERY
  SELECT 
    p.id,
    p.email::TEXT,
COALESCE(p.display_name, split_part(p.email, '@', 1))::TEXT as display_name,
    COALESCE(p.account_type, 'free')::TEXT as account_type,
    COALESCE(p.newsletter_enabled, FALSE)::BOOLEAN as newsletter_enabled,
    COALESCE(p.newsletter_status, 'inactive')::TEXT as newsletter_status,
    p.newsletter_started_at,
    p.newsletter_expires_at,
    p.newsletter_trial_ends_at,
    p.created_at
  FROM profiles p
  WHERE p.email IS NOT NULL
  ORDER BY 
    CASE COALESCE(p.newsletter_status, 'inactive')
      WHEN 'active' THEN 1 
      WHEN 'trial' THEN 2 
      WHEN 'cancelled' THEN 3
      ELSE 4 
    END,
    p.created_at DESC;
END;
$$;

GRANT EXECUTE ON FUNCTION get_newsletter_users() TO authenticated;
GRANT EXECUTE ON FUNCTION get_newsletter_users() TO service_role;


-- ============================================
-- 17.2 get_newsletter_stats - FIXED
-- ============================================

DROP FUNCTION IF EXISTS get_newsletter_stats();

CREATE OR REPLACE FUNCTION get_newsletter_stats()
RETURNS TABLE (
  total_subscribers BIGINT,
  active_subscribers BIGINT,
  trial_subscribers BIGINT,
  cancelled_subscribers BIGINT,
  total_users BIGINT
)
LANGUAGE plpgsql
STABLE
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_caller_role TEXT;
BEGIN
  SELECT role INTO v_caller_role 
  FROM profiles 
  WHERE profiles.id = auth.uid();

  IF v_caller_role IS NOT NULL AND v_caller_role NOT IN ('admin', 'super_admin') THEN
    RAISE EXCEPTION 'Access denied: Admin only';
  END IF;

  RETURN QUERY
  SELECT 
    COUNT(*) FILTER (WHERE COALESCE(p.newsletter_status, 'inactive') IN ('active', 'trial'))::BIGINT,
    COUNT(*) FILTER (WHERE COALESCE(p.newsletter_status, 'inactive') = 'active')::BIGINT,
    COUNT(*) FILTER (WHERE COALESCE(p.newsletter_status, 'inactive') = 'trial')::BIGINT,
    COUNT(*) FILTER (WHERE COALESCE(p.newsletter_status, 'inactive') = 'cancelled')::BIGINT,
    COUNT(*)::BIGINT
  FROM profiles p
  WHERE p.email IS NOT NULL;
END;
$$;

GRANT EXECUTE ON FUNCTION get_newsletter_stats() TO authenticated;
GRANT EXECUTE ON FUNCTION get_newsletter_stats() TO service_role;


-- ============================================
-- 17.3 get_newsletter_config - FIXED
-- ============================================

DROP FUNCTION IF EXISTS get_newsletter_config();

CREATE OR REPLACE FUNCTION get_newsletter_config()
RETURNS TABLE(
  config_key TEXT, 
  config_value JSONB, 
  description TEXT,
  updated_at TIMESTAMPTZ
)
LANGUAGE plpgsql
STABLE
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_caller_role TEXT;
BEGIN
  SELECT role INTO v_caller_role 
  FROM profiles 
  WHERE profiles.id = auth.uid();

  IF v_caller_role IS NOT NULL AND v_caller_role NOT IN ('admin', 'super_admin') THEN
    RAISE EXCEPTION 'Access denied: Admin only';
  END IF;

  RETURN QUERY
  SELECT 
    nc.config_key, 
    nc.config_value, 
    nc.description,
    nc.updated_at
  FROM newsletter_config nc
  ORDER BY nc.config_key;
END;
$$;

GRANT EXECUTE ON FUNCTION get_newsletter_config() TO authenticated;
GRANT EXECUTE ON FUNCTION get_newsletter_config() TO service_role;


-- ============================================
-- 17.4 toggle_newsletter_config - FIXED
-- ============================================

DROP FUNCTION IF EXISTS toggle_newsletter_config(TEXT, BOOLEAN);

CREATE OR REPLACE FUNCTION toggle_newsletter_config(
  p_config_key TEXT,
  p_enabled BOOLEAN
)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_admin_id UUID;
  v_caller_role TEXT;
BEGIN
  SELECT id, role INTO v_admin_id, v_caller_role
  FROM profiles 
  WHERE profiles.id = auth.uid();
  
  IF v_caller_role IS NULL OR v_caller_role NOT IN ('admin', 'super_admin') THEN
    RAISE EXCEPTION 'Access denied: Admin only';
  END IF;

  INSERT INTO newsletter_config (config_key, config_value, updated_at, updated_by)
  VALUES (p_config_key, jsonb_build_object('enabled', p_enabled), NOW(), v_admin_id)
  ON CONFLICT (config_key) DO UPDATE SET
    config_value = jsonb_build_object('enabled', p_enabled),
    updated_at = NOW(),
    updated_by = v_admin_id;
  
  RETURN jsonb_build_object(
    'success', true, 
    'key', p_config_key, 
    'enabled', p_enabled
  );
END;
$$;

GRANT EXECUTE ON FUNCTION toggle_newsletter_config(TEXT, BOOLEAN) TO authenticated;


-- ============================================
-- 17.5 get_newsletter_inclusion_status - FIXED
-- ============================================

DROP FUNCTION IF EXISTS get_newsletter_inclusion_status();

CREATE OR REPLACE FUNCTION get_newsletter_inclusion_status()
RETURNS TABLE(
  premium_included BOOLEAN,
  basic_included BOOLEAN,
  total_recipients BIGINT,
  newsletter_subscribers BIGINT,
  premium_recipients BIGINT,
  basic_recipients BIGINT
)
LANGUAGE plpgsql
STABLE
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_premium BOOLEAN;
  v_basic BOOLEAN;
  v_newsletter_subs BIGINT;
  v_premium_users BIGINT;
  v_basic_users BIGINT;
  v_caller_role TEXT;
BEGIN
  SELECT role INTO v_caller_role 
  FROM profiles 
  WHERE profiles.id = auth.uid();

  IF v_caller_role IS NOT NULL AND v_caller_role NOT IN ('admin', 'super_admin') THEN
    RAISE EXCEPTION 'Access denied: Admin only';
  END IF;

  SELECT COALESCE((config_value->>'enabled')::boolean, FALSE) INTO v_premium
  FROM newsletter_config WHERE config_key = 'premium_included';
  v_premium := COALESCE(v_premium, FALSE);
  
  SELECT COALESCE((config_value->>'enabled')::boolean, FALSE) INTO v_basic
  FROM newsletter_config WHERE config_key = 'basic_included';
  v_basic := COALESCE(v_basic, FALSE);

  SELECT COUNT(*) INTO v_newsletter_subs
  FROM profiles 
  WHERE COALESCE(newsletter_status, 'inactive') IN ('active', 'trial')
    AND email IS NOT NULL;

  SELECT COUNT(*) INTO v_premium_users
  FROM profiles 
  WHERE account_type = 'premium' 
    AND subscription_status = 'active'
    AND email IS NOT NULL;

  SELECT COUNT(*) INTO v_basic_users
  FROM profiles 
  WHERE account_type = 'basic' 
    AND subscription_status = 'active'
    AND email IS NOT NULL;

  RETURN QUERY
  SELECT 
    v_premium as premium_included,
    v_basic as basic_included,
    (v_newsletter_subs + 
     CASE WHEN v_premium THEN v_premium_users ELSE 0 END + 
     CASE WHEN v_basic THEN v_basic_users ELSE 0 END)::BIGINT as total_recipients,
    v_newsletter_subs as newsletter_subscribers,
    CASE WHEN v_premium THEN v_premium_users ELSE 0::BIGINT END as premium_recipients,
    CASE WHEN v_basic THEN v_basic_users ELSE 0::BIGINT END as basic_recipients;
END;
$$;

GRANT EXECUTE ON FUNCTION get_newsletter_inclusion_status() TO authenticated;
GRANT EXECUTE ON FUNCTION get_newsletter_inclusion_status() TO service_role;


-- ============================================
-- 17.6 toggle_newsletter_status - FIXED
-- ============================================

DROP FUNCTION IF EXISTS toggle_newsletter_status(UUID, BOOLEAN);

CREATE OR REPLACE FUNCTION toggle_newsletter_status(
  p_user_id UUID,
  p_enabled BOOLEAN
)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_email TEXT;
  v_current_status TEXT;
  v_caller_role TEXT;
BEGIN
  SELECT role INTO v_caller_role 
  FROM profiles 
  WHERE profiles.id = auth.uid();

  IF v_caller_role IS NULL OR v_caller_role NOT IN ('admin', 'super_admin') THEN
    RAISE EXCEPTION 'Access denied: Admin only';
  END IF;

  SELECT email, newsletter_status
  INTO v_email, v_current_status
  FROM profiles 
  WHERE id = p_user_id;
  
  IF v_email IS NULL THEN
    RETURN jsonb_build_object('success', false, 'error', 'User not found');
  END IF;
  
  UPDATE profiles 
  SET 
    newsletter_enabled = p_enabled,
    newsletter_status = CASE WHEN p_enabled THEN 'active' ELSE 'inactive' END,
    newsletter_started_at = CASE 
      WHEN p_enabled AND newsletter_started_at IS NULL THEN NOW()
      ELSE newsletter_started_at
    END,
    updated_at = NOW()
  WHERE id = p_user_id;
  
  RETURN jsonb_build_object(
    'success', true,
    'user_id', p_user_id,
    'email', v_email,
    'newsletter_enabled', p_enabled,
    'previous_status', v_current_status
  );
END;
$$;

GRANT EXECUTE ON FUNCTION toggle_newsletter_status(UUID, BOOLEAN) TO authenticated;


-- ============================================
-- 17.7 TABLES & RLS
-- ============================================

-- newsletter_send_logs
CREATE TABLE IF NOT EXISTS newsletter_send_logs (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  sent_at TIMESTAMPTZ DEFAULT NOW(),
  subject TEXT NOT NULL,
  recipient_count INTEGER NOT NULL,
  segments TEXT[] DEFAULT '{}',
  admin_note TEXT,
  sent_by UUID REFERENCES auth.users(id),
  metadata JSONB DEFAULT '{}',
  created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_newsletter_send_logs_sent_at ON newsletter_send_logs(sent_at DESC);

ALTER TABLE newsletter_send_logs ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Admins can read newsletter send logs" ON newsletter_send_logs;
DROP POLICY IF EXISTS "Service role full access" ON newsletter_send_logs;

CREATE POLICY "Admins can read newsletter send logs" ON newsletter_send_logs
  FOR SELECT USING (
    EXISTS (SELECT 1 FROM profiles WHERE profiles.id = auth.uid() AND profiles.role IN ('admin', 'super_admin'))
  );

CREATE POLICY "Service role full access" ON newsletter_send_logs
  FOR ALL USING (TRUE) WITH CHECK (TRUE);

GRANT SELECT ON newsletter_send_logs TO authenticated;
GRANT ALL ON newsletter_send_logs TO service_role;

-- newsletter_config
CREATE TABLE IF NOT EXISTS newsletter_config (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  config_key TEXT UNIQUE NOT NULL,
  config_value JSONB NOT NULL DEFAULT '{}',
  description TEXT,
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  updated_by UUID REFERENCES auth.users(id)
);

ALTER TABLE newsletter_config ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Admins can read newsletter config" ON newsletter_config;
DROP POLICY IF EXISTS "Admins can manage newsletter config" ON newsletter_config;
DROP POLICY IF EXISTS "Service role full access to newsletter config" ON newsletter_config;

CREATE POLICY "Admins can read newsletter config" ON newsletter_config
  FOR SELECT USING (
    EXISTS (SELECT 1 FROM profiles WHERE profiles.id = auth.uid() AND profiles.role IN ('admin', 'super_admin'))
  );

CREATE POLICY "Admins can manage newsletter config" ON newsletter_config
  FOR ALL USING (
    EXISTS (SELECT 1 FROM profiles WHERE profiles.id = auth.uid() AND profiles.role IN ('admin', 'super_admin'))
  );

CREATE POLICY "Service role full access to newsletter config" ON newsletter_config
  FOR ALL USING (TRUE) WITH CHECK (TRUE);

INSERT INTO newsletter_config (config_key, config_value, description) VALUES
  ('premium_included', '{"enabled": false}', 'Premium users receive newsletter'),
  ('basic_included', '{"enabled": false}', 'Basic users receive newsletter')
ON CONFLICT (config_key) DO NOTHING;

GRANT SELECT, UPDATE ON newsletter_config TO authenticated;
GRANT ALL ON newsletter_config TO service_role;


-- ============================================
-- 17.8 VERIFICATION
-- ============================================

SELECT '========== PART 17 NEWSLETTER ADMIN v5.0.0 ==========' as section;

SELECT 
  'FUNCTIONS' as check_type,
  CASE WHEN EXISTS (SELECT 1 FROM pg_proc WHERE proname = 'get_newsletter_users') THEN '‚úÖ' ELSE '‚ùå' END as get_newsletter_users,
  CASE WHEN EXISTS (SELECT 1 FROM pg_proc WHERE proname = 'get_newsletter_stats') THEN '‚úÖ' ELSE '‚ùå' END as get_newsletter_stats,
  CASE WHEN EXISTS (SELECT 1 FROM pg_proc WHERE proname = 'get_newsletter_config') THEN '‚úÖ' ELSE '‚ùå' END as get_newsletter_config,
  CASE WHEN EXISTS (SELECT 1 FROM pg_proc WHERE proname = 'toggle_newsletter_config') THEN '‚úÖ' ELSE '‚ùå' END as toggle_newsletter_config,
  CASE WHEN EXISTS (SELECT 1 FROM pg_proc WHERE proname = 'get_newsletter_inclusion_status') THEN '‚úÖ' ELSE '‚ùå' END as get_newsletter_inclusion_status,
  CASE WHEN EXISTS (SELECT 1 FROM pg_proc WHERE proname = 'toggle_newsletter_status') THEN '‚úÖ' ELSE '‚ùå' END as toggle_newsletter_status;

SELECT 'TABLES' as check_type,
  CASE WHEN EXISTS (SELECT 1 FROM pg_tables WHERE tablename = 'newsletter_send_logs') THEN '‚úÖ' ELSE '‚ùå' END as newsletter_send_logs,
  CASE WHEN EXISTS (SELECT 1 FROM pg_tables WHERE tablename = 'newsletter_config') THEN '‚úÖ' ELSE '‚ùå' END as newsletter_config;

SELECT 'üéâ PART 17 COMPLETE!' as status;
-- ============================================
-- PART 18: NEWSLETTER SEND LOGS
-- ============================================

CREATE TABLE IF NOT EXISTS newsletter_send_logs (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  sent_at TIMESTAMPTZ DEFAULT NOW(),
  subject TEXT NOT NULL,
  recipient_count INTEGER NOT NULL,
  segments TEXT[] DEFAULT '{}',
  admin_note TEXT,
  sent_by UUID REFERENCES auth.users(id),
  metadata JSONB DEFAULT '{}',
  created_at TIMESTAMPTZ DEFAULT NOW()
);

COMMENT ON TABLE newsletter_send_logs IS 'Tracks all newsletter sends for admin dashboard';
COMMENT ON COLUMN newsletter_send_logs.segments IS 'Array of audience segments: newsletter_active, newsletter_trial, journal_basic, journal_premium';
COMMENT ON COLUMN newsletter_send_logs.admin_note IS 'Optional admin note that was included in the email';

CREATE INDEX IF NOT EXISTS idx_newsletter_send_logs_sent_at 
ON newsletter_send_logs(sent_at DESC);

CREATE INDEX IF NOT EXISTS idx_newsletter_send_logs_sent_by 
ON newsletter_send_logs(sent_by);

ALTER TABLE newsletter_send_logs ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Admins can read newsletter send logs" ON newsletter_send_logs;
CREATE POLICY "Admins can read newsletter send logs" ON newsletter_send_logs
  FOR SELECT USING (
    EXISTS (
      SELECT 1 FROM profiles 
      WHERE profiles.id = auth.uid() 
      AND profiles.role IN ('admin', 'super_admin')
    )
  );

DROP POLICY IF EXISTS "Service role can insert newsletter send logs" ON newsletter_send_logs;
CREATE POLICY "Service role can insert newsletter send logs" ON newsletter_send_logs
  FOR INSERT WITH CHECK (TRUE);

DROP POLICY IF EXISTS "Service role full access to newsletter send logs" ON newsletter_send_logs;
CREATE POLICY "Service role full access to newsletter send logs" ON newsletter_send_logs
  FOR ALL USING (auth.role() = 'service_role');

GRANT SELECT ON newsletter_send_logs TO authenticated;
GRANT ALL ON newsletter_send_logs TO service_role;

SELECT '========== NEWSLETTER SEND LOGS ==========' as section;

SELECT 
  'NEWSLETTER_SEND_LOGS TABLE' as check_type,
  CASE WHEN EXISTS (SELECT 1 FROM pg_tables WHERE tablename = 'newsletter_send_logs') 
    THEN '‚úÖ Created' ELSE '‚ùå Missing' END as status;

SELECT 
  'INDEXES' as check_type,
  CASE WHEN EXISTS (SELECT 1 FROM pg_indexes WHERE indexname = 'idx_newsletter_send_logs_sent_at') 
    THEN '‚úÖ' ELSE '‚ùå' END as sent_at_index,
  CASE WHEN EXISTS (SELECT 1 FROM pg_indexes WHERE indexname = 'idx_newsletter_send_logs_sent_by') 
    THEN '‚úÖ' ELSE '‚ùå' END as sent_by_index;


-- ============================================
-- PART 19: NEWSLETTER REPORTS TABLE
-- ============================================
-- For War Zone Report History & Viewer
-- ============================================

CREATE TABLE IF NOT EXISTS newsletter_reports (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  report_date DATE NOT NULL UNIQUE,
  subject TEXT NOT NULL,
  preheader TEXT,
  content JSONB,              -- Raw structured content from Claude
  html_content TEXT,          -- Rendered HTML
  recipient_count INTEGER DEFAULT 0,
  sent_count INTEGER DEFAULT 0,
  qa_score NUMERIC(3,2),      -- Quality score (0.00-1.00)
  generated_at TIMESTAMPTZ DEFAULT NOW(),
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

COMMENT ON TABLE newsletter_reports IS 'Stores daily War Zone newsletter reports';
COMMENT ON COLUMN newsletter_reports.content IS 'Structured JSON content from newsletter generation';
COMMENT ON COLUMN newsletter_reports.html_content IS 'Full rendered HTML for display';
COMMENT ON COLUMN newsletter_reports.qa_score IS 'Quality assurance score from AI validation';

-- Index for fast date lookups
CREATE INDEX IF NOT EXISTS idx_newsletter_reports_date 
ON newsletter_reports(report_date DESC);

-- RLS
ALTER TABLE newsletter_reports ENABLE ROW LEVEL SECURITY;

-- Policy: Authenticated users can read
DROP POLICY IF EXISTS "Users can read newsletter reports" ON newsletter_reports;
CREATE POLICY "Users can read newsletter reports" ON newsletter_reports
  FOR SELECT TO authenticated USING (true);

-- Policy: Service role full access
DROP POLICY IF EXISTS "Service role full access to reports" ON newsletter_reports;
CREATE POLICY "Service role full access to reports" ON newsletter_reports
  FOR ALL USING (auth.role() = 'service_role');

-- Grants
GRANT SELECT ON newsletter_reports TO authenticated;
GRANT ALL ON newsletter_reports TO service_role;

-- Verification
SELECT '========== PART 19: NEWSLETTER REPORTS ==========' as section;

SELECT 
  'NEWSLETTER_REPORTS TABLE' as check_type,
  CASE WHEN EXISTS (SELECT 1 FROM pg_tables WHERE tablename = 'newsletter_reports') 
    THEN '‚úÖ Created' ELSE '‚ùå Missing' END as status;



-- =============================================
-- AFFILIATE PAYOUTS - PAYPAL INTEGRATION
-- =============================================

DO $$ 
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_name = 'affiliates' AND column_name = 'paypal_email'
    ) THEN
        ALTER TABLE affiliates ADD COLUMN paypal_email TEXT;
    END IF;
END $$;

DO $$ 
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_name = 'affiliate_payouts' AND column_name = 'paypal_batch_id'
    ) THEN
        ALTER TABLE affiliate_payouts ADD COLUMN paypal_batch_id TEXT;
    END IF;
    
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_name = 'affiliate_payouts' AND column_name = 'paypal_payout_item_id'
    ) THEN
        ALTER TABLE affiliate_payouts ADD COLUMN paypal_payout_item_id TEXT;
    END IF;
    
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_name = 'affiliate_payouts' AND column_name = 'paypal_transaction_status'
    ) THEN
        ALTER TABLE affiliate_payouts ADD COLUMN paypal_transaction_status TEXT;
    END IF;
    
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_name = 'affiliate_payouts' AND column_name = 'payment_email'
    ) THEN
        ALTER TABLE affiliate_payouts ADD COLUMN payment_email TEXT;
    END IF;
    
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_name = 'affiliate_payouts' AND column_name = 'paypal_fee_usd'
    ) THEN
        ALTER TABLE affiliate_payouts ADD COLUMN paypal_fee_usd DECIMAL(10,2) DEFAULT 0;
    END IF;
    
    IF EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_name = 'affiliate_payouts' AND column_name = 'transaction_id'
    ) AND NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_name = 'affiliate_payouts' AND column_name = 'paypal_transaction_id'
    ) THEN
        ALTER TABLE affiliate_payouts RENAME COLUMN transaction_id TO paypal_transaction_id;
    END IF;
    
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_name = 'affiliate_payouts' AND column_name = 'paypal_transaction_id'
    ) THEN
        ALTER TABLE affiliate_payouts ADD COLUMN paypal_transaction_id TEXT;
    END IF;
END $$;

CREATE INDEX IF NOT EXISTS idx_affiliate_payouts_paypal_batch_id 
ON affiliate_payouts(paypal_batch_id);

CREATE INDEX IF NOT EXISTS idx_affiliate_payouts_status 
ON affiliate_payouts(status);

CREATE INDEX IF NOT EXISTS idx_affiliates_paypal_email 
ON affiliates(paypal_email);

COMMENT ON COLUMN affiliates.paypal_email IS 'PayPal email address for receiving payouts';
COMMENT ON COLUMN affiliate_payouts.paypal_batch_id IS 'PayPal Payouts API batch ID';
COMMENT ON COLUMN affiliate_payouts.paypal_payout_item_id IS 'PayPal individual payout item ID';
COMMENT ON COLUMN affiliate_payouts.paypal_transaction_id IS 'PayPal transaction ID after successful payout';
COMMENT ON COLUMN affiliate_payouts.paypal_transaction_status IS 'PayPal transaction status (SUCCESS, FAILED, PENDING, UNCLAIMED, RETURNED, ONHOLD, BLOCKED, REFUNDED, REVERSED)';
COMMENT ON COLUMN affiliate_payouts.payment_email IS 'PayPal email used for this specific payout';
COMMENT ON COLUMN affiliate_payouts.paypal_fee_usd IS 'Fee charged by PayPal for this payout';


-- =============================================
-- NEWSLETTER COMPLETE SETUP - UNIFIED V3 (FIXED)
-- =============================================

CREATE OR REPLACE FUNCTION generate_newsletter_token()
RETURNS TRIGGER AS $$
BEGIN
  IF NEW.newsletter_unsubscribe_token IS NULL THEN
    NEW.newsletter_unsubscribe_token := encode(gen_random_bytes(32), 'hex');
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS set_newsletter_token_on_insert ON profiles;
CREATE TRIGGER set_newsletter_token_on_insert
  BEFORE INSERT ON profiles
  FOR EACH ROW
  EXECUTE FUNCTION generate_newsletter_token();

UPDATE profiles 
SET newsletter_unsubscribe_token = encode(gen_random_bytes(32), 'hex')
WHERE newsletter_unsubscribe_token IS NULL;

DO $$ 
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns 
    WHERE table_name = 'profiles' AND column_name = 'newsletter_paid'
  ) THEN
    ALTER TABLE profiles ADD COLUMN newsletter_paid BOOLEAN DEFAULT false;
  END IF;
  
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns 
    WHERE table_name = 'profiles' AND column_name = 'newsletter_paid_at'
  ) THEN
    ALTER TABLE profiles ADD COLUMN newsletter_paid_at TIMESTAMPTZ;
  END IF;
  
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns 
    WHERE table_name = 'profiles' AND column_name = 'whop_newsletter_membership_id'
  ) THEN
    ALTER TABLE profiles ADD COLUMN whop_newsletter_membership_id TEXT;
  END IF;
END $$;

CREATE INDEX IF NOT EXISTS idx_profiles_newsletter_paid 
ON profiles(newsletter_paid) WHERE newsletter_paid = true;

CREATE OR REPLACE FUNCTION handle_whop_newsletter_subscription(
  p_user_email TEXT,
  p_membership_id TEXT,
  p_action TEXT
)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_user_id UUID;
  v_result JSONB;
BEGIN
  SELECT id INTO v_user_id
  FROM profiles
  WHERE LOWER(email) = LOWER(p_user_email)
  LIMIT 1;
  
  IF v_user_id IS NULL THEN
    RETURN jsonb_build_object('success', false, 'error', 'User not found');
  END IF;
  
  IF p_action = 'subscribe' THEN
    UPDATE profiles
    SET 
      newsletter_paid = true,
      newsletter_paid_at = NOW(),
      newsletter_enabled = true,
      whop_newsletter_membership_id = p_membership_id
    WHERE id = v_user_id;
    
    v_result := jsonb_build_object('success', true, 'action', 'subscribed', 'user_id', v_user_id);
    
  ELSIF p_action = 'unsubscribe' THEN
    UPDATE profiles
    SET 
      newsletter_paid = false,
      whop_newsletter_membership_id = NULL
    WHERE id = v_user_id;
    
    v_result := jsonb_build_object('success', true, 'action', 'unsubscribed', 'user_id', v_user_id);
  ELSE
    v_result := jsonb_build_object('success', false, 'error', 'Invalid action');
  END IF;
  
  RETURN v_result;
END;
$$;

DO $$ 
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns 
    WHERE table_name = 'newsletters' AND column_name = 'opened_count'
  ) THEN
    ALTER TABLE newsletters ADD COLUMN opened_count INTEGER DEFAULT 0;
  END IF;
  
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns 
    WHERE table_name = 'newsletters' AND column_name = 'clicked_count'
  ) THEN
    ALTER TABLE newsletters ADD COLUMN clicked_count INTEGER DEFAULT 0;
  END IF;
END $$;

GRANT EXECUTE ON FUNCTION handle_whop_newsletter_subscription(TEXT, TEXT, TEXT) TO service_role;


-- =====================================================
-- FINOTAUR NEWSLETTER CRON - SUPABASE SETUP
-- =====================================================
CREATE TABLE IF NOT EXISTS newsletter_cron_logs (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  status TEXT NOT NULL CHECK (status IN ('success', 'failed', 'skipped', 'started', 'completed', 'error')),
  newsletter_id UUID,
  recipient_count INTEGER,
  sent_count INTEGER,
  failed_count INTEGER,
  error_message TEXT,
  http_status INTEGER,
  response_body JSONB,
  triggered_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  completed_at TIMESTAMPTZ,                          -- üÜï ◊û◊™◊ô ◊°◊ô◊ô◊ù
  duration_ms INTEGER,
  subject TEXT,                                       -- üÜï ◊†◊ï◊©◊ê ◊î◊†◊ô◊ï◊ñ◊ú◊ò◊®
  qa_score INTEGER,                                   -- üÜï ◊¶◊ô◊ï◊ü QA
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Add columns if table exists
DO $$ 
BEGIN
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns 
    WHERE table_name = 'newsletter_cron_logs' AND column_name = 'completed_at') THEN
    ALTER TABLE newsletter_cron_logs ADD COLUMN completed_at TIMESTAMPTZ;
  END IF;
  
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns 
    WHERE table_name = 'newsletter_cron_logs' AND column_name = 'subject') THEN
    ALTER TABLE newsletter_cron_logs ADD COLUMN subject TEXT;
  END IF;
  
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns 
    WHERE table_name = 'newsletter_cron_logs' AND column_name = 'qa_score') THEN
    ALTER TABLE newsletter_cron_logs ADD COLUMN qa_score INTEGER;
  END IF;
END $$;

-- Update constraint
ALTER TABLE newsletter_cron_logs DROP CONSTRAINT IF EXISTS newsletter_cron_logs_status_check;
ALTER TABLE newsletter_cron_logs ADD CONSTRAINT newsletter_cron_logs_status_check 
  CHECK (status IN ('success', 'failed', 'skipped', 'started', 'completed', 'error'));


CREATE INDEX IF NOT EXISTS idx_newsletter_cron_logs_triggered 
ON newsletter_cron_logs(triggered_at DESC);

ALTER TABLE newsletter_cron_logs ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Service role full access" ON newsletter_cron_logs;
CREATE POLICY "Service role full access" ON newsletter_cron_logs
  FOR ALL USING (true);

CREATE OR REPLACE FUNCTION invoke_newsletter_cron()
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_request_id BIGINT;
BEGIN
  SELECT net.http_post(
    url := 'https://xnypsjnoeserfflqnlqt.supabase.co/functions/v1/newsletter-cron?secret=YOUR_CRON_SECRET_HERE',
    headers := '{"Content-Type": "application/json"}'::jsonb,
    body := jsonb_build_object(
      'trigger', 'scheduled_cron',
      'timestamp', NOW()
    ),
    timeout_milliseconds := 300000
  ) INTO v_request_id;

  -- Log the trigger
  INSERT INTO newsletter_cron_logs (status, triggered_at, response_body)
  VALUES ('started', NOW(), jsonb_build_object('request_id', v_request_id));

  RAISE NOTICE 'üì® Newsletter cron triggered, request_id: %', v_request_id;
END;
$$;

DO $$
BEGIN
  PERFORM cron.unschedule('newsletter-daily-cron');
EXCEPTION WHEN OTHERS THEN
  NULL;
END $$;

DO $$
BEGIN
  PERFORM cron.unschedule('newsletter-daily-cron');
  RAISE NOTICE '‚úÖ Unscheduled existing job';
EXCEPTION WHEN OTHERS THEN
  RAISE NOTICE '‚ÑπÔ∏è No existing job to unschedule';
END $$;

-- Schedule cron job using UTC time
-- 14:00 UTC = 9:00 AM EST (winter) / 10:00 AM EDT (summer)
SELECT cron.schedule(
  'newsletter-daily-cron',      -- job name (unique)
  '0 14 * * 1-5',               -- Mon-Fri at 14:00 UTC
  $$SELECT invoke_newsletter_cron()$$  -- SQL to execute
);

SELECT 
  COUNT(*) as total_users,
  COUNT(newsletter_unsubscribe_token) as with_token,
  COUNT(*) FILTER (WHERE newsletter_paid = true) as paid_subscribers,
  COUNT(*) FILTER (WHERE newsletter_enabled = true) as enabled_users
FROM profiles
WHERE email IS NOT NULL AND deleted_at IS NULL;

SELECT jobname, schedule, active 
FROM cron.job 
WHERE jobname = 'newsletter-daily-cron';
-- =====================================================
-- FINOTAUR NEWSLETTER CONFIG - Dynamic Audience Settings
-- =====================================================
-- Version: 1.2.0 (FIXED)
-- Date: 2025-12-07
-- =====================================================


-- ============================================
-- NEWSLETTER CONFIG TABLE
-- ============================================

CREATE TABLE IF NOT EXISTS newsletter_config (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  config_key TEXT UNIQUE NOT NULL,
  config_value JSONB NOT NULL DEFAULT '{}',
  description TEXT,
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  updated_by UUID REFERENCES auth.users(id)
);

COMMENT ON TABLE newsletter_config IS 'Admin-controlled newsletter settings';
COMMENT ON COLUMN newsletter_config.config_key IS 'Unique identifier for the setting';
COMMENT ON COLUMN newsletter_config.config_value IS 'JSON value containing the setting data';


-- ============================================
-- DEFAULT SETTINGS
-- ============================================

INSERT INTO newsletter_config (config_key, config_value, description) VALUES
  ('premium_included', '{"enabled": false}', 'Premium journal users automatically receive newsletter for free'),
  ('basic_included', '{"enabled": false}', 'Basic journal users automatically receive newsletter for free'),
  ('send_days', '{"days": ["mon","tue","wed","thu","fri"]}', 'Days of week to send newsletter (for cron)'),
  ('send_time', '{"hour": 9, "minute": 0, "timezone": "America/New_York"}', 'Daily send time (for cron)')
ON CONFLICT (config_key) DO NOTHING;


-- ============================================
-- RPC FUNCTIONS
-- ============================================

DROP FUNCTION IF EXISTS get_newsletter_config();

CREATE OR REPLACE FUNCTION get_newsletter_config()
RETURNS TABLE(
  config_key TEXT, 
  config_value JSONB, 
  description TEXT,
  updated_at TIMESTAMPTZ
)
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM profiles 
    WHERE profiles.id = auth.uid() 
    AND profiles.role IN ('admin', 'super_admin')
  ) THEN
    RAISE EXCEPTION 'Access denied: Admin only';
  END IF;

  RETURN QUERY
  SELECT 
    nc.config_key, 
    nc.config_value, 
    nc.description,
    nc.updated_at
  FROM newsletter_config nc
  ORDER BY nc.config_key;
END;
$$;


DROP FUNCTION IF EXISTS update_newsletter_config(TEXT, JSONB);

CREATE OR REPLACE FUNCTION update_newsletter_config(
  p_config_key TEXT,
  p_config_value JSONB
)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_admin_id UUID;
BEGIN
  SELECT id INTO v_admin_id FROM profiles 
  WHERE profiles.id = auth.uid() 
  AND profiles.role IN ('admin', 'super_admin');
  
  IF v_admin_id IS NULL THEN
    RAISE EXCEPTION 'Access denied: Admin only';
  END IF;

  INSERT INTO newsletter_config (config_key, config_value, updated_at, updated_by)
  VALUES (p_config_key, p_config_value, NOW(), v_admin_id)
  ON CONFLICT (config_key) DO UPDATE SET
    config_value = EXCLUDED.config_value,
    updated_at = NOW(),
    updated_by = v_admin_id;
  
  RETURN jsonb_build_object(
    'success', true, 
    'key', p_config_key, 
    'value', p_config_value
  );
END;
$$;


DROP FUNCTION IF EXISTS toggle_newsletter_config(TEXT, BOOLEAN);

CREATE OR REPLACE FUNCTION toggle_newsletter_config(
  p_config_key TEXT,
  p_enabled BOOLEAN
)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  RETURN update_newsletter_config(
    p_config_key, 
    jsonb_build_object('enabled', p_enabled)
  );
END;
$$;


DROP FUNCTION IF EXISTS get_newsletter_recipients();

CREATE OR REPLACE FUNCTION get_newsletter_recipients()
RETURNS TABLE(
  id UUID, 
  email TEXT, 
  display_name TEXT,
  source TEXT,
  account_type TEXT,
  newsletter_status TEXT
)
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_premium_included BOOLEAN := FALSE;
  v_basic_included BOOLEAN := FALSE;
BEGIN
  SELECT COALESCE((config_value->>'enabled')::boolean, FALSE) INTO v_premium_included
  FROM newsletter_config WHERE config_key = 'premium_included';
  
  SELECT COALESCE((config_value->>'enabled')::boolean, FALSE) INTO v_basic_included
  FROM newsletter_config WHERE config_key = 'basic_included';

  RETURN QUERY
  SELECT 
    p.id, 
    p.email, 
    p.display_name,
    CASE 
      WHEN p.newsletter_status IN ('active', 'trial') THEN 'newsletter_subscription'
      WHEN p.account_type = 'premium' AND v_premium_included THEN 'premium_perk'
      WHEN p.account_type = 'basic' AND v_basic_included THEN 'basic_perk'
    END as source,
    p.account_type,
    COALESCE(p.newsletter_status, 'inactive') as newsletter_status
  FROM profiles p
  WHERE p.email IS NOT NULL
    AND p.deleted_at IS NULL
    AND (
      p.newsletter_status IN ('active', 'trial')
      OR (
        p.account_type = 'premium' 
        AND p.subscription_status = 'active' 
        AND v_premium_included
        AND COALESCE(p.newsletter_enabled, TRUE) = TRUE
      )
      OR (
        p.account_type = 'basic' 
        AND p.subscription_status = 'active' 
        AND v_basic_included
        AND COALESCE(p.newsletter_enabled, TRUE) = TRUE
      )
    )
  ORDER BY p.email;
END;
$$;


DROP FUNCTION IF EXISTS get_newsletter_recipients_breakdown();

CREATE OR REPLACE FUNCTION get_newsletter_recipients_breakdown()
RETURNS TABLE(
  source TEXT,
  count BIGINT
)
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  RETURN QUERY
  SELECT 
    r.source,
    COUNT(*)::BIGINT as count
  FROM get_newsletter_recipients() r
  GROUP BY r.source
  ORDER BY count DESC;
END;
$$;


DROP FUNCTION IF EXISTS get_newsletter_inclusion_status();

CREATE OR REPLACE FUNCTION get_newsletter_inclusion_status()
RETURNS TABLE(
  premium_included BOOLEAN,
  basic_included BOOLEAN,
  total_recipients BIGINT,
  newsletter_subscribers BIGINT,
  premium_recipients BIGINT,
  basic_recipients BIGINT
)
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_premium BOOLEAN;
  v_basic BOOLEAN;
BEGIN
  SELECT COALESCE((config_value->>'enabled')::boolean, FALSE) INTO v_premium
  FROM newsletter_config WHERE config_key = 'premium_included';
  
  SELECT COALESCE((config_value->>'enabled')::boolean, FALSE) INTO v_basic
  FROM newsletter_config WHERE config_key = 'basic_included';

  RETURN QUERY
  SELECT 
    v_premium as premium_included,
    v_basic as basic_included,
    (SELECT COUNT(*) FROM get_newsletter_recipients())::BIGINT as total_recipients,
    (SELECT COUNT(*) FROM get_newsletter_recipients() WHERE source = 'newsletter_subscription')::BIGINT,
    (SELECT COUNT(*) FROM get_newsletter_recipients() WHERE source = 'premium_perk')::BIGINT,
    (SELECT COUNT(*) FROM get_newsletter_recipients() WHERE source = 'basic_perk')::BIGINT;
END;
$$;


-- ============================================
-- INDEXES
-- ============================================

CREATE INDEX IF NOT EXISTS idx_newsletter_config_key 
ON newsletter_config(config_key);


-- ============================================
-- RLS POLICIES
-- ============================================

ALTER TABLE newsletter_config ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Admins can read newsletter config" ON newsletter_config;
CREATE POLICY "Admins can read newsletter config" ON newsletter_config
  FOR SELECT USING (
    EXISTS (
      SELECT 1 FROM profiles 
      WHERE profiles.id = auth.uid() 
      AND profiles.role IN ('admin', 'super_admin')
    )
  );

DROP POLICY IF EXISTS "Admins can update newsletter config" ON newsletter_config;
CREATE POLICY "Admins can update newsletter config" ON newsletter_config
  FOR UPDATE USING (
    EXISTS (
      SELECT 1 FROM profiles 
      WHERE profiles.id = auth.uid() 
      AND profiles.role IN ('admin', 'super_admin')
    )
  );

DROP POLICY IF EXISTS "Service role full access to newsletter config" ON newsletter_config;
CREATE POLICY "Service role full access to newsletter config" ON newsletter_config
  FOR ALL USING (auth.role() = 'service_role');


-- ============================================
-- GRANTS
-- ============================================

GRANT SELECT ON newsletter_config TO authenticated;
GRANT ALL ON newsletter_config TO service_role;

GRANT EXECUTE ON FUNCTION get_newsletter_config() TO authenticated;
GRANT EXECUTE ON FUNCTION update_newsletter_config(TEXT, JSONB) TO authenticated;
GRANT EXECUTE ON FUNCTION toggle_newsletter_config(TEXT, BOOLEAN) TO authenticated;
GRANT EXECUTE ON FUNCTION get_newsletter_recipients() TO authenticated, service_role;
GRANT EXECUTE ON FUNCTION get_newsletter_recipients_breakdown() TO authenticated;
GRANT EXECUTE ON FUNCTION get_newsletter_inclusion_status() TO authenticated;


-- ============================================
-- VERIFICATION
-- ============================================

SELECT '========== NEWSLETTER CONFIG v1.2.0 ==========' as section;

SELECT 
  'TABLE' as check_type,
  CASE WHEN EXISTS (SELECT 1 FROM pg_tables WHERE tablename = 'newsletter_config') 
    THEN '‚úÖ' ELSE '‚ùå' END as status;

SELECT config_key, config_value FROM newsletter_config ORDER BY config_key;

SELECT 
  'FUNCTIONS' as check_type,
  CASE WHEN EXISTS (SELECT 1 FROM pg_proc WHERE proname = 'get_newsletter_config') THEN '‚úÖ' ELSE '‚ùå' END as get_config,
  CASE WHEN EXISTS (SELECT 1 FROM pg_proc WHERE proname = 'toggle_newsletter_config') THEN '‚úÖ' ELSE '‚ùå' END as toggle_config,
  CASE WHEN EXISTS (SELECT 1 FROM pg_proc WHERE proname = 'get_newsletter_recipients') THEN '‚úÖ' ELSE '‚ùå' END as get_recipients,
  CASE WHEN EXISTS (SELECT 1 FROM pg_proc WHERE proname = 'get_newsletter_inclusion_status') THEN '‚úÖ' ELSE '‚ùå' END as inclusion_status;

SELECT 'RECIPIENTS BY SOURCE' as info, source, COUNT(*) as count
FROM get_newsletter_recipients()
GROUP BY source;

SELECT 'INCLUSION STATUS' as info, * FROM get_newsletter_inclusion_status();

SELECT 'üéâ DONE!' as status;


-- ============================================
-- üéâ FINOTAUR COMPLETE SUBSCRIPTION SYSTEM v5.0.0
-- ============================================
-- 
-- ‚úÖ Whop Integration (v4.1.0)
-- ‚úÖ Subscription Management (v1.0.0)
-- ‚úÖ Affiliate System Complete
-- ‚úÖ Commission & Qualification
-- ‚úÖ Newsletter System Complete
-- 
-- üìã Commission Rates:
--    tier_1: 10%, tier_2: 15%, tier_3: 20%, yearly: 15%
-- 
-- üîÑ Subscription Cancel/Downgrade Flow:
--    1. User clicks Cancel/Downgrade
--    2. Edge Function calls Whop API (cancel at_period_end)
--    3. profiles: cancel_at_period_end=TRUE, pending_downgrade_plan='free'/'basic'
--    4. User keeps current plan until period end
--    5. Whop webhook: membership.went_invalid
--    6. deactivate_whop_subscription checks pending_downgrade_plan
--    7. User moved to target plan
-- 
-- üîÑ Affiliate Qualification Flow:
--    1. Affiliate link click ‚Üí record_affiliate_click
--    2. Promo code validation ‚Üí validate_affiliate_code
--    3. Payment via Whop ‚Üí handle_whop_payment
--    4. Referral created (verification_pending)
--    5. After 7 days: qualify_verified_referrals (Cron)
--    6. Referral ‚Üí qualified, Commission ‚Üí confirmed
-- 
-- ‚ö†Ô∏è Cron Setup (if pg_cron available):
--    SELECT cron.schedule('qualify-referrals', '0 2 * * *', 'SELECT qualify_verified_referrals()');
-- 
-- Manual run: SELECT run_daily_affiliate_tasks();
-- ============================================
