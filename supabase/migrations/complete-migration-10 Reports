-- =====================================================
-- FINOTAUR COMPLETE DATABASE SCHEMA (FIXED)
-- =====================================================
-- Includes: ISM Reports, Company Analysis, Crypto Analysis
-- Fixed: All RLS policies properly configured
-- Run this ENTIRE file in Supabase SQL Editor
-- =====================================================

-- ============================================
-- UTILITY FUNCTION: update_updated_at_column
-- ============================================
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- =====================================================
-- PART 1: ISM REPORTS TABLES
-- =====================================================

-- ============================================
-- TABLE: ism_reports
-- Main table for generated ISM reports
-- ============================================
CREATE TABLE IF NOT EXISTS ism_reports (
  id TEXT PRIMARY KEY,
  report_month TEXT NOT NULL,
  report_title TEXT,
  
  -- Raw ISM Data
  ism_data JSONB,
  ism_release_date TIMESTAMPTZ,
  
  -- 5 Report Sections
  macro_snapshot JSONB,
  trend_analysis JSONB,
  sector_impacts JSONB,
  equity_logic JSONB,
  trade_ideas JSONB,
  
  -- Executive Summary
  executive_summary JSONB,
  five_line_summary JSONB,
  
  -- Additional Sections
  invalidation_scenarios TEXT[],
  next_month_indicators TEXT[],
  
  -- Output Content
  markdown_content TEXT,
  html_content TEXT,
  
  -- Processing Info
  processing_info JSONB,
  
  -- Quality Assurance
  qa_score INTEGER DEFAULT 0,
  qa_passed BOOLEAN DEFAULT false,
  
  -- Admin Override
  is_admin_override BOOLEAN DEFAULT false,
  override_reason TEXT,
  created_by TEXT,
  
  -- â˜…â˜…â˜… NEW: Orchestrator v3.2 required columns â˜…â˜…â˜…
  status TEXT DEFAULT 'pending',
  structured_report JSONB,
  admin_id TEXT,
  agents_completed INTEGER DEFAULT 0,
  errors JSONB DEFAULT '[]'::jsonb,
  
  -- Timestamps
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- â˜…â˜…â˜… ADD COLUMNS IF TABLE ALREADY EXISTS â˜…â˜…â˜…
ALTER TABLE ism_reports 
ADD COLUMN IF NOT EXISTS status TEXT DEFAULT 'pending',
ADD COLUMN IF NOT EXISTS structured_report JSONB,
ADD COLUMN IF NOT EXISTS admin_id TEXT,
ADD COLUMN IF NOT EXISTS agents_completed INTEGER DEFAULT 0,
ADD COLUMN IF NOT EXISTS errors JSONB DEFAULT '[]'::jsonb;

-- Indexes
CREATE INDEX IF NOT EXISTS idx_ism_reports_month ON ism_reports(report_month);
CREATE INDEX IF NOT EXISTS idx_ism_reports_created ON ism_reports(created_at DESC);

-- Trigger
DROP TRIGGER IF EXISTS update_ism_reports_updated_at ON ism_reports;
CREATE TRIGGER update_ism_reports_updated_at
  BEFORE UPDATE ON ism_reports
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- ============================================
-- TABLE: ism_report_tracking
-- Track monthly report status (one row per month)
-- ============================================
CREATE TABLE IF NOT EXISTS ism_report_tracking (
  report_month TEXT PRIMARY KEY,
  
  -- Status
  status TEXT NOT NULL DEFAULT 'pending_ism',
  
  -- ISM Data Status
  ism_data_available BOOLEAN DEFAULT false,
  ism_release_date TIMESTAMPTZ,
  last_ism_check TIMESTAMPTZ,
  
  -- Generation Status
  generation_started_at TIMESTAMPTZ,
  generation_completed_at TIMESTAMPTZ,
  report_generated_at TIMESTAMPTZ,
  
  -- Report Reference
  report_id TEXT,
  latest_report_id TEXT,
  
  -- Quick Reference
  pmi_value NUMERIC(4,1),
  
  -- Admin Override
  is_admin_override BOOLEAN DEFAULT false,
  admin_id TEXT,
  override_reason TEXT,
  
  -- Error Tracking
  error_message TEXT,
  error_count INTEGER DEFAULT 0,
  
  -- Timestamps
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Trigger
DROP TRIGGER IF EXISTS update_ism_report_tracking_updated_at ON ism_report_tracking;
CREATE TRIGGER update_ism_report_tracking_updated_at
  BEFORE UPDATE ON ism_report_tracking
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- ============================================
-- TABLE: ism_agent_logs
-- Log each agent execution
-- ============================================
CREATE TABLE IF NOT EXISTS ism_agent_logs (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  report_id TEXT NOT NULL,
  report_month TEXT NOT NULL,
  
  -- Agent Info
  agent_id TEXT NOT NULL,
  agent_name TEXT NOT NULL,
  phase TEXT NOT NULL,
  
  -- Execution Details
  started_at TIMESTAMPTZ NOT NULL,
  completed_at TIMESTAMPTZ,
  duration_ms INTEGER,
  
  -- Status
  status TEXT NOT NULL DEFAULT 'running',
  
  -- Output
  output_summary TEXT,
  error_message TEXT,
  
  -- Timestamps
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Indexes
CREATE INDEX IF NOT EXISTS idx_ism_agent_logs_report ON ism_agent_logs(report_id);
CREATE INDEX IF NOT EXISTS idx_ism_agent_logs_month ON ism_agent_logs(report_month);
CREATE INDEX IF NOT EXISTS idx_ism_agent_logs_agent ON ism_agent_logs(agent_id);

-- ============================================
-- TABLE: ism_source_cache
-- Cache ISM data from external sources
-- ============================================
CREATE TABLE IF NOT EXISTS ism_source_cache (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  data_month TEXT NOT NULL UNIQUE,
  source_url TEXT,
  
  -- Data
  raw_data JSONB,
  parsed_data JSONB,
  
  -- Cache Management
  fetched_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  expires_at TIMESTAMPTZ,
  is_valid BOOLEAN DEFAULT true,
  
  -- Timestamps
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Index
CREATE INDEX IF NOT EXISTS idx_ism_source_cache_month ON ism_source_cache(data_month);

-- ============================================
-- TABLE: ism_report_progress
-- Real-time progress tracking
-- ============================================
CREATE TABLE IF NOT EXISTS ism_report_progress (
  report_id TEXT PRIMARY KEY,
  status TEXT NOT NULL DEFAULT 'running',
  progress INTEGER DEFAULT 0,
  current_phase TEXT,
  current_agent_id TEXT,
  current_agent_name TEXT,
  completed_agents TEXT[],
  total_agents INTEGER,
  elapsed_seconds INTEGER,
  error TEXT,
  updated_at TIMESTAMPTZ DEFAULT NOW()
);
-- =====================================================
-- PART 1.5: DELETED REPORTS TRACKING (FIXED v2.0)
-- =====================================================
-- Tracks deleted published reports to prevent re-sync
-- When admin deletes a report, it will NOT come back
-- =====================================================

CREATE TABLE IF NOT EXISTS deleted_published_reports (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    report_type TEXT NOT NULL,
    original_report_id TEXT NOT NULL,
    deleted_at TIMESTAMPTZ DEFAULT NOW(),
    deleted_by UUID,
    reason TEXT,
    UNIQUE(report_type, original_report_id)
);

CREATE INDEX IF NOT EXISTS idx_deleted_reports_lookup 
ON deleted_published_reports(report_type, original_report_id);

ALTER TABLE deleted_published_reports ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "service_deleted_reports_all" ON deleted_published_reports;
CREATE POLICY "service_deleted_reports_all" ON deleted_published_reports
    FOR ALL TO service_role USING (true) WITH CHECK (true);

DROP POLICY IF EXISTS "admin_deleted_reports_all" ON deleted_published_reports;
CREATE POLICY "admin_deleted_reports_all" ON deleted_published_reports
    FOR ALL TO authenticated
    USING (
        EXISTS (
            SELECT 1 FROM profiles
            WHERE id = auth.uid() AND role IN ('admin', 'super_admin')
        )
    )
    WITH CHECK (
        EXISTS (
            SELECT 1 FROM profiles
            WHERE id = auth.uid() AND role IN ('admin', 'super_admin')
        )
    );

GRANT ALL ON deleted_published_reports TO service_role;
GRANT SELECT, INSERT, DELETE ON deleted_published_reports TO authenticated;

-- â­ FIXED: Trigger to track deletions from published_reports
DROP TRIGGER IF EXISTS trigger_track_deleted_published_report ON published_reports;
DROP FUNCTION IF EXISTS track_deleted_published_report() CASCADE;

CREATE OR REPLACE FUNCTION track_deleted_published_report()
RETURNS TRIGGER AS $$
BEGIN
    -- Only track if original_report_id exists (synced reports)
    IF OLD.original_report_id IS NOT NULL THEN
        INSERT INTO deleted_published_reports (
            report_type, 
            original_report_id, 
            deleted_by,
            reason
        )
        VALUES (
            OLD.report_type, 
            OLD.original_report_id, 
            auth.uid(),
            'Manually deleted by admin'
        )
        ON CONFLICT (report_type, original_report_id) 
        DO UPDATE SET
            deleted_at = NOW(),
            deleted_by = auth.uid();
            
        RAISE NOTICE '[DeleteTracker] Tracked deletion: % - %', OLD.report_type, OLD.original_report_id;
    END IF;
    
    RETURN OLD;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE TRIGGER trigger_track_deleted_published_report
    BEFORE DELETE ON published_reports
    FOR EACH ROW
    EXECUTE FUNCTION track_deleted_published_report();

-- â­ NEW: Function to restore a deleted report
CREATE OR REPLACE FUNCTION restore_deleted_report(
    p_report_type TEXT,
    p_original_report_id TEXT
)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    v_deleted BOOLEAN;
BEGIN
    -- Check if user is admin
    IF NOT is_admin_user(auth.uid()) THEN
        RETURN jsonb_build_object('success', false, 'error', 'Admin access required');
    END IF;

    -- Check if it was deleted
    SELECT EXISTS (
        SELECT 1 FROM deleted_published_reports
        WHERE report_type = p_report_type AND original_report_id = p_original_report_id
    ) INTO v_deleted;
    
    IF NOT v_deleted THEN
        RETURN jsonb_build_object('success', false, 'error', 'Report was not deleted');
    END IF;
    
    -- Remove from deleted list
    DELETE FROM deleted_published_reports
    WHERE report_type = p_report_type AND original_report_id = p_original_report_id;
    
    RETURN jsonb_build_object(
        'success', true, 
        'message', 'Report removed from deleted list - run sync to restore',
        'report_type', p_report_type,
        'original_report_id', p_original_report_id
    );
END;
$$;

GRANT EXECUTE ON FUNCTION restore_deleted_report(TEXT, TEXT) TO authenticated;

-- â­ NEW: Function to view all deleted reports
CREATE OR REPLACE FUNCTION get_deleted_reports()
RETURNS TABLE (
    id UUID,
    report_type TEXT,
    original_report_id TEXT,
    deleted_at TIMESTAMPTZ,
    deleted_by UUID,
    reason TEXT
)
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
    IF NOT is_admin_user(auth.uid()) THEN
        RETURN;
    END IF;

    RETURN QUERY
    SELECT 
        d.id,
        d.report_type,
        d.original_report_id,
        d.deleted_at,
        d.deleted_by,
        d.reason
    FROM deleted_published_reports d
    ORDER BY d.deleted_at DESC;
END;
$$;

GRANT EXECUTE ON FUNCTION get_deleted_reports() TO authenticated;


-- =====================================================
-- PART 2: COMPANY ANALYSIS TABLES
-- =====================================================

-- ============================================
-- TABLE: company_reports
-- Main table for Company Analysis reports (23 AI Agents)
-- ============================================
CREATE TABLE IF NOT EXISTS company_reports (
  id TEXT PRIMARY KEY,
  ticker VARCHAR(10) NOT NULL,
  company_name VARCHAR(255),
  exchange VARCHAR(50),
  market_cap BIGINT,
  sector VARCHAR(100),
  industry VARCHAR(100),
  company_type VARCHAR(50),
  
  -- 6 Report Sections (JSONB)
  business_reality JSONB,
  sector_competition JSONB,
  financial_core JSONB,
  filings_analysis JSONB,
  forward_view JSONB,
  investment_decision JSONB,
  
  -- Executive Summary
  executive_summary JSONB,
  
  -- Generated Content
  markdown_content TEXT,
  html_content TEXT,
  
  -- Processing Info
  processing_info JSONB,
  
  -- Quality Assurance
  qa_score INTEGER DEFAULT 85,
  qa_passed BOOLEAN DEFAULT true,
  confidence_level VARCHAR(20) DEFAULT 'medium',
  
  -- Admin Override
  is_admin_override BOOLEAN DEFAULT false,
  override_reason TEXT,
  created_by UUID,
  
  -- S&P 500 Flag
  is_sp500 BOOLEAN DEFAULT true,
  
  -- Timestamps
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- =====================================================
-- FIX: Add missing columns to company_reports
-- Required for orchestrator.js v8.3+ to save reports
-- =====================================================

ALTER TABLE company_reports 
ADD COLUMN IF NOT EXISTS admin_id TEXT,
ADD COLUMN IF NOT EXISTS include_ism BOOLEAN DEFAULT false,
ADD COLUMN IF NOT EXISTS report_type VARCHAR(50) DEFAULT 'auto',
ADD COLUMN IF NOT EXISTS report_data JSONB,
ADD COLUMN IF NOT EXISTS is_smart_fallback BOOLEAN DEFAULT false,
ADD COLUMN IF NOT EXISTS smart_fallback_context JSONB;

-- Optional: Add index for faster admin queries
CREATE INDEX IF NOT EXISTS idx_company_reports_admin_id 
ON company_reports(admin_id) WHERE admin_id IS NOT NULL;

CREATE INDEX IF NOT EXISTS idx_company_reports_report_type 
ON company_reports(report_type);

-- =====================================================
-- Verification - Run this to confirm columns exist
-- =====================================================
SELECT column_name, data_type, column_default
FROM information_schema.columns 
WHERE table_name = 'company_reports' 
AND column_name IN ('admin_id', 'include_ism', 'report_type', 'report_data', 'override_reason')
ORDER BY column_name;

-- Add columns if table already exists
ALTER TABLE company_reports 
ADD COLUMN IF NOT EXISTS company_type VARCHAR(50),
ADD COLUMN IF NOT EXISTS exchange VARCHAR(50),
ADD COLUMN IF NOT EXISTS market_cap BIGINT,
ADD COLUMN IF NOT EXISTS industry VARCHAR(100),
ADD COLUMN IF NOT EXISTS business_reality JSONB,
ADD COLUMN IF NOT EXISTS sector_competition JSONB,
ADD COLUMN IF NOT EXISTS financial_core JSONB,
ADD COLUMN IF NOT EXISTS filings_analysis JSONB,
ADD COLUMN IF NOT EXISTS forward_view JSONB,
ADD COLUMN IF NOT EXISTS investment_decision JSONB,
ADD COLUMN IF NOT EXISTS processing_info JSONB,
ADD COLUMN IF NOT EXISTS qa_passed BOOLEAN DEFAULT true,
ADD COLUMN IF NOT EXISTS confidence_level VARCHAR(20) DEFAULT 'medium',
ADD COLUMN IF NOT EXISTS is_sp500 BOOLEAN DEFAULT true,
ADD COLUMN IF NOT EXISTS markdown_content TEXT,
ADD COLUMN IF NOT EXISTS version VARCHAR(20) DEFAULT '6.0.0',
ADD COLUMN IF NOT EXISTS html_content TEXT;


-- Indexes
CREATE INDEX IF NOT EXISTS idx_company_reports_ticker ON company_reports(ticker);
CREATE INDEX IF NOT EXISTS idx_company_reports_created ON company_reports(created_at DESC);
CREATE INDEX IF NOT EXISTS idx_company_reports_sector ON company_reports(sector);

-- Trigger
DROP TRIGGER IF EXISTS update_company_reports_updated_at ON company_reports;
CREATE TRIGGER update_company_reports_updated_at
  BEFORE UPDATE ON company_reports
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- ============================================
-- TABLE: company_agent_logs
-- Log each agent execution for Company Analysis
-- ============================================
CREATE TABLE IF NOT EXISTS company_agent_logs (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  report_id TEXT NOT NULL,
  ticker VARCHAR(10) NOT NULL,
  
  -- Agent Info
  agent_id TEXT NOT NULL,
  agent_name TEXT NOT NULL,
  phase TEXT NOT NULL,
  
  -- Execution Details
  started_at TIMESTAMPTZ NOT NULL,
  completed_at TIMESTAMPTZ,
  duration_ms INTEGER,
  
  -- Status
  status TEXT NOT NULL DEFAULT 'running',
  
  -- Output
  output_summary TEXT,
  error_message TEXT,
  
  -- Timestamps
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Indexes
CREATE INDEX IF NOT EXISTS idx_company_agent_logs_report ON company_agent_logs(report_id);
CREATE INDEX IF NOT EXISTS idx_company_agent_logs_ticker ON company_agent_logs(ticker);

-- =====================================================
-- PART 3: CRYPTO ANALYSIS TABLES
-- =====================================================

-- ============================================
-- TABLE: crypto_reports
-- Main table for Crypto Analysis reports (18 AI Agents)
-- ============================================
CREATE TABLE IF NOT EXISTS crypto_reports (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  report_date DATE NOT NULL,
  
  -- Time window for data collection
  window_start TIMESTAMPTZ,
  window_end TIMESTAMPTZ,
  
  -- Market Analysis
  market_regime VARCHAR(50),
  regime_score INTEGER,
  regime_confidence INTEGER,
  market_regime_confidence INTEGER,
  
  -- Executive Summary (JSON)
  executive_summary JSONB,
  
  -- Report Sections (JSON)
  sections JSONB,
  
  -- Raw data storage
  raw_data JSONB,
  
  -- Charts storage
  charts JSONB,
  
  -- Individual Section Data (for quick access)
  btc_analysis JSONB,
  eth_analysis JSONB,
  altcoin_verdicts JSONB,
  trade_ideas JSONB,
  risk_assessment JSONB,
  
  -- Quality Metrics
  qa_score INTEGER,
  qa_grade VARCHAR(2),
  qa_passed BOOLEAN DEFAULT false,
  quality_score INTEGER DEFAULT 0,
  quality_metrics JSONB,
  
  -- Generated Content
  markdown_content TEXT,
  html_content TEXT,
  pdf_path VARCHAR(255),
  
  -- Agent Results (for debugging/auditing)
  agent_results JSONB,
  
  -- Metadata
  generation_duration_seconds INTEGER,
  openai_tokens_used INTEGER,
  openai_cost_usd DECIMAL(10, 4),
  
  -- Timestamps
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- =====================================================
-- FIX: Add missing columns to crypto_reports
-- Run this to ensure all columns exist
-- =====================================================
ALTER TABLE crypto_reports 
ADD COLUMN IF NOT EXISTS window_start TIMESTAMPTZ,
ADD COLUMN IF NOT EXISTS window_end TIMESTAMPTZ,
ADD COLUMN IF NOT EXISTS regime_score INTEGER,
ADD COLUMN IF NOT EXISTS regime_confidence INTEGER,
ADD COLUMN IF NOT EXISTS raw_data JSONB,
ADD COLUMN IF NOT EXISTS charts JSONB,
ADD COLUMN IF NOT EXISTS quality_score INTEGER DEFAULT 0,
ADD COLUMN IF NOT EXISTS quality_metrics JSONB,
ADD COLUMN IF NOT EXISTS status TEXT DEFAULT 'completed';

-- Refresh schema cache by recreating index
DROP INDEX IF EXISTS idx_crypto_reports_quality;
CREATE INDEX idx_crypto_reports_quality ON crypto_reports(quality_score);

-- Indexes
CREATE INDEX IF NOT EXISTS idx_crypto_reports_date ON crypto_reports(report_date DESC);
CREATE INDEX IF NOT EXISTS idx_crypto_reports_regime ON crypto_reports(market_regime);
CREATE INDEX IF NOT EXISTS idx_crypto_reports_created ON crypto_reports(created_at DESC);

-- Trigger function for crypto
CREATE OR REPLACE FUNCTION update_crypto_reports_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger
DROP TRIGGER IF EXISTS trigger_crypto_reports_updated_at ON crypto_reports;
CREATE TRIGGER trigger_crypto_reports_updated_at
  BEFORE UPDATE ON crypto_reports
  FOR EACH ROW
  EXECUTE FUNCTION update_crypto_reports_updated_at();

-- ============================================
-- TABLE: crypto_report_progress
-- Real-time progress tracking for crypto reports
-- ============================================
CREATE TABLE IF NOT EXISTS crypto_report_progress (
  report_id UUID PRIMARY KEY,
  status TEXT NOT NULL DEFAULT 'running',
  progress INTEGER DEFAULT 0,
  current_phase TEXT,
  current_agent TEXT,
  completed_agents TEXT[],
  elapsed_seconds INTEGER DEFAULT 0,
  error TEXT,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Index
CREATE INDEX IF NOT EXISTS idx_crypto_progress_status ON crypto_report_progress(status);

-- ============================================
-- TABLE: crypto_agent_logs
-- Log each agent execution for Crypto Analysis
-- ============================================
CREATE TABLE IF NOT EXISTS crypto_agent_logs (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  report_id UUID NOT NULL,
  
  -- Agent Info
  agent_id TEXT NOT NULL,
  agent_name TEXT NOT NULL,
  phase TEXT NOT NULL,
  
  -- Execution Details
  started_at TIMESTAMPTZ NOT NULL,
  completed_at TIMESTAMPTZ,
  duration_ms INTEGER,
  
  -- Status
  status TEXT NOT NULL DEFAULT 'running',
  
  -- Output
  output_summary TEXT,
  error_message TEXT,
  
  -- Timestamps
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Indexes
CREATE INDEX IF NOT EXISTS idx_crypto_agent_logs_report ON crypto_agent_logs(report_id);
CREATE INDEX IF NOT EXISTS idx_crypto_agent_logs_agent ON crypto_agent_logs(agent_id);

-- =====================================================
-- PART 3.5: PUBLISHED REPORTS TABLE - Manual Report Publishing
-- =====================================================

-- Create the published_reports table
CREATE TABLE IF NOT EXISTS public.published_reports (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    
    -- Report identification
    report_type TEXT NOT NULL CHECK (report_type IN ('ism', 'company', 'crypto', 'weekly')),
    original_report_id TEXT,
    
    -- Report content metadata
    title TEXT NOT NULL,
    subtitle TEXT,
    highlights TEXT[],
    key_metric_label TEXT,
    key_metric_value TEXT,
    key_insights_count INTEGER,
    pdf_url TEXT,
    markdown_preview TEXT,
    qa_score INTEGER,
    
    -- Report-specific fields
    ticker TEXT,
    company_name TEXT,
    sector TEXT,
    report_month TEXT,
    pmi_value NUMERIC,
    market_regime TEXT,
    
    -- â­ NEW: Full content storage
    markdown_content TEXT,
    html_content TEXT,
    pdf_storage_path TEXT,
    
    -- Publishing settings
    is_featured BOOLEAN DEFAULT false,
    is_pinned BOOLEAN DEFAULT false,
    target_group TEXT NOT NULL DEFAULT 'all' CHECK (target_group IN ('all', 'top_secret', 'newsletter', 'trading_journal')),
    
    -- Email tracking
    email_sent BOOLEAN DEFAULT false,
    email_sent_at TIMESTAMPTZ,
    email_recipient_count INTEGER DEFAULT 0,
    
    -- Admin tracking
    published_by UUID REFERENCES auth.users(id),
    admin_note TEXT,
    
    -- Timestamps
    published_at TIMESTAMPTZ DEFAULT NOW(),
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- â­ ADD COLUMNS IF TABLE ALREADY EXISTS
ALTER TABLE public.published_reports 
ADD COLUMN IF NOT EXISTS markdown_content TEXT;

ALTER TABLE public.published_reports 
ADD COLUMN IF NOT EXISTS html_content TEXT;

ALTER TABLE public.published_reports 
ADD COLUMN IF NOT EXISTS pdf_storage_path TEXT;

ALTER TABLE public.published_reports 
ADD COLUMN IF NOT EXISTS category TEXT;


-- Create indexes
CREATE INDEX IF NOT EXISTS idx_published_reports_type ON public.published_reports(report_type);
CREATE INDEX IF NOT EXISTS idx_published_reports_target ON public.published_reports(target_group);
CREATE INDEX IF NOT EXISTS idx_published_reports_published_at ON public.published_reports(published_at DESC);
CREATE INDEX IF NOT EXISTS idx_published_reports_featured ON public.published_reports(is_featured) WHERE is_featured = true;
CREATE INDEX IF NOT EXISTS idx_published_reports_pinned ON public.published_reports(is_pinned) WHERE is_pinned = true;

-- ============================================
-- RLS for published_reports
-- ============================================
ALTER TABLE public.published_reports ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "published_reports_service_all" ON public.published_reports;
DROP POLICY IF EXISTS "published_reports_admin_manage" ON public.published_reports;
DROP POLICY IF EXISTS "published_reports_user_read" ON public.published_reports;

CREATE POLICY "published_reports_service_all" ON public.published_reports
    FOR ALL TO service_role
    USING (true) WITH CHECK (true);

CREATE POLICY "published_reports_admin_manage" ON public.published_reports
    FOR ALL TO authenticated
    USING (
        EXISTS (
            SELECT 1 FROM public.profiles
            WHERE id = auth.uid() AND role IN ('admin', 'super_admin')
        )
    )
    WITH CHECK (
        EXISTS (
            SELECT 1 FROM public.profiles
            WHERE id = auth.uid() AND role IN ('admin', 'super_admin')
        )
    );

CREATE POLICY "published_reports_user_read" ON public.published_reports
    FOR SELECT TO authenticated
    USING (
        EXISTS (
            SELECT 1 FROM public.profiles
            WHERE id = auth.uid() AND role IN ('admin', 'super_admin')
        )
        OR target_group = 'all'
        OR (target_group = 'top_secret' AND EXISTS (
            SELECT 1 FROM public.profiles
            WHERE id = auth.uid() AND top_secret_enabled = true
        ))
        OR (target_group = 'newsletter' AND EXISTS (
            SELECT 1 FROM public.profiles
            WHERE id = auth.uid() AND (newsletter_enabled = true OR newsletter_paid = true)
        ))
        OR (target_group = 'trading_journal' AND EXISTS (
            SELECT 1 FROM public.profiles
            WHERE id = auth.uid() AND account_type IN ('basic', 'premium', 'pro')
        ))
    );

-- ============================================
-- PUBLISHED REPORTS FUNCTIONS
-- ============================================

-- Function to publish a report

DROP FUNCTION IF EXISTS publish_report_to_dashboard;

CREATE OR REPLACE FUNCTION publish_report_to_dashboard(
    p_report_type TEXT,
    p_original_report_id TEXT,
    p_title TEXT,
    p_subtitle TEXT DEFAULT NULL,
    p_highlights TEXT[] DEFAULT NULL,
    p_key_metric_label TEXT DEFAULT NULL,
    p_key_metric_value TEXT DEFAULT NULL,
    p_key_insights_count INTEGER DEFAULT NULL,
    p_pdf_url TEXT DEFAULT NULL,
    p_markdown_preview TEXT DEFAULT NULL,
    p_qa_score INTEGER DEFAULT NULL,
    p_ticker TEXT DEFAULT NULL,
    p_company_name TEXT DEFAULT NULL,
    p_sector TEXT DEFAULT NULL,
    p_report_month TEXT DEFAULT NULL,
    p_pmi_value NUMERIC DEFAULT NULL,
    p_market_regime TEXT DEFAULT NULL,
    p_is_featured BOOLEAN DEFAULT false,
    p_is_pinned BOOLEAN DEFAULT false,
    p_target_group TEXT DEFAULT 'all',
    p_admin_note TEXT DEFAULT NULL,
    p_admin_id UUID DEFAULT NULL,
    -- NEW PARAMETERS for full content
    p_markdown_content TEXT DEFAULT NULL,
    p_html_content TEXT DEFAULT NULL,
    p_pdf_storage_path TEXT DEFAULT NULL
)
RETURNS UUID
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    v_report_id UUID;
    v_markdown TEXT;
    v_html TEXT;
BEGIN
    -- If no content provided, try to fetch from original report
    v_markdown := p_markdown_content;
    v_html := p_html_content;
    
    IF v_markdown IS NULL THEN
        IF p_report_type = 'ism' THEN
            SELECT markdown_content, html_content 
            INTO v_markdown, v_html
            FROM ism_reports WHERE id = p_original_report_id;
        ELSIF p_report_type = 'company' THEN
            SELECT markdown_content, html_content 
            INTO v_markdown, v_html
            FROM company_reports WHERE id = p_original_report_id;
        ELSIF p_report_type = 'crypto' THEN
            SELECT markdown_content, html_content 
            INTO v_markdown, v_html
            FROM crypto_reports WHERE id::TEXT = p_original_report_id;
        END IF;
    END IF;

    INSERT INTO public.published_reports (
        report_type, original_report_id, title, subtitle, highlights,
        key_metric_label, key_metric_value, key_insights_count, pdf_url,
        markdown_preview, qa_score, ticker, company_name, sector,
        report_month, pmi_value, market_regime, is_featured, is_pinned,
        target_group, admin_note, published_by,
        markdown_content, html_content, pdf_storage_path
    ) VALUES (
        p_report_type, p_original_report_id, p_title, p_subtitle, p_highlights,
        p_key_metric_label, p_key_metric_value, p_key_insights_count, p_pdf_url,
        COALESCE(p_markdown_preview, LEFT(v_markdown, 500)), p_qa_score, 
        p_ticker, p_company_name, p_sector,
        p_report_month, p_pmi_value, p_market_regime, p_is_featured, p_is_pinned,
        p_target_group, p_admin_note, COALESCE(p_admin_id, auth.uid()),
        v_markdown, v_html, p_pdf_storage_path
    )
    ON CONFLICT (report_type, original_report_id) 
    WHERE original_report_id IS NOT NULL
    DO UPDATE SET
        title = EXCLUDED.title,
        subtitle = EXCLUDED.subtitle,
        highlights = EXCLUDED.highlights,
        markdown_preview = EXCLUDED.markdown_preview,
        qa_score = EXCLUDED.qa_score,
        is_featured = EXCLUDED.is_featured,
        markdown_content = EXCLUDED.markdown_content,
        html_content = EXCLUDED.html_content,
        pdf_storage_path = EXCLUDED.pdf_storage_path,
        updated_at = NOW()
    RETURNING id INTO v_report_id;
    
    RETURN v_report_id;
END;
$$;

GRANT EXECUTE ON FUNCTION publish_report_to_dashboard TO authenticated;
GRANT EXECUTE ON FUNCTION publish_report_to_dashboard TO service_role;

-- Function to get published reports for a user
DROP FUNCTION IF EXISTS get_published_reports_for_user(UUID, TEXT, INTEGER);

CREATE OR REPLACE FUNCTION get_published_reports_for_user(
    p_user_id UUID,
    p_report_type TEXT DEFAULT NULL,
    p_limit INTEGER DEFAULT 20
)
RETURNS TABLE (
    id UUID,
    report_type TEXT,
    original_report_id TEXT,
    title TEXT,
    subtitle TEXT,
    highlights TEXT[],
    key_metric_label TEXT,
    key_metric_value TEXT,
    key_insights_count INTEGER,
    pdf_url TEXT,
    markdown_preview TEXT,
    qa_score INTEGER,
    ticker TEXT,
    company_name TEXT,
    sector TEXT,
    report_month TEXT,
    pmi_value NUMERIC,
    market_regime TEXT,
    is_featured BOOLEAN,
    is_pinned BOOLEAN,
    target_group TEXT,
    published_at TIMESTAMPTZ,
    -- NEW: Full content fields
    markdown_content TEXT,
    html_content TEXT,
    pdf_storage_path TEXT,
    -- Stats
    likes_count BIGINT,
    comments_count BIGINT
)
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    v_user_profile RECORD;
BEGIN
    SELECT 
        role, top_secret_enabled, newsletter_enabled, newsletter_paid, account_type
    INTO v_user_profile
    FROM public.profiles
    WHERE profiles.id = p_user_id;
    
    RETURN QUERY
    SELECT 
        pr.id, 
        pr.report_type, 
        pr.original_report_id, 
        pr.title, 
        pr.subtitle,
        pr.highlights, 
        pr.key_metric_label, 
        pr.key_metric_value, 
        pr.key_insights_count,
        pr.pdf_url, 
        pr.markdown_preview, 
        pr.qa_score, 
        pr.ticker, 
        pr.company_name,
        pr.sector, 
        pr.report_month, 
        pr.pmi_value, 
        pr.market_regime, 
        pr.is_featured,
        pr.is_pinned, 
        pr.target_group, 
        pr.published_at,
        -- Full content
        pr.markdown_content,
        pr.html_content,
        pr.pdf_storage_path,
        -- Stats
        COALESCE((SELECT COUNT(*) FROM report_likes rl WHERE rl.report_id = pr.id), 0)::BIGINT as likes_count,
        0::BIGINT as comments_count
    FROM public.published_reports pr
    WHERE 
        (p_report_type IS NULL OR pr.report_type = p_report_type)
        AND (
            v_user_profile.role IN ('admin', 'super_admin')
            OR pr.target_group = 'all'
            OR (pr.target_group = 'top_secret' AND v_user_profile.top_secret_enabled = true)
            OR (pr.target_group = 'newsletter' AND (v_user_profile.newsletter_enabled = true OR v_user_profile.newsletter_paid = true))
            OR (pr.target_group = 'trading_journal' AND v_user_profile.account_type IN ('basic', 'premium', 'pro'))
        )
    ORDER BY pr.is_pinned DESC, pr.is_featured DESC, pr.published_at DESC
    LIMIT p_limit;
END;
$$;

GRANT EXECUTE ON FUNCTION get_published_reports_for_user TO authenticated;
GRANT EXECUTE ON FUNCTION get_published_reports_for_user TO service_role;

-- Function to mark email as sent
CREATE OR REPLACE FUNCTION mark_published_report_email_sent(
    p_report_id UUID,
    p_recipient_count INTEGER
)
RETURNS BOOLEAN
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
    UPDATE public.published_reports
    SET 
        email_sent = true,
        email_sent_at = NOW(),
        email_recipient_count = p_recipient_count,
        updated_at = NOW()
    WHERE id = p_report_id;
    
    RETURN FOUND;
END;
$$;

-- Grants
GRANT SELECT, INSERT, UPDATE, DELETE ON public.published_reports TO authenticated;
GRANT ALL ON public.published_reports TO service_role;

GRANT EXECUTE ON FUNCTION publish_report_to_dashboard TO authenticated;
GRANT EXECUTE ON FUNCTION get_published_reports_for_user TO authenticated;
GRANT EXECUTE ON FUNCTION mark_published_report_email_sent TO authenticated;

GRANT EXECUTE ON FUNCTION publish_report_to_dashboard TO service_role;
GRANT EXECUTE ON FUNCTION get_published_reports_for_user TO service_role;
GRANT EXECUTE ON FUNCTION mark_published_report_email_sent TO service_role;

-- =====================================================
-- PART 3.6: PUBLISHED REPORTS MANAGEMENT FUNCTIONS
-- =====================================================
-- Additional functions for admin management of published reports
-- =====================================================

-- ============================================
-- 1. UPDATE PUBLISHED REPORT
-- ============================================
CREATE OR REPLACE FUNCTION update_published_report(
    p_id UUID,
    p_is_featured BOOLEAN DEFAULT NULL,
    p_is_pinned BOOLEAN DEFAULT NULL,
    p_target_group TEXT DEFAULT NULL,
    p_admin_note TEXT DEFAULT NULL,
    p_title TEXT DEFAULT NULL,
    p_subtitle TEXT DEFAULT NULL,
    p_highlights TEXT[] DEFAULT NULL
)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    v_user_id UUID;
    v_is_admin BOOLEAN;
    v_report RECORD;
BEGIN
    v_user_id := auth.uid();
    IF v_user_id IS NULL THEN
        RETURN jsonb_build_object('success', false, 'error', 'Not authenticated');
    END IF;

    SELECT is_admin_user(v_user_id) INTO v_is_admin;
    IF NOT COALESCE(v_is_admin, false) THEN
        RETURN jsonb_build_object('success', false, 'error', 'Admin access required');
    END IF;

    SELECT * INTO v_report FROM published_reports WHERE id = p_id;
    IF v_report IS NULL THEN
        RETURN jsonb_build_object('success', false, 'error', 'Report not found');
    END IF;

    UPDATE published_reports
    SET
        is_featured = COALESCE(p_is_featured, is_featured),
        is_pinned = COALESCE(p_is_pinned, is_pinned),
        target_group = COALESCE(p_target_group, target_group),
        admin_note = CASE 
            WHEN p_admin_note IS NOT NULL THEN p_admin_note 
            ELSE admin_note 
        END,
        title = COALESCE(p_title, title),
        subtitle = COALESCE(p_subtitle, subtitle),
        highlights = COALESCE(p_highlights, highlights),
        updated_at = NOW()
    WHERE id = p_id;

    RETURN jsonb_build_object(
        'success', true,
        'message', 'Report updated successfully',
        'report_id', p_id
    );
END;
$$;

GRANT EXECUTE ON FUNCTION update_published_report TO authenticated;
GRANT EXECUTE ON FUNCTION update_published_report TO service_role;

-- ============================================
-- 2. DELETE PUBLISHED REPORT
-- ============================================
CREATE OR REPLACE FUNCTION delete_published_report(p_id UUID)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    v_user_id UUID;
    v_is_admin BOOLEAN;
    v_report RECORD;
BEGIN
    v_user_id := auth.uid();
    IF v_user_id IS NULL THEN
        RETURN jsonb_build_object('success', false, 'error', 'Not authenticated');
    END IF;

    SELECT is_admin_user(v_user_id) INTO v_is_admin;
    IF NOT COALESCE(v_is_admin, false) THEN
        RETURN jsonb_build_object('success', false, 'error', 'Admin access required');
    END IF;

    SELECT * INTO v_report FROM published_reports WHERE id = p_id;
    IF v_report IS NULL THEN
        RETURN jsonb_build_object('success', false, 'error', 'Report not found');
    END IF;

    DELETE FROM published_reports WHERE id = p_id;

    RETURN jsonb_build_object(
        'success', true,
        'message', 'Report removed from publication',
        'report_id', p_id,
        'title', v_report.title
    );
END;
$$;

GRANT EXECUTE ON FUNCTION delete_published_report TO authenticated;
GRANT EXECUTE ON FUNCTION delete_published_report TO service_role;

-- ============================================
-- 3. GET PUBLISHED REPORTS STATS
-- ============================================
CREATE OR REPLACE FUNCTION get_published_reports_stats()
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    v_stats JSONB;
    v_this_month DATE;
    v_last_month DATE;
BEGIN
    v_this_month := DATE_TRUNC('month', NOW());
    v_last_month := DATE_TRUNC('month', NOW() - INTERVAL '1 month');

    SELECT jsonb_build_object(
        'total', COUNT(*),
        'this_month', COUNT(*) FILTER (WHERE published_at >= v_this_month),
        'last_month', COUNT(*) FILTER (WHERE published_at >= v_last_month AND published_at < v_this_month),
        'by_type', jsonb_build_object(
            'ism', COUNT(*) FILTER (WHERE report_type = 'ism'),
            'company', COUNT(*) FILTER (WHERE report_type = 'company'),
            'crypto', COUNT(*) FILTER (WHERE report_type = 'crypto'),
            'weekly', COUNT(*) FILTER (WHERE report_type = 'weekly')
        ),
        'by_target', jsonb_build_object(
            'all', COUNT(*) FILTER (WHERE target_group = 'all'),
            'top_secret', COUNT(*) FILTER (WHERE target_group = 'top_secret'),
            'newsletter', COUNT(*) FILTER (WHERE target_group = 'newsletter'),
            'trading_journal', COUNT(*) FILTER (WHERE target_group = 'trading_journal')
        ),
        'featured_count', COUNT(*) FILTER (WHERE is_featured = true),
        'pinned_count', COUNT(*) FILTER (WHERE is_pinned = true),
        'email_sent_count', COUNT(*) FILTER (WHERE email_sent = true),
        'total_emails_sent', COALESCE(SUM(email_recipient_count), 0),
        'avg_qa_score', ROUND(AVG(qa_score)::NUMERIC, 1)
    ) INTO v_stats
    FROM published_reports;

    RETURN v_stats;
END;
$$;

GRANT EXECUTE ON FUNCTION get_published_reports_stats TO authenticated;
GRANT EXECUTE ON FUNCTION get_published_reports_stats TO service_role;

-- ============================================
-- 4. TOGGLE FEATURED STATUS (Quick Action)
-- ============================================
CREATE OR REPLACE FUNCTION toggle_published_report_featured(p_id UUID)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    v_user_id UUID;
    v_is_admin BOOLEAN;
    v_new_status BOOLEAN;
BEGIN
    v_user_id := auth.uid();
    IF v_user_id IS NULL THEN
        RETURN jsonb_build_object('success', false, 'error', 'Not authenticated');
    END IF;

    SELECT is_admin_user(v_user_id) INTO v_is_admin;
    IF NOT COALESCE(v_is_admin, false) THEN
        RETURN jsonb_build_object('success', false, 'error', 'Admin access required');
    END IF;

    UPDATE published_reports
    SET 
        is_featured = NOT is_featured,
        updated_at = NOW()
    WHERE id = p_id
    RETURNING is_featured INTO v_new_status;

    IF v_new_status IS NULL THEN
        RETURN jsonb_build_object('success', false, 'error', 'Report not found');
    END IF;

    RETURN jsonb_build_object('success', true, 'is_featured', v_new_status);
END;
$$;

GRANT EXECUTE ON FUNCTION toggle_published_report_featured TO authenticated;
GRANT EXECUTE ON FUNCTION toggle_published_report_featured TO service_role;

-- ============================================
-- 5. TOGGLE PINNED STATUS (Quick Action)
-- ============================================
CREATE OR REPLACE FUNCTION toggle_published_report_pinned(p_id UUID)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    v_user_id UUID;
    v_is_admin BOOLEAN;
    v_new_status BOOLEAN;
BEGIN
    v_user_id := auth.uid();
    IF v_user_id IS NULL THEN
        RETURN jsonb_build_object('success', false, 'error', 'Not authenticated');
    END IF;

    SELECT is_admin_user(v_user_id) INTO v_is_admin;
    IF NOT COALESCE(v_is_admin, false) THEN
        RETURN jsonb_build_object('success', false, 'error', 'Admin access required');
    END IF;

    UPDATE published_reports
    SET 
        is_pinned = NOT is_pinned,
        updated_at = NOW()
    WHERE id = p_id
    RETURNING is_pinned INTO v_new_status;

    IF v_new_status IS NULL THEN
        RETURN jsonb_build_object('success', false, 'error', 'Report not found');
    END IF;

    RETURN jsonb_build_object('success', true, 'is_pinned', v_new_status);
END;
$$;

GRANT EXECUTE ON FUNCTION toggle_published_report_pinned TO authenticated;
GRANT EXECUTE ON FUNCTION toggle_published_report_pinned TO service_role;

-- ============================================
-- 6. BULK UPDATE TARGET GROUP
-- ============================================
CREATE OR REPLACE FUNCTION bulk_update_published_reports_target(
    p_ids UUID[],
    p_target_group TEXT
)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    v_user_id UUID;
    v_is_admin BOOLEAN;
    v_updated_count INTEGER;
BEGIN
    v_user_id := auth.uid();
    IF v_user_id IS NULL THEN
        RETURN jsonb_build_object('success', false, 'error', 'Not authenticated');
    END IF;

    SELECT is_admin_user(v_user_id) INTO v_is_admin;
    IF NOT COALESCE(v_is_admin, false) THEN
        RETURN jsonb_build_object('success', false, 'error', 'Admin access required');
    END IF;

    IF p_target_group NOT IN ('all', 'top_secret', 'newsletter', 'trading_journal') THEN
        RETURN jsonb_build_object('success', false, 'error', 'Invalid target group');
    END IF;

    UPDATE published_reports
    SET 
        target_group = p_target_group,
        updated_at = NOW()
    WHERE id = ANY(p_ids);

    GET DIAGNOSTICS v_updated_count = ROW_COUNT;

    RETURN jsonb_build_object(
        'success', true,
        'updated_count', v_updated_count,
        'target_group', p_target_group
    );
END;
$$;

GRANT EXECUTE ON FUNCTION bulk_update_published_reports_target TO authenticated;
GRANT EXECUTE ON FUNCTION bulk_update_published_reports_target TO service_role;

-- ============================================
-- VERIFICATION FOR PART 3.6
-- ============================================
DO $$
BEGIN
    IF EXISTS (SELECT 1 FROM pg_proc WHERE proname = 'update_published_report') THEN
        RAISE NOTICE 'YES: update_published_report function created';
    END IF;
    
    IF EXISTS (SELECT 1 FROM pg_proc WHERE proname = 'delete_published_report') THEN
        RAISE NOTICE 'YES: delete_published_report function created';
    END IF;
    
    IF EXISTS (SELECT 1 FROM pg_proc WHERE proname = 'get_published_reports_stats') THEN
        RAISE NOTICE 'YES: get_published_reports_stats function created';
    END IF;
    
    IF EXISTS (SELECT 1 FROM pg_proc WHERE proname = 'toggle_published_report_featured') THEN
        RAISE NOTICE 'YES: toggle_published_report_featured function created';
    END IF;
    
    IF EXISTS (SELECT 1 FROM pg_proc WHERE proname = 'toggle_published_report_pinned') THEN
        RAISE NOTICE 'YES: toggle_published_report_pinned function created';
    END IF;
    
    IF EXISTS (SELECT 1 FROM pg_proc WHERE proname = 'bulk_update_published_reports_target') THEN
        RAISE NOTICE 'YES: bulk_update_published_reports_target function created';
    END IF;
END $$;

-- =====================================================
-- END OF PART 3.6
-- =====================================================


-- =====================================================
-- FIX: Missing columns and table for Company Reports
-- =====================================================

-- 1. Fix published_reports - add missing columns
ALTER TABLE published_reports 
ADD COLUMN IF NOT EXISTS description TEXT,
ADD COLUMN IF NOT EXISTS report_id TEXT,
ADD COLUMN IF NOT EXISTS target_tier TEXT,
ADD COLUMN IF NOT EXISTS is_active BOOLEAN DEFAULT true,
ADD COLUMN IF NOT EXISTS category TEXT;

-- Index for report_id lookup
CREATE INDEX IF NOT EXISTS idx_published_reports_report_id 
ON published_reports(report_id) WHERE report_id IS NOT NULL;

-- 2. Create update_center_notifications table
CREATE TABLE IF NOT EXISTS update_center_notifications (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  
  -- Content
  title TEXT NOT NULL,
  message TEXT,
  type TEXT DEFAULT 'info' CHECK (type IN ('info', 'success', 'warning', 'report', 'announcement')),
  
  -- Report link (optional)
  report_type TEXT,
  report_id TEXT,
  ticker VARCHAR(10),
  
  -- Targeting
  target_group TEXT DEFAULT 'all' CHECK (target_group IN ('all', 'top_secret', 'newsletter', 'trading_journal')),
  
  -- Status
  is_read BOOLEAN DEFAULT false,
  is_dismissed BOOLEAN DEFAULT false,
  
  -- Metadata
  metadata JSONB DEFAULT '{}',
  
  -- Timestamps
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Indexes
CREATE INDEX IF NOT EXISTS idx_update_notifications_type ON update_center_notifications(type);
CREATE INDEX IF NOT EXISTS idx_update_notifications_target ON update_center_notifications(target_group);
CREATE INDEX IF NOT EXISTS idx_update_notifications_created ON update_center_notifications(created_at DESC);
CREATE INDEX IF NOT EXISTS idx_update_notifications_report ON update_center_notifications(report_id) WHERE report_id IS NOT NULL;

-- RLS
ALTER TABLE update_center_notifications ENABLE ROW LEVEL SECURITY;

-- Drop existing policies first (prevent duplicates)
DROP POLICY IF EXISTS "service_manage_notifications" ON update_center_notifications;
DROP POLICY IF EXISTS "users_see_notifications" ON update_center_notifications;
DROP POLICY IF EXISTS "service_ucn_all" ON update_center_notifications;
DROP POLICY IF EXISTS "authenticated_ucn_read" ON update_center_notifications;

-- Service role full access
CREATE POLICY "service_ucn_all" ON update_center_notifications
  FOR ALL TO service_role
  USING (true) WITH CHECK (true);

-- Users can read notifications
CREATE POLICY "authenticated_ucn_read" ON update_center_notifications
  FOR SELECT TO authenticated
  USING (true);

-- Grants
GRANT ALL ON update_center_notifications TO service_role;
GRANT SELECT ON update_center_notifications TO authenticated;

-- Verification
DO $$
BEGIN
  RAISE NOTICE 'âœ… published_reports columns added';
  RAISE NOTICE 'âœ… update_center_notifications table created';
END $$;
-- =====================================================
-- MIGRATION: Sync All Reports to published_reports
-- =====================================================
-- 
-- ğŸ“ ×”×•×¡×£ ××ª ×”×§×•×“ ×”×–×” ×‘×¡×•×£ ×§×•×‘×¥ ×”-SQL ×”×¨××©×™ ×©×œ×š
--    ××—×¨×™ PART 3.6 (PUBLISHED REPORTS MANAGEMENT FUNCTIONS)
--    ×•×œ×¤× ×™ FUNCTION: check_ism_report_status
--
-- =====================================================

-- =====================================================
-- PART 3.7: AUTO-SYNC REPORTS TO published_reports
-- â­ FIXED VERSION - No duplicates, only from Jan 10, 2025
-- =====================================================
-- 
-- REPLACE your existing PART 3.7 with this code
-- This version:
-- 1. Only syncs reports from Jan 10, 2025
-- 2. Uses ON CONFLICT to prevent duplicates
-- 3. Won't re-add deleted reports
-- =====================================================
-- â­ CRITICAL: First delete any reports that came back but should stay deleted
DELETE FROM published_reports pr
WHERE EXISTS (
    SELECT 1 FROM deleted_published_reports d
    WHERE d.report_type = pr.report_type 
    AND d.original_report_id = pr.original_report_id
);

-- ============================================
-- STEP 0: CLEAN UP - Remove reports that should stay deleted
-- ============================================
DELETE FROM published_reports pr
WHERE EXISTS (
    SELECT 1 FROM deleted_published_reports d
    WHERE d.report_type = pr.report_type 
    AND d.original_report_id = pr.original_report_id
);

-- ============================================
-- STEP 1: ENSURE UNIQUE INDEX EXISTS
-- ============================================
CREATE UNIQUE INDEX IF NOT EXISTS idx_published_reports_original_unique 
ON published_reports(report_type, original_report_id) 
WHERE original_report_id IS NOT NULL;

-- ============================================
-- STEP 2: SYNC ISM REPORTS (Jan 10, 2025+, no duplicates, respect deletions)
-- ============================================
INSERT INTO published_reports (
    report_type,
    original_report_id,
    title,
    subtitle,
    highlights,
    key_metric_label,
    key_metric_value,
    key_insights_count,
    pdf_url,
    markdown_preview,
    markdown_content,
    html_content,
    qa_score,
    report_month,
    pmi_value,
    is_featured,
    is_pinned,
    target_group,
    published_at,
    created_at
)
SELECT 
    'ism' as report_type,
    id as original_report_id,
    'Finotaur Macro Report' as title,
    COALESCE(
        executive_summary->>'headline',
        five_line_summary->>'headline',
        'ISM Manufacturing Analysis & Market Impact'
    ) as subtitle,
    COALESCE(
        ARRAY(SELECT jsonb_array_elements_text(executive_summary->'key_points')),
        ARRAY(SELECT jsonb_array_elements_text(five_line_summary->'lines')),
        ARRAY['Comprehensive ISM analysis']::TEXT[]
    ) as highlights,
    'PMI' as key_metric_label,
    COALESCE(
        (executive_summary->>'pmi_value')::TEXT,
        (five_line_summary->>'pmi_value')::TEXT
    ) as key_metric_value,
    COALESCE(
        jsonb_array_length(executive_summary->'key_points'),
        jsonb_array_length(five_line_summary->'lines'),
        12
    ) as key_insights_count,
    '/api/ism/report/' || id || '/pdf' as pdf_url,
    LEFT(markdown_content, 500) as markdown_preview,
    markdown_content,
    html_content,
    qa_score,
    report_month,
    (executive_summary->>'pmi_value')::NUMERIC as pmi_value,
    false as is_featured,
    false as is_pinned,
    'top_secret' as target_group,
    created_at as published_at,
    created_at
FROM ism_reports
WHERE created_at >= '2025-01-10T00:00:00Z'
  AND NOT EXISTS (
      SELECT 1 FROM deleted_published_reports d
      WHERE d.report_type = 'ism' AND d.original_report_id = ism_reports.id
  )
ON CONFLICT (report_type, original_report_id) 
WHERE original_report_id IS NOT NULL
DO NOTHING;

-- ============================================
-- STEP 3: SYNC COMPANY REPORTS (Jan 10, 2025+, no duplicates, respect deletions)
-- ============================================

-- Step 3a: First, remove existing duplicates (keep newest per ticker per day)
DELETE FROM published_reports
WHERE id IN (
  SELECT id FROM (
    SELECT 
      id,
      ROW_NUMBER() OVER (
        PARTITION BY ticker, published_at::date 
        ORDER BY published_at DESC
      ) as rn
    FROM published_reports
    WHERE report_type = 'company'
  ) ranked
  WHERE rn > 1
);

-- Step 3b: Add published_date column for unique constraint
ALTER TABLE published_reports 
ADD COLUMN IF NOT EXISTS published_date DATE;

-- Step 3c: Populate published_date from published_at
UPDATE published_reports 
SET published_date = published_at::date 
WHERE published_date IS NULL;

-- Step 3d: Create unique index to prevent future duplicates per ticker per day
DROP INDEX IF EXISTS idx_published_reports_company_no_dups;
CREATE UNIQUE INDEX IF NOT EXISTS idx_published_reports_company_no_dups 
ON published_reports (report_type, ticker, published_date) 
WHERE report_type = 'company' AND ticker IS NOT NULL;

-- Step 3e: Sync company reports (only newest per ticker)
INSERT INTO published_reports (
    report_type,
    original_report_id,
    title,
    subtitle,
    highlights,
    key_metric_label,
    key_metric_value,
    key_insights_count,
    pdf_url,
    markdown_preview,
    markdown_content,
    html_content,
    qa_score,
    ticker,
    company_name,
    sector,
    is_featured,
    is_pinned,
    target_group,
    published_at,
    published_date,
    created_at
)
SELECT 
    'company' as report_type,
    id as original_report_id,
    'Company Analysis' as title,
    COALESCE(
        executive_summary->>'headline',
        'Deep-Dive Analysis'
    ) as subtitle,
    COALESCE(
        ARRAY(SELECT jsonb_array_elements_text(executive_summary->'key_points')),
        ARRAY['Comprehensive company analysis']::TEXT[]
    ) as highlights,
    ticker as key_metric_label,
    company_name as key_metric_value,
    COALESCE(
        jsonb_array_length(executive_summary->'key_points'),
        8
    ) as key_insights_count,
    '/api/company/report/' || id || '/pdf' as pdf_url,
    LEFT(markdown_content, 500) as markdown_preview,
    markdown_content,
    html_content,
    qa_score,
    ticker,
    company_name,
    sector,
    false as is_featured,
    false as is_pinned,
    'top_secret' as target_group,
    created_at as published_at,
    created_at::date as published_date,
    created_at
FROM (
    -- Get only the NEWEST report per ticker
    SELECT DISTINCT ON (ticker) *
    FROM company_reports
    WHERE created_at >= '2025-01-10T00:00:00Z'
      AND NOT EXISTS (
          SELECT 1 FROM deleted_published_reports d
          WHERE d.report_type = 'company' AND d.original_report_id = company_reports.id
      )
    ORDER BY ticker, created_at DESC
) as latest_company_reports
ON CONFLICT (report_type, ticker, published_date) 
WHERE report_type = 'company' AND ticker IS NOT NULL
DO UPDATE SET
    original_report_id = EXCLUDED.original_report_id,
    markdown_content = EXCLUDED.markdown_content,
    html_content = EXCLUDED.html_content,
    qa_score = EXCLUDED.qa_score,
    updated_at = NOW();

-- ============================================
-- STEP 4: SYNC CRYPTO REPORTS (Jan 10, 2025+, no duplicates, respect deletions)
-- ============================================
INSERT INTO published_reports (
    report_type,
    original_report_id,
    title,
    subtitle,
    highlights,
    key_metric_label,
    key_metric_value,
    key_insights_count,
    pdf_url,
    markdown_preview,
    markdown_content,
    html_content,
    qa_score,
    market_regime,
    is_featured,
    is_pinned,
    target_group,
    published_at,
    created_at
)
SELECT 
    'crypto' as report_type,
    id::TEXT as original_report_id,
    'Crypto Market Report' as title,
    COALESCE(
        executive_summary->>'headline',
        market_regime,
        'Crypto Market Analysis'
    ) as subtitle,
    COALESCE(
        ARRAY(SELECT jsonb_array_elements_text(executive_summary->'key_points')),
        ARRAY['Comprehensive crypto analysis']::TEXT[]
    ) as highlights,
    'Market Regime' as key_metric_label,
    market_regime as key_metric_value,
    COALESCE(
        jsonb_array_length(executive_summary->'key_points'),
        11
    ) as key_insights_count,
    '/api/crypto/report/' || id || '/pdf' as pdf_url,
    LEFT(markdown_content, 500) as markdown_preview,
    markdown_content,
    html_content,
    qa_score,
    market_regime,
    false as is_featured,
    false as is_pinned,
    'top_secret' as target_group,
    created_at as published_at,
    created_at
FROM crypto_reports
WHERE created_at >= '2025-01-10T00:00:00Z'
  AND NOT EXISTS (
      SELECT 1 FROM deleted_published_reports d
      WHERE d.report_type = 'crypto' AND d.original_report_id = crypto_reports.id::TEXT
  )
ON CONFLICT (report_type, original_report_id) 
WHERE original_report_id IS NOT NULL
DO NOTHING;

-- ============================================
-- STEP 5: MARK LATEST REPORTS AS FEATURED
-- (Only if not already featured)
-- ============================================
WITH latest_reports AS (
    SELECT DISTINCT ON (report_type) id
    FROM published_reports
    ORDER BY report_type, published_at DESC
)
UPDATE published_reports
SET is_featured = true
WHERE id IN (SELECT id FROM latest_reports)
AND is_featured = false;  -- Only update if not already featured

-- ============================================
-- VERIFICATION
-- ============================================
DO $$
DECLARE
    v_ism_count INTEGER;
    v_company_count INTEGER;
    v_crypto_count INTEGER;
    v_total INTEGER;
BEGIN
    SELECT COUNT(*) INTO v_ism_count FROM published_reports WHERE report_type = 'ism';
    SELECT COUNT(*) INTO v_company_count FROM published_reports WHERE report_type = 'company';
    SELECT COUNT(*) INTO v_crypto_count FROM published_reports WHERE report_type = 'crypto';
    SELECT COUNT(*) INTO v_total FROM published_reports;
    
    RAISE NOTICE '';
    RAISE NOTICE '=====================================================';
    RAISE NOTICE 'âœ… PART 3.7: AUTO-SYNC COMPLETE (FIXED VERSION)';
    RAISE NOTICE '=====================================================';
    RAISE NOTICE '';
    RAISE NOTICE 'Reports in published_reports:';
    RAISE NOTICE '  â€¢ ISM (Macro): %', v_ism_count;
    RAISE NOTICE '  â€¢ Company: %', v_company_count;
    RAISE NOTICE '  â€¢ Crypto: %', v_crypto_count;
    RAISE NOTICE '  â€¢ TOTAL: %', v_total;
    RAISE NOTICE '';
    RAISE NOTICE 'â­ Only reports from Jan 10, 2025 are synced';
    RAISE NOTICE 'â­ Duplicates are prevented by ON CONFLICT DO NOTHING';
    RAISE NOTICE '=====================================================';
END $$;

-- =====================================================
-- PART 3.8: REPORT LIKES & BOOKMARKS
-- =====================================================
-- Add this AFTER PART 3.7 (AUTO-SYNC REPORTS)
-- And BEFORE "FUNCTION: check_ism_report_status"
-- =====================================================

-- ============================================
-- 1. CREATE report_likes TABLE
-- ============================================
CREATE TABLE IF NOT EXISTS public.report_likes (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    report_id UUID NOT NULL REFERENCES published_reports(id) ON DELETE CASCADE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    
    -- Ensure one like per user per report
    UNIQUE(user_id, report_id)
);

-- ============================================
-- 2. CREATE report_bookmarks TABLE
-- ============================================
CREATE TABLE IF NOT EXISTS public.report_bookmarks (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    report_id UUID NOT NULL REFERENCES published_reports(id) ON DELETE CASCADE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    
    -- Ensure one bookmark per user per report
    UNIQUE(user_id, report_id)
);

-- ============================================
-- 3. INDEXES
-- ============================================
CREATE INDEX IF NOT EXISTS idx_report_likes_user_id ON public.report_likes(user_id);
CREATE INDEX IF NOT EXISTS idx_report_likes_report_id ON public.report_likes(report_id);
CREATE INDEX IF NOT EXISTS idx_report_bookmarks_user_id ON public.report_bookmarks(user_id);
CREATE INDEX IF NOT EXISTS idx_report_bookmarks_report_id ON public.report_bookmarks(report_id);

-- ============================================
-- 4. ENABLE ROW LEVEL SECURITY
-- ============================================
ALTER TABLE public.report_likes ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.report_bookmarks ENABLE ROW LEVEL SECURITY;

-- ============================================
-- 5. RLS POLICIES FOR report_likes
-- ============================================

-- Drop existing policies if any
DROP POLICY IF EXISTS "Users can view own likes" ON public.report_likes;
DROP POLICY IF EXISTS "Users can insert own likes" ON public.report_likes;
DROP POLICY IF EXISTS "Users can delete own likes" ON public.report_likes;
DROP POLICY IF EXISTS "Service role manages likes" ON public.report_likes;

-- Users can view their own likes
CREATE POLICY "Users can view own likes"
    ON public.report_likes
    FOR SELECT TO authenticated
    USING (auth.uid() = user_id);

-- Users can insert their own likes
CREATE POLICY "Users can insert own likes"
    ON public.report_likes
    FOR INSERT TO authenticated
    WITH CHECK (auth.uid() = user_id);

-- Users can delete their own likes
CREATE POLICY "Users can delete own likes"
    ON public.report_likes
    FOR DELETE TO authenticated
    USING (auth.uid() = user_id);

-- Service role full access
CREATE POLICY "Service role manages likes"
    ON public.report_likes
    FOR ALL TO service_role
    USING (true) WITH CHECK (true);

-- ============================================
-- 6. RLS POLICIES FOR report_bookmarks
-- ============================================

-- Drop existing policies if any
DROP POLICY IF EXISTS "Users can view own bookmarks" ON public.report_bookmarks;
DROP POLICY IF EXISTS "Users can insert own bookmarks" ON public.report_bookmarks;
DROP POLICY IF EXISTS "Users can delete own bookmarks" ON public.report_bookmarks;
DROP POLICY IF EXISTS "Service role manages bookmarks" ON public.report_bookmarks;

-- Users can view their own bookmarks
CREATE POLICY "Users can view own bookmarks"
    ON public.report_bookmarks
    FOR SELECT TO authenticated
    USING (auth.uid() = user_id);

-- Users can insert their own bookmarks
CREATE POLICY "Users can insert own bookmarks"
    ON public.report_bookmarks
    FOR INSERT TO authenticated
    WITH CHECK (auth.uid() = user_id);

-- Users can delete their own bookmarks
CREATE POLICY "Users can delete own bookmarks"
    ON public.report_bookmarks
    FOR DELETE TO authenticated
    USING (auth.uid() = user_id);

-- Service role full access
CREATE POLICY "Service role manages bookmarks"
    ON public.report_bookmarks
    FOR ALL TO service_role
    USING (true) WITH CHECK (true);

-- ============================================
-- 7. GRANTS
-- ============================================
GRANT SELECT, INSERT, DELETE ON public.report_likes TO authenticated;
GRANT SELECT, INSERT, DELETE ON public.report_bookmarks TO authenticated;
GRANT ALL ON public.report_likes TO service_role;
GRANT ALL ON public.report_bookmarks TO service_role;

-- ============================================
-- 8. HELPER VIEW: Report interaction counts
-- ============================================
CREATE OR REPLACE VIEW public.v_report_interaction_counts AS
SELECT 
    pr.id as report_id,
    pr.title,
    pr.report_type,
    COALESCE(likes.count, 0) as likes_count,
    COALESCE(bookmarks.count, 0) as bookmarks_count
FROM published_reports pr
LEFT JOIN (
    SELECT report_id, COUNT(*) as count 
    FROM report_likes 
    GROUP BY report_id
) likes ON pr.id = likes.report_id
LEFT JOIN (
    SELECT report_id, COUNT(*) as count 
    FROM report_bookmarks 
    GROUP BY report_id
) bookmarks ON pr.id = bookmarks.report_id;

-- Grant access to the view
GRANT SELECT ON public.v_report_interaction_counts TO authenticated;

-- ============================================
-- 9. FUNCTION: Get user's bookmarked reports
-- ============================================
CREATE OR REPLACE FUNCTION get_user_bookmarked_reports(p_user_id UUID)
RETURNS TABLE (
    id UUID,
    report_type TEXT,
    title TEXT,
    subtitle TEXT,
    pdf_url TEXT,
    published_at TIMESTAMPTZ,
    bookmarked_at TIMESTAMPTZ
)
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
    RETURN QUERY
    SELECT 
        pr.id,
        pr.report_type,
        pr.title,
        pr.subtitle,
        pr.pdf_url,
        pr.published_at,
        rb.created_at as bookmarked_at
    FROM report_bookmarks rb
    JOIN published_reports pr ON pr.id = rb.report_id
    WHERE rb.user_id = p_user_id
    ORDER BY rb.created_at DESC;
END;
$$;

GRANT EXECUTE ON FUNCTION get_user_bookmarked_reports(UUID) TO authenticated;

-- ============================================
-- 10. VERIFICATION
-- ============================================
DO $$
DECLARE
    v_likes_exists BOOLEAN;
    v_bookmarks_exists BOOLEAN;
BEGIN
    SELECT EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_name = 'report_likes'
    ) INTO v_likes_exists;
    
    SELECT EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_name = 'report_bookmarks'
    ) INTO v_bookmarks_exists;
    
    RAISE NOTICE '';
    RAISE NOTICE '=====================================================';
    RAISE NOTICE 'âœ… PART 3.8: REPORT LIKES & BOOKMARKS COMPLETE';
    RAISE NOTICE '=====================================================';
    RAISE NOTICE '';
    RAISE NOTICE 'Tables created:';
    RAISE NOTICE '  â€¢ report_likes: %', CASE WHEN v_likes_exists THEN 'YES' ELSE 'NO' END;
    RAISE NOTICE '  â€¢ report_bookmarks: %', CASE WHEN v_bookmarks_exists THEN 'YES' ELSE 'NO' END;
    RAISE NOTICE '';
    RAISE NOTICE 'Features:';
    RAISE NOTICE '  â€¢ Users can like/unlike reports';
    RAISE NOTICE '  â€¢ Users can bookmark/unbookmark reports';
    RAISE NOTICE '  â€¢ Each user can only like/bookmark once per report';
    RAISE NOTICE '  â€¢ RLS ensures users only see their own data';
    RAISE NOTICE '=====================================================';
END $$;

-- =====================================================
-- END OF PART 3.8
-- =====================================================
-- =====================================================
-- PART 3.9: AUTO-PUBLISH TO published_reports (FIXED v3.0)
-- =====================================================
-- CRITICAL FIX: All triggers now check deleted_published_reports
-- Deleted reports will NOT come back when running this schema
-- =====================================================

-- ============================================
-- 1. TRIGGER: Auto-publish ISM reports
-- ============================================

DROP FUNCTION IF EXISTS auto_publish_ism_report() CASCADE;

CREATE OR REPLACE FUNCTION auto_publish_ism_report()
RETURNS TRIGGER AS $$
DECLARE
    v_existing_id UUID;
    v_month_display TEXT;
    v_is_deleted BOOLEAN := FALSE;
BEGIN
    -- Only proceed if we have content
    IF NEW.markdown_content IS NULL OR LENGTH(NEW.markdown_content) < 100 THEN
        RETURN NEW;
    END IF;

    -- â­ CRITICAL: Check if this report was deleted - DON'T RE-SYNC
    SELECT EXISTS (
        SELECT 1 FROM deleted_published_reports
        WHERE report_type = 'ism' AND original_report_id = NEW.id
    ) INTO v_is_deleted;
    
    IF v_is_deleted THEN
        RAISE NOTICE '[AutoPublish] ISM report % was deleted by admin - skipping sync', NEW.id;
        RETURN NEW;
    END IF;

    -- Format month for display
    v_month_display := TO_CHAR(TO_DATE(NEW.report_month, 'YYYY-MM'), 'Month YYYY');

    -- Check if already exists
    SELECT id INTO v_existing_id
    FROM published_reports
    WHERE original_report_id = NEW.id AND report_type = 'ism';

    IF v_existing_id IS NOT NULL THEN
        -- UPDATE existing
        UPDATE published_reports
        SET 
            markdown_content = NEW.markdown_content,
            html_content = NEW.html_content,
            markdown_preview = LEFT(NEW.markdown_content, 500),
            qa_score = NEW.qa_score,
            updated_at = NOW()
        WHERE id = v_existing_id;
        
        RAISE NOTICE '[AutoPublish] Updated ISM report % in published_reports', NEW.id;
    ELSE
        -- INSERT new
        INSERT INTO published_reports (
            report_type,
            original_report_id,
            title,
            subtitle,
            report_month,
            markdown_content,
            html_content,
            markdown_preview,
            highlights,
            key_metric_label,
            key_metric_value,
            pmi_value,
            qa_score,
            is_featured,
            is_pinned,
            target_group,
            published_at,
            created_at,
            updated_at
        ) VALUES (
            'ism',
            NEW.id,
            'ISM Manufacturing Report',
            v_month_display,
            NEW.report_month,
            NEW.markdown_content,
            NEW.html_content,
            LEFT(NEW.markdown_content, 500),
            COALESCE(
                ARRAY(SELECT jsonb_array_elements_text(NEW.executive_summary->'key_points')),
                ARRAY['ISM Manufacturing Analysis']::TEXT[]
            ),
            'PMI',
            (NEW.executive_summary->>'pmi_value')::TEXT,
            (NEW.executive_summary->>'pmi_value')::NUMERIC,
            NEW.qa_score,
            true,
            false,
            'top_secret',
            NOW(),
            NOW(),
            NOW()
        );
        
        RAISE NOTICE '[AutoPublish] Created ISM report % in published_reports', NEW.id;
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trigger_auto_publish_ism ON ism_reports;

CREATE TRIGGER trigger_auto_publish_ism
    AFTER INSERT OR UPDATE OF markdown_content, html_content
    ON ism_reports
    FOR EACH ROW
    EXECUTE FUNCTION auto_publish_ism_report();

-- ============================================
-- 2. TRIGGER: Auto-publish Company reports
-- ============================================

DROP FUNCTION IF EXISTS auto_publish_company_report() CASCADE;

CREATE OR REPLACE FUNCTION auto_publish_company_report()
RETURNS TRIGGER AS $$
DECLARE
    v_existing_id UUID;
    v_is_deleted BOOLEAN := FALSE;
BEGIN
    -- Only proceed if we have content
    IF NEW.markdown_content IS NULL OR LENGTH(NEW.markdown_content) < 100 THEN
        RETURN NEW;
    END IF;

    -- â­ CRITICAL: Check if this report was deleted - DON'T RE-SYNC
    SELECT EXISTS (
        SELECT 1 FROM deleted_published_reports
        WHERE report_type = 'company' AND original_report_id = NEW.id
    ) INTO v_is_deleted;
    
    IF v_is_deleted THEN
        RAISE NOTICE '[AutoPublish] Company report % was deleted by admin - skipping sync', NEW.id;
        RETURN NEW;
    END IF;

    -- Check if already exists
    SELECT id INTO v_existing_id
    FROM published_reports
    WHERE original_report_id = NEW.id AND report_type = 'company';

    IF v_existing_id IS NOT NULL THEN
        -- UPDATE existing
        UPDATE published_reports
        SET 
            markdown_content = NEW.markdown_content,
            html_content = NEW.html_content,
            markdown_preview = LEFT(NEW.markdown_content, 500),
            qa_score = NEW.qa_score,
            updated_at = NOW()
        WHERE id = v_existing_id;
        
        RAISE NOTICE '[AutoPublish] Updated Company report % in published_reports', NEW.id;
    ELSE
        -- INSERT new
        INSERT INTO published_reports (
            report_type,
            original_report_id,
            title,
            subtitle,
            ticker,
            company_name,
            sector,
            markdown_content,
            html_content,
            markdown_preview,
            highlights,
            key_metric_label,
            key_metric_value,
            qa_score,
            is_featured,
            is_pinned,
            target_group,
            published_at,
            created_at,
            updated_at
        ) VALUES (
            'company',
            NEW.id,
            'Company Analysis',
            COALESCE(NEW.company_name, NEW.ticker) || ' Deep-Dive',
            NEW.ticker,
            NEW.company_name,
            NEW.sector,
            NEW.markdown_content,
            NEW.html_content,
            LEFT(NEW.markdown_content, 500),
            COALESCE(
                ARRAY(SELECT jsonb_array_elements_text(NEW.executive_summary->'key_points')),
                ARRAY['Company Analysis']::TEXT[]
            ),
            NEW.ticker,
            NEW.company_name,
            NEW.qa_score,
            true,
            false,
            'top_secret',
            NOW(),
            NOW(),
            NOW()
        );
        
        RAISE NOTICE '[AutoPublish] Created Company report % in published_reports', NEW.id;
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trigger_auto_publish_company ON company_reports;

CREATE TRIGGER trigger_auto_publish_company
    AFTER INSERT OR UPDATE OF markdown_content, html_content
    ON company_reports
    FOR EACH ROW
    EXECUTE FUNCTION auto_publish_company_report();

-- ============================================
-- 3. TRIGGER: Auto-publish Crypto reports
-- ============================================

DROP FUNCTION IF EXISTS auto_publish_crypto_report() CASCADE;

CREATE OR REPLACE FUNCTION auto_publish_crypto_report()
RETURNS TRIGGER AS $$
DECLARE
    v_existing_id UUID;
    v_is_deleted BOOLEAN := FALSE;
BEGIN
    -- Only proceed if we have content
    IF NEW.markdown_content IS NULL OR LENGTH(NEW.markdown_content) < 100 THEN
        RETURN NEW;
    END IF;

    -- â­ CRITICAL: Check if this report was deleted - DON'T RE-SYNC
    SELECT EXISTS (
        SELECT 1 FROM deleted_published_reports
        WHERE report_type = 'crypto' AND original_report_id = NEW.id::TEXT
    ) INTO v_is_deleted;
    
    IF v_is_deleted THEN
        RAISE NOTICE '[AutoPublish] Crypto report % was deleted by admin - skipping sync', NEW.id;
        RETURN NEW;
    END IF;

    -- Check if already exists
    SELECT id INTO v_existing_id
    FROM published_reports
    WHERE original_report_id = NEW.id::TEXT AND report_type = 'crypto';

    IF v_existing_id IS NOT NULL THEN
        -- UPDATE existing
        UPDATE published_reports
        SET 
            markdown_content = NEW.markdown_content,
            html_content = NEW.html_content,
            markdown_preview = LEFT(NEW.markdown_content, 500),
            qa_score = NEW.qa_score,
            updated_at = NOW()
        WHERE id = v_existing_id;
        
        RAISE NOTICE '[AutoPublish] Updated Crypto report % in published_reports', NEW.id;
    ELSE
        -- INSERT new
        INSERT INTO published_reports (
            report_type,
            original_report_id,
            title,
            subtitle,
            market_regime,
            markdown_content,
            html_content,
            markdown_preview,
            highlights,
            key_metric_label,
            key_metric_value,
            qa_score,
            is_featured,
            is_pinned,
            target_group,
            published_at,
            created_at,
            updated_at
        ) VALUES (
            'crypto',
            NEW.id::TEXT,
            'Crypto Market Report',
            COALESCE(NEW.market_regime, 'Market Analysis'),
            NEW.market_regime,
            NEW.markdown_content,
            NEW.html_content,
            LEFT(NEW.markdown_content, 500),
            COALESCE(
                ARRAY(SELECT jsonb_array_elements_text(NEW.executive_summary->'key_points')),
                ARRAY['Crypto Analysis']::TEXT[]
            ),
            'Market Regime',
            NEW.market_regime,
            NEW.qa_score,
            true,
            false,
            'top_secret',
            NOW(),
            NOW(),
            NOW()
        );
        
        RAISE NOTICE '[AutoPublish] Created Crypto report % in published_reports', NEW.id;
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trigger_auto_publish_crypto ON crypto_reports;

CREATE TRIGGER trigger_auto_publish_crypto
    AFTER INSERT OR UPDATE OF markdown_content, html_content
    ON crypto_reports
    FOR EACH ROW
    EXECUTE FUNCTION auto_publish_crypto_report();

-- ============================================
-- 4. FUNCTION: Manual sync all (respects deletions)
-- ============================================

DROP FUNCTION IF EXISTS sync_all_published_reports_content();

CREATE OR REPLACE FUNCTION sync_all_published_reports_content()
RETURNS TABLE (
    out_report_type TEXT,
    synced_count INTEGER,
    created_count INTEGER,
    skipped_deleted INTEGER
) AS $$
DECLARE
    v_ism_synced INTEGER := 0;
    v_ism_created INTEGER := 0;
    v_ism_skipped INTEGER := 0;
    v_company_synced INTEGER := 0;
    v_company_created INTEGER := 0;
    v_company_skipped INTEGER := 0;
    v_crypto_synced INTEGER := 0;
    v_crypto_created INTEGER := 0;
    v_crypto_skipped INTEGER := 0;
BEGIN
    -- Count deleted reports that will be skipped
    SELECT COUNT(*) INTO v_ism_skipped FROM deleted_published_reports d WHERE d.report_type = 'ism';
    SELECT COUNT(*) INTO v_company_skipped FROM deleted_published_reports d WHERE d.report_type = 'company';
    SELECT COUNT(*) INTO v_crypto_skipped FROM deleted_published_reports d WHERE d.report_type = 'crypto';

    -- ========== ISM ==========
    -- Update existing (only if not deleted)
    UPDATE published_reports pr
    SET 
        markdown_content = ir.markdown_content,
        html_content = ir.html_content,
        markdown_preview = LEFT(ir.markdown_content, 500),
        updated_at = NOW()
    FROM ism_reports ir
    WHERE pr.original_report_id = ir.id
      AND pr.report_type = 'ism'
      AND (pr.markdown_content IS NULL OR LENGTH(pr.markdown_content) < 100)
      AND ir.markdown_content IS NOT NULL
      AND LENGTH(ir.markdown_content) > 100
      AND NOT EXISTS (
          SELECT 1 FROM deleted_published_reports d
          WHERE d.report_type = 'ism' AND d.original_report_id = ir.id
      );
    GET DIAGNOSTICS v_ism_synced = ROW_COUNT;
    
    -- Insert missing (only if not deleted)
    INSERT INTO published_reports (
        report_type, original_report_id, title, subtitle, report_month,
        markdown_content, html_content, markdown_preview, highlights,
        key_metric_label, key_metric_value, pmi_value, qa_score,
        is_featured, target_group, published_at, created_at
    )
    SELECT 
        'ism', ir.id, 'ISM Manufacturing Report',
        TO_CHAR(TO_DATE(ir.report_month, 'YYYY-MM'), 'Month YYYY'),
        ir.report_month, ir.markdown_content, ir.html_content,
        LEFT(ir.markdown_content, 500),
        COALESCE(ARRAY(SELECT jsonb_array_elements_text(ir.executive_summary->'key_points')), ARRAY['ISM Analysis']::TEXT[]),
        'PMI', (ir.executive_summary->>'pmi_value')::TEXT,
        (ir.executive_summary->>'pmi_value')::NUMERIC, ir.qa_score,
        true, 'top_secret', ir.created_at, ir.created_at
    FROM ism_reports ir
    WHERE ir.markdown_content IS NOT NULL
      AND LENGTH(ir.markdown_content) > 100
      AND NOT EXISTS (
          SELECT 1 FROM published_reports pr 
          WHERE pr.original_report_id = ir.id AND pr.report_type = 'ism'
      )
      AND NOT EXISTS (
          SELECT 1 FROM deleted_published_reports d
          WHERE d.report_type = 'ism' AND d.original_report_id = ir.id
      );
    GET DIAGNOSTICS v_ism_created = ROW_COUNT;

    -- ========== COMPANY ==========
    UPDATE published_reports pr
    SET 
        markdown_content = cr.markdown_content,
        html_content = cr.html_content,
        markdown_preview = LEFT(cr.markdown_content, 500),
        updated_at = NOW()
    FROM company_reports cr
    WHERE pr.original_report_id = cr.id
      AND pr.report_type = 'company'
      AND (pr.markdown_content IS NULL OR LENGTH(pr.markdown_content) < 100)
      AND cr.markdown_content IS NOT NULL
      AND LENGTH(cr.markdown_content) > 100
      AND NOT EXISTS (
          SELECT 1 FROM deleted_published_reports d
          WHERE d.report_type = 'company' AND d.original_report_id = cr.id
      );
    GET DIAGNOSTICS v_company_synced = ROW_COUNT;
    
    INSERT INTO published_reports (
        report_type, original_report_id, title, subtitle, ticker, company_name, sector,
        markdown_content, html_content, markdown_preview, highlights,
        key_metric_label, key_metric_value, qa_score,
        is_featured, target_group, published_at, created_at
    )
    SELECT 
        'company', cr.id, 'Company Analysis',
        COALESCE(cr.company_name, cr.ticker) || ' Deep-Dive',
        cr.ticker, cr.company_name, cr.sector,
        cr.markdown_content, cr.html_content, LEFT(cr.markdown_content, 500),
        COALESCE(ARRAY(SELECT jsonb_array_elements_text(cr.executive_summary->'key_points')), ARRAY['Company Analysis']::TEXT[]),
        cr.ticker, cr.company_name, cr.qa_score,
        true, 'top_secret', cr.created_at, cr.created_at
    FROM company_reports cr
    WHERE cr.markdown_content IS NOT NULL
      AND LENGTH(cr.markdown_content) > 100
      AND NOT EXISTS (
          SELECT 1 FROM published_reports pr 
          WHERE pr.original_report_id = cr.id AND pr.report_type = 'company'
      )
      AND NOT EXISTS (
          SELECT 1 FROM deleted_published_reports d
          WHERE d.report_type = 'company' AND d.original_report_id = cr.id
      );
    GET DIAGNOSTICS v_company_created = ROW_COUNT;

    -- ========== CRYPTO ==========
    UPDATE published_reports pr
    SET 
        markdown_content = crypto.markdown_content,
        html_content = crypto.html_content,
        markdown_preview = LEFT(crypto.markdown_content, 500),
        updated_at = NOW()
    FROM crypto_reports crypto
    WHERE pr.original_report_id = crypto.id::TEXT
      AND pr.report_type = 'crypto'
      AND (pr.markdown_content IS NULL OR LENGTH(pr.markdown_content) < 100)
      AND crypto.markdown_content IS NOT NULL
      AND LENGTH(crypto.markdown_content) > 100
      AND NOT EXISTS (
          SELECT 1 FROM deleted_published_reports d
          WHERE d.report_type = 'crypto' AND d.original_report_id = crypto.id::TEXT
      );
    GET DIAGNOSTICS v_crypto_synced = ROW_COUNT;
    
    INSERT INTO published_reports (
        report_type, original_report_id, title, subtitle, market_regime,
        markdown_content, html_content, markdown_preview, highlights,
        key_metric_label, key_metric_value, qa_score,
        is_featured, target_group, published_at, created_at
    )
    SELECT 
        'crypto', crypto.id::TEXT, 'Crypto Market Report',
        COALESCE(crypto.market_regime, 'Market Analysis'), crypto.market_regime,
        crypto.markdown_content, crypto.html_content, LEFT(crypto.markdown_content, 500),
        COALESCE(ARRAY(SELECT jsonb_array_elements_text(crypto.executive_summary->'key_points')), ARRAY['Crypto Analysis']::TEXT[]),
        'Market Regime', crypto.market_regime, crypto.qa_score,
        true, 'top_secret', crypto.created_at, crypto.created_at
    FROM crypto_reports crypto
    WHERE crypto.markdown_content IS NOT NULL
      AND LENGTH(crypto.markdown_content) > 100
      AND NOT EXISTS (
          SELECT 1 FROM published_reports pr 
          WHERE pr.original_report_id = crypto.id::TEXT AND pr.report_type = 'crypto'
      )
      AND NOT EXISTS (
          SELECT 1 FROM deleted_published_reports d
          WHERE d.report_type = 'crypto' AND d.original_report_id = crypto.id::TEXT
      );
    GET DIAGNOSTICS v_crypto_created = ROW_COUNT;
    
    -- Return results
    RETURN QUERY
    SELECT 'ism'::TEXT, v_ism_synced, v_ism_created, v_ism_skipped
    UNION ALL
    SELECT 'company'::TEXT, v_company_synced, v_company_created, v_company_skipped
    UNION ALL
    SELECT 'crypto'::TEXT, v_crypto_synced, v_crypto_created, v_crypto_skipped;
END;
$$ LANGUAGE plpgsql;

GRANT EXECUTE ON FUNCTION sync_all_published_reports_content() TO authenticated;
GRANT EXECUTE ON FUNCTION sync_all_published_reports_content() TO service_role;

-- ============================================
-- 5. RUN SYNC NOW (respects deletions)
-- ============================================

SELECT * FROM sync_all_published_reports_content();

-- ============================================
-- 6. VERIFICATION
-- ============================================

DO $$
DECLARE
    v_ism_count INTEGER;
    v_company_count INTEGER;
    v_crypto_count INTEGER;
    v_deleted_count INTEGER;
    v_with_content INTEGER;
BEGIN
    SELECT COUNT(*) INTO v_ism_count FROM published_reports WHERE report_type = 'ism';
    SELECT COUNT(*) INTO v_company_count FROM published_reports WHERE report_type = 'company';
    SELECT COUNT(*) INTO v_crypto_count FROM published_reports WHERE report_type = 'crypto';
    SELECT COUNT(*) INTO v_deleted_count FROM deleted_published_reports;
    SELECT COUNT(*) INTO v_with_content FROM published_reports 
        WHERE markdown_content IS NOT NULL AND LENGTH(markdown_content) > 100;
    
    RAISE NOTICE '';
    RAISE NOTICE '=====================================================';
    RAISE NOTICE 'âœ… PART 3.9 FIXED v3.0: AUTO-PUBLISH COMPLETE';
    RAISE NOTICE '=====================================================';
    RAISE NOTICE '';
    RAISE NOTICE 'Triggers created (INSERT + UPDATE):';
    RAISE NOTICE '  â€¢ trigger_auto_publish_ism';
    RAISE NOTICE '  â€¢ trigger_auto_publish_company';
    RAISE NOTICE '  â€¢ trigger_auto_publish_crypto';
    RAISE NOTICE '';
    RAISE NOTICE 'Published Reports:';
    RAISE NOTICE '  â€¢ ISM: %', v_ism_count;
    RAISE NOTICE '  â€¢ Company: %', v_company_count;
    RAISE NOTICE '  â€¢ Crypto: %', v_crypto_count;
    RAISE NOTICE '  â€¢ With content: %', v_with_content;
    RAISE NOTICE '';
    RAISE NOTICE 'Deleted reports (will NOT come back): %', v_deleted_count;
    RAISE NOTICE '';
    RAISE NOTICE 'â­ CRITICAL FIX: Deleted reports are now respected!';
    RAISE NOTICE 'â­ New reports will auto-publish to dashboard';
    RAISE NOTICE 'â­ Admin deletions are permanent (unless restored)';
    RAISE NOTICE '=====================================================';
END $$;

-- Show final status
SELECT 
    report_type,
    COUNT(*) as total,
    COUNT(*) FILTER (WHERE markdown_content IS NOT NULL AND LENGTH(markdown_content) > 100) as with_content
FROM published_reports
GROUP BY report_type
ORDER BY report_type;

-- Show deleted reports count
SELECT report_type, COUNT(*) as deleted_count 
FROM deleted_published_reports 
GROUP BY report_type;

-- =====================================================
-- END OF PART 3.9 FIXED v3.0
-- =====================================================
-- =====================================================
-- PART 3.10: FIX PDF STORAGE PATH FOR EXISTING REPORTS
-- =====================================================
-- This migration populates pdf_storage_path for existing reports
-- so the TopSecretDashboard can generate signed URLs for PDF downloads
-- =====================================================

-- ============================================
-- STEP 1: Update ISM reports with pdf_storage_path
-- Pattern: ism-reports/ism-report-{YYYY-MM}.pdf
-- ============================================
UPDATE published_reports
SET 
    pdf_storage_path = 'ism-reports/ism-report-' || report_month || '.pdf',
    updated_at = NOW()
WHERE report_type = 'ism'
  AND report_month IS NOT NULL
  AND pdf_url IS NOT NULL
  AND (pdf_storage_path IS NULL OR pdf_storage_path = '');

-- ============================================
-- STEP 2: Update Company reports with pdf_storage_path
-- Pattern: company-reports/company-report-{ticker}-{id}.pdf
-- ============================================
UPDATE published_reports
SET 
    pdf_storage_path = 'company-reports/company-report-' || LOWER(ticker) || '-' || original_report_id || '.pdf',
    updated_at = NOW()
WHERE report_type = 'company'
  AND ticker IS NOT NULL
  AND original_report_id IS NOT NULL
  AND pdf_url IS NOT NULL
  AND (pdf_storage_path IS NULL OR pdf_storage_path = '');

-- ============================================
-- STEP 3: Update Crypto reports with pdf_storage_path
-- Pattern: crypto-reports/crypto-report-{YYYY-MM-DD}.pdf
-- ============================================
UPDATE published_reports pr
SET 
    pdf_storage_path = 'crypto-reports/crypto-report-' || TO_CHAR(pr.published_at, 'YYYY-MM-DD') || '.pdf',
    updated_at = NOW()
WHERE pr.report_type = 'crypto'
  AND pr.pdf_url IS NOT NULL
  AND (pr.pdf_storage_path IS NULL OR pr.pdf_storage_path = '');

-- ============================================
-- STEP 4: VERIFICATION
-- ============================================
DO $$
DECLARE
    v_total INTEGER;
    v_with_path INTEGER;
    v_ism_fixed INTEGER;
    v_company_fixed INTEGER;
    v_crypto_fixed INTEGER;
BEGIN
    SELECT COUNT(*) INTO v_total FROM published_reports WHERE pdf_url IS NOT NULL;
    SELECT COUNT(*) INTO v_with_path FROM published_reports WHERE pdf_storage_path IS NOT NULL;
    SELECT COUNT(*) INTO v_ism_fixed FROM published_reports WHERE report_type = 'ism' AND pdf_storage_path IS NOT NULL;
    SELECT COUNT(*) INTO v_company_fixed FROM published_reports WHERE report_type = 'company' AND pdf_storage_path IS NOT NULL;
    SELECT COUNT(*) INTO v_crypto_fixed FROM published_reports WHERE report_type = 'crypto' AND pdf_storage_path IS NOT NULL;
    
    RAISE NOTICE '';
    RAISE NOTICE '=====================================================';
    RAISE NOTICE 'âœ… PART 3.10: PDF STORAGE PATH MIGRATION COMPLETE';
    RAISE NOTICE '=====================================================';
    RAISE NOTICE '';
    RAISE NOTICE 'Reports with PDF URL: %', v_total;
    RAISE NOTICE 'Reports with storage path: %', v_with_path;
    RAISE NOTICE '';
    RAISE NOTICE 'By type:';
    RAISE NOTICE '  â€¢ ISM with path: %', v_ism_fixed;
    RAISE NOTICE '  â€¢ Company with path: %', v_company_fixed;
    RAISE NOTICE '  â€¢ Crypto with path: %', v_crypto_fixed;
    RAISE NOTICE '';
    RAISE NOTICE 'Storage paths:';
    RAISE NOTICE '  â€¢ ISM: ism-reports/ism-report-{YYYY-MM}.pdf';
    RAISE NOTICE '  â€¢ Company: company-reports/company-report-{ticker}-{id}.pdf';
    RAISE NOTICE '  â€¢ Crypto: crypto-reports/crypto-report-{YYYY-MM-DD}.pdf';
    RAISE NOTICE '=====================================================';
END $$;

-- Show results
SELECT 
    report_type,
    COUNT(*) as total,
    COUNT(pdf_storage_path) as with_storage_path,
    COUNT(pdf_url) as with_url
FROM published_reports
GROUP BY report_type
ORDER BY report_type;

-- =====================================================
-- END OF PART 3.10
-- =====================================================
-- =====================================================
-- PART 3.11: ISM INSIGHTS TABLES
-- =====================================================
-- Stores actionable insights from ISM reports:
-- 1. Sector outlook (up/down expectations)
-- 2. Specific stocks with tailwinds
-- 3. Economic environment & implications
-- =====================================================

-- ============================================
-- TABLE 1: ism_sector_outlook
-- ×¡×§×˜×•×¨×™× ×©×¦×¤×•×™×™× ×œ×¢×œ×•×ª/×œ×¨×“×ª ×‘×¢×§×‘×•×ª ×”×“×•×—
-- ============================================
CREATE TABLE IF NOT EXISTS ism_sector_outlook (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    report_id TEXT NOT NULL,
    report_month TEXT NOT NULL,  -- YYYY-MM
    
    -- Sector identification
    sector_name TEXT NOT NULL,
    sector_etf TEXT,  -- XLF, XLK, etc.
    
    -- Direction & Conviction
    direction TEXT NOT NULL CHECK (direction IN ('bullish', 'bearish', 'neutral')),
    conviction TEXT DEFAULT 'medium' CHECK (conviction IN ('high', 'medium', 'low')),
    expected_move_percent DECIMAL(5,2),  -- e.g., +5.5% or -3.2%
    timeframe TEXT DEFAULT '1-3 months',  -- Expected timeframe
    
    -- Reasoning from ISM
    primary_driver TEXT NOT NULL,  -- Main reason (e.g., "New Orders surge to 58.3")
    supporting_quotes TEXT[],  -- Executive quotes supporting this view
    ism_components_impact JSONB,  -- Which ISM components affect this sector
    
    -- Risk factors
    key_risks TEXT[],
    invalidation_level TEXT,  -- What would invalidate this thesis
    
    -- Display
    display_order INTEGER DEFAULT 1,
    
    -- Timestamps
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    
    UNIQUE(report_id, sector_name)
);

-- Indexes
CREATE INDEX IF NOT EXISTS idx_sector_outlook_report ON ism_sector_outlook(report_id);
CREATE INDEX IF NOT EXISTS idx_sector_outlook_month ON ism_sector_outlook(report_month);
CREATE INDEX IF NOT EXISTS idx_sector_outlook_direction ON ism_sector_outlook(direction);

-- ============================================
-- TABLE 2: ism_stock_tailwinds
-- ×× ×™×•×ª ×¡×¤×¦×™×¤×™×•×ª ×¢× ×¨×•×— ×’×‘×™×ª
-- ============================================
CREATE TABLE IF NOT EXISTS ism_stock_tailwinds (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    report_id TEXT NOT NULL,
    report_month TEXT NOT NULL,
    
    -- Stock identification
    ticker TEXT NOT NULL,
    company_name TEXT,
    sector TEXT,
    market_cap_category TEXT CHECK (market_cap_category IN ('mega', 'large', 'mid', 'small')),
    
    -- Tailwind details
    tailwind_type TEXT NOT NULL,  -- 'ism_driven', 'sector_rotation', 'supply_chain', etc.
    tailwind_strength TEXT DEFAULT 'moderate' CHECK (tailwind_strength IN ('strong', 'moderate', 'mild')),
    
    -- Why this stock benefits
    thesis TEXT NOT NULL,  -- Main investment thesis
    ism_connection TEXT NOT NULL,  -- How ISM data supports this
    specific_catalyst TEXT,  -- Specific ISM component driving this
    
    -- Supporting data
    supporting_quotes TEXT[],  -- Executive quotes mentioning relevant trends
    related_ism_components JSONB,  -- e.g., {"new_orders": 58.3, "production": 54.2}
    
    -- Expected impact
    expected_benefit TEXT,  -- "Revenue acceleration", "Margin expansion", etc.
    timeframe TEXT DEFAULT '1-3 months',
    
    -- Risk/Reward
    key_risks TEXT[],
    price_target_impact TEXT,  -- "Supports $XXX price target"
    
    -- Display
    display_order INTEGER DEFAULT 1,
    is_top_pick BOOLEAN DEFAULT false,
    
    -- Timestamps
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    
    UNIQUE(report_id, ticker)
);

-- Indexes
CREATE INDEX IF NOT EXISTS idx_stock_tailwinds_report ON ism_stock_tailwinds(report_id);
CREATE INDEX IF NOT EXISTS idx_stock_tailwinds_ticker ON ism_stock_tailwinds(ticker);
CREATE INDEX IF NOT EXISTS idx_stock_tailwinds_sector ON ism_stock_tailwinds(sector);
CREATE INDEX IF NOT EXISTS idx_stock_tailwinds_top_pick ON ism_stock_tailwinds(is_top_pick) WHERE is_top_pick = true;

-- ============================================
-- TABLE 3: ism_economic_environment
-- ×”×¡×‘×™×‘×” ×”×›×œ×›×œ×™×ª ×•×”×”×©×œ×›×•×ª
-- ============================================
CREATE TABLE IF NOT EXISTS ism_economic_environment (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    report_id TEXT NOT NULL UNIQUE,
    report_month TEXT NOT NULL,
    
    -- Overall Assessment
    economic_regime TEXT NOT NULL,  -- 'expansion', 'contraction', 'transition', 'stagflation_risk'
    regime_confidence TEXT DEFAULT 'medium',
    cycle_phase TEXT,  -- 'early', 'mid', 'late', 'recession'
    
    -- PMI Headline
    pmi_value DECIMAL(4,1) NOT NULL,
    pmi_trend TEXT CHECK (pmi_trend IN ('accelerating', 'stable', 'decelerating')),
    pmi_vs_expectations TEXT,  -- 'beat', 'miss', 'inline'
    months_in_expansion INTEGER,  -- Consecutive months above 50
    months_in_contraction INTEGER,  -- Consecutive months below 50
    
    -- All ISM Components with implications
    components JSONB NOT NULL,  -- Full component breakdown
    /*
    Example structure:
    {
        "new_orders": {
            "value": 58.3,
            "change": 2.1,
            "trend": "rising",
            "implication": "Strong demand pipeline, bullish for industrials"
        },
        "production": {...},
        "employment": {...},
        "supplier_deliveries": {...},
        "inventories": {...},
        "customers_inventories": {...},
        "prices": {...},
        "backlog": {...},
        "new_export_orders": {...},
        "imports": {...}
    }
    */
    
    -- Key Implications Summary
    growth_outlook TEXT NOT NULL,  -- Overall growth assessment
    inflation_pressure TEXT NOT NULL,  -- 'rising', 'stable', 'falling'
    employment_outlook TEXT NOT NULL,
    supply_chain_status TEXT NOT NULL,  -- 'stressed', 'normalizing', 'healthy'
    
    -- Investment Implications
    equity_outlook TEXT NOT NULL,  -- Overall equity market view
    sector_rotation_signal TEXT,  -- 'risk_on', 'risk_off', 'neutral'
    factor_preference TEXT[],  -- ['growth', 'value', 'quality', etc.]
    
    -- Fixed Income Implications
    rate_expectations TEXT,  -- 'higher', 'lower', 'stable'
    yield_curve_impact TEXT,
    credit_outlook TEXT,
    
    -- Key Risks
    primary_risks TEXT[] NOT NULL,
    tail_risks TEXT[],
    
    -- Forward Guidance
    next_month_expectations TEXT,
    key_indicators_to_watch TEXT[],
    
    -- Executive Commentary Summary
    sentiment_score INTEGER CHECK (sentiment_score BETWEEN -100 AND 100),  -- -100 to +100
    notable_quotes JSONB,  -- Key quotes by theme
    industry_divergence TEXT,  -- Which industries diverging from headline
    
    -- Timestamps
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Indexes
CREATE INDEX IF NOT EXISTS idx_econ_env_month ON ism_economic_environment(report_month);
CREATE INDEX IF NOT EXISTS idx_econ_env_regime ON ism_economic_environment(economic_regime);

-- ============================================
-- RLS POLICIES
-- ============================================
ALTER TABLE ism_sector_outlook ENABLE ROW LEVEL SECURITY;
ALTER TABLE ism_stock_tailwinds ENABLE ROW LEVEL SECURITY;
ALTER TABLE ism_economic_environment ENABLE ROW LEVEL SECURITY;

-- Drop existing policies
DROP POLICY IF EXISTS "Read ism_sector_outlook" ON ism_sector_outlook;
DROP POLICY IF EXISTS "Service manage ism_sector_outlook" ON ism_sector_outlook;
DROP POLICY IF EXISTS "Read ism_stock_tailwinds" ON ism_stock_tailwinds;
DROP POLICY IF EXISTS "Service manage ism_stock_tailwinds" ON ism_stock_tailwinds;
DROP POLICY IF EXISTS "Read ism_economic_environment" ON ism_economic_environment;
DROP POLICY IF EXISTS "Service manage ism_economic_environment" ON ism_economic_environment;

-- Sector Outlook policies
CREATE POLICY "Read ism_sector_outlook" ON ism_sector_outlook
    FOR SELECT TO authenticated USING (true);
CREATE POLICY "Service manage ism_sector_outlook" ON ism_sector_outlook
    FOR ALL TO service_role USING (true) WITH CHECK (true);

-- Stock Tailwinds policies
CREATE POLICY "Read ism_stock_tailwinds" ON ism_stock_tailwinds
    FOR SELECT TO authenticated USING (true);
CREATE POLICY "Service manage ism_stock_tailwinds" ON ism_stock_tailwinds
    FOR ALL TO service_role USING (true) WITH CHECK (true);

-- Economic Environment policies
CREATE POLICY "Read ism_economic_environment" ON ism_economic_environment
    FOR SELECT TO authenticated USING (true);
CREATE POLICY "Service manage ism_economic_environment" ON ism_economic_environment
    FOR ALL TO service_role USING (true) WITH CHECK (true);

-- ============================================
-- GRANTS
-- ============================================
GRANT SELECT ON ism_sector_outlook TO authenticated;
GRANT SELECT ON ism_stock_tailwinds TO authenticated;
GRANT SELECT ON ism_economic_environment TO authenticated;

GRANT ALL ON ism_sector_outlook TO service_role;
GRANT ALL ON ism_stock_tailwinds TO service_role;
GRANT ALL ON ism_economic_environment TO service_role;

-- ============================================
-- VIEWS FOR EASY ACCESS
-- ============================================

-- Latest sector outlook
CREATE OR REPLACE VIEW v_ism_sector_outlook_latest AS
SELECT 
    sector_name,
    sector_etf,
    direction,
    conviction,
    expected_move_percent,
    primary_driver,
    key_risks,
    report_month
FROM ism_sector_outlook
WHERE report_month = (SELECT MAX(report_month) FROM ism_sector_outlook)
ORDER BY 
    CASE direction WHEN 'bullish' THEN 1 WHEN 'neutral' THEN 2 ELSE 3 END,
    CASE conviction WHEN 'high' THEN 1 WHEN 'medium' THEN 2 ELSE 3 END;

-- Latest stock tailwinds
CREATE OR REPLACE VIEW v_ism_stock_tailwinds_latest AS
SELECT 
    ticker,
    company_name,
    sector,
    tailwind_strength,
    thesis,
    ism_connection,
    is_top_pick,
    report_month
FROM ism_stock_tailwinds
WHERE report_month = (SELECT MAX(report_month) FROM ism_stock_tailwinds)
ORDER BY is_top_pick DESC, 
    CASE tailwind_strength WHEN 'strong' THEN 1 WHEN 'moderate' THEN 2 ELSE 3 END;

-- Latest economic environment
CREATE OR REPLACE VIEW v_ism_economic_environment_latest AS
SELECT 
    economic_regime,
    pmi_value,
    pmi_trend,
    growth_outlook,
    inflation_pressure,
    equity_outlook,
    sector_rotation_signal,
    primary_risks,
    report_month
FROM ism_economic_environment
WHERE report_month = (SELECT MAX(report_month) FROM ism_economic_environment);

-- Grant access to views
GRANT SELECT ON v_ism_sector_outlook_latest TO authenticated;
GRANT SELECT ON v_ism_stock_tailwinds_latest TO authenticated;
GRANT SELECT ON v_ism_economic_environment_latest TO authenticated;

-- ============================================
-- HELPER FUNCTION: Get full ISM insights
-- ============================================
CREATE OR REPLACE FUNCTION get_ism_insights(p_report_month TEXT DEFAULT NULL)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    v_month TEXT;
    v_result JSONB;
BEGIN
    -- Use latest month if not specified
    v_month := COALESCE(p_report_month, (SELECT MAX(report_month) FROM ism_economic_environment));
    
    SELECT jsonb_build_object(
        'report_month', v_month,
        'economic_environment', (
            SELECT row_to_json(e.*)
            FROM ism_economic_environment e
            WHERE e.report_month = v_month
        ),
        'sector_outlook', (
            SELECT jsonb_agg(row_to_json(s.*) ORDER BY s.display_order)
            FROM ism_sector_outlook s
            WHERE s.report_month = v_month
        ),
        'stock_tailwinds', (
            SELECT jsonb_agg(row_to_json(t.*) ORDER BY t.is_top_pick DESC, t.display_order)
            FROM ism_stock_tailwinds t
            WHERE t.report_month = v_month
        )
    ) INTO v_result;
    
    RETURN v_result;
END;
$$;

GRANT EXECUTE ON FUNCTION get_ism_insights(TEXT) TO authenticated;
GRANT EXECUTE ON FUNCTION get_ism_insights(TEXT) TO service_role;

-- ============================================
-- VERIFICATION
-- ============================================
DO $$
BEGIN
    RAISE NOTICE '';
    RAISE NOTICE '=====================================================';
    RAISE NOTICE 'âœ… PART 3.11: ISM INSIGHTS TABLES COMPLETE';
    RAISE NOTICE '=====================================================';
    RAISE NOTICE '';
    RAISE NOTICE 'New tables created:';
    RAISE NOTICE '  1. ism_sector_outlook - ×¡×§×˜×•×¨×™× ×¦×¤×•×™×™× ×œ×¢×œ×•×ª/×œ×¨×“×ª';
    RAISE NOTICE '  2. ism_stock_tailwinds - ×× ×™×•×ª ×¢× ×¨×•×— ×’×‘×™×ª';
    RAISE NOTICE '  3. ism_economic_environment - ×¡×‘×™×‘×” ×›×œ×›×œ×™×ª ×•×”×©×œ×›×•×ª';
    RAISE NOTICE '';
    RAISE NOTICE 'Views created:';
    RAISE NOTICE '  â€¢ v_ism_sector_outlook_latest';
    RAISE NOTICE '  â€¢ v_ism_stock_tailwinds_latest';
    RAISE NOTICE '  â€¢ v_ism_economic_environment_latest';
    RAISE NOTICE '';
    RAISE NOTICE 'Function created:';
    RAISE NOTICE '  â€¢ get_ism_insights(report_month) - Returns all insights as JSON';
    RAISE NOTICE '=====================================================';
END $$;

-- =====================================================
-- END OF PART 3.11
-- =====================================================

-- =====================================================
-- PART 3.12: ISM ECONOMIC SNAPSHOTS TABLE
-- =====================================================
-- Required by orchestrator.js saveEconomicSnapshot()
-- =====================================================

CREATE TABLE IF NOT EXISTS ism_economic_snapshots (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  report_id TEXT NOT NULL,
  report_month TEXT NOT NULL UNIQUE,
  
  -- Core ISM Indices
  pmi DECIMAL(4,1),
  pmi_prior DECIMAL(4,1),
  pmi_change DECIMAL(4,1),
  pmi_direction TEXT,
  
  new_orders DECIMAL(4,1),
  new_orders_prior DECIMAL(4,1),
  new_orders_change DECIMAL(4,1),
  
  production DECIMAL(4,1),
  production_prior DECIMAL(4,1),
  production_change DECIMAL(4,1),
  
  employment DECIMAL(4,1),
  employment_prior DECIMAL(4,1),
  employment_change DECIMAL(4,1),
  
  supplier_deliveries DECIMAL(4,1),
  supplier_deliveries_prior DECIMAL(4,1),
  
  inventories DECIMAL(4,1),
  inventories_prior DECIMAL(4,1),
  
  prices DECIMAL(4,1),
  prices_prior DECIMAL(4,1),
  prices_change DECIMAL(4,1),
  prices_pressure TEXT,
  
  backlog DECIMAL(4,1),
  backlog_prior DECIMAL(4,1),
  
  new_export_orders DECIMAL(4,1),
  imports DECIMAL(4,1),
  
  -- Regime Analysis
  macro_regime TEXT,
  regime_confidence TEXT,
  consecutive_months INTEGER,
  
  -- Derived Signals
  inventory_cycle_signal TEXT,
  demand_signal TEXT,
  pricing_power_signal TEXT,
  labor_market_signal TEXT,
  supply_chain_signal TEXT,
  
  -- Metadata
  data_source TEXT DEFAULT 'Perplexity',
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Index
CREATE INDEX IF NOT EXISTS idx_econ_snapshots_month ON ism_economic_snapshots(report_month);
CREATE INDEX IF NOT EXISTS idx_econ_snapshots_report ON ism_economic_snapshots(report_id);

-- RLS
ALTER TABLE ism_economic_snapshots ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Read ism_economic_snapshots" ON ism_economic_snapshots;
DROP POLICY IF EXISTS "Service manage ism_economic_snapshots" ON ism_economic_snapshots;

CREATE POLICY "Read ism_economic_snapshots" ON ism_economic_snapshots
  FOR SELECT TO authenticated USING (true);
  
CREATE POLICY "Service manage ism_economic_snapshots" ON ism_economic_snapshots
  FOR ALL TO service_role USING (true) WITH CHECK (true);

-- Grants
GRANT SELECT ON ism_economic_snapshots TO authenticated;
GRANT ALL ON ism_economic_snapshots TO service_role;

-- Verification
DO $$
BEGIN
  RAISE NOTICE 'âœ… PART 3.12: ism_economic_snapshots table created';
END $$;
-- =====================================================
-- COMPANY NOTIFICATION SYSTEM - COMPLETE SCHEMA
-- =====================================================

-- 1. CREATE update_center_notifications (main notifications table)
CREATE TABLE IF NOT EXISTS update_center_notifications (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  
  -- Type and category
  type TEXT NOT NULL DEFAULT 'company_report',
  category TEXT NOT NULL DEFAULT 'company_report',
  priority TEXT DEFAULT 'normal' CHECK (priority IN ('high', 'normal', 'low')),
  
  -- Content
  title TEXT NOT NULL,
  subtitle TEXT,
  description TEXT,
  
  -- Report reference
  report_id TEXT,
  ticker VARCHAR(10),
  company_name TEXT,
  sector TEXT,
  
  -- Quality indicators
  confidence_level TEXT,
  qa_score INTEGER,
  
  -- Admin tracking
  is_admin_generated BOOLEAN DEFAULT false,
  
  -- Targeting
  target_group TEXT DEFAULT 'all',
  
  -- Status
  is_read BOOLEAN DEFAULT false,
  is_dismissed BOOLEAN DEFAULT false,
  
  -- Timestamps
  published_at TIMESTAMPTZ DEFAULT NOW(),
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  
  -- Metadata
  metadata JSONB DEFAULT '{}'
);

-- ADD COLUMNS IF TABLE ALREADY EXISTS
ALTER TABLE update_center_notifications 
ADD COLUMN IF NOT EXISTS category TEXT DEFAULT 'company_report',
ADD COLUMN IF NOT EXISTS priority TEXT DEFAULT 'normal',
ADD COLUMN IF NOT EXISTS subtitle TEXT,
ADD COLUMN IF NOT EXISTS description TEXT,
ADD COLUMN IF NOT EXISTS company_name TEXT,
ADD COLUMN IF NOT EXISTS sector TEXT,
ADD COLUMN IF NOT EXISTS confidence_level TEXT,
ADD COLUMN IF NOT EXISTS qa_score INTEGER,
ADD COLUMN IF NOT EXISTS is_admin_generated BOOLEAN DEFAULT false,
ADD COLUMN IF NOT EXISTS published_at TIMESTAMPTZ DEFAULT NOW(),
ADD COLUMN IF NOT EXISTS target_group TEXT DEFAULT 'all';

-- Indexes
CREATE INDEX IF NOT EXISTS idx_ucn_type ON update_center_notifications(type);
CREATE INDEX IF NOT EXISTS idx_ucn_category ON update_center_notifications(category);
CREATE INDEX IF NOT EXISTS idx_ucn_ticker ON update_center_notifications(ticker);
CREATE INDEX IF NOT EXISTS idx_ucn_report_id ON update_center_notifications(report_id);
CREATE INDEX IF NOT EXISTS idx_ucn_published_at ON update_center_notifications(published_at DESC);

-- ADD COLUMNS IF TABLE ALREADY EXISTS
ALTER TABLE update_center_notifications 
ADD COLUMN IF NOT EXISTS category TEXT DEFAULT 'company_report',
ADD COLUMN IF NOT EXISTS priority TEXT DEFAULT 'normal',
ADD COLUMN IF NOT EXISTS subtitle TEXT,
ADD COLUMN IF NOT EXISTS description TEXT,
ADD COLUMN IF NOT EXISTS company_name TEXT,
ADD COLUMN IF NOT EXISTS sector TEXT,
ADD COLUMN IF NOT EXISTS confidence_level TEXT,
ADD COLUMN IF NOT EXISTS qa_score INTEGER,
ADD COLUMN IF NOT EXISTS is_admin_generated BOOLEAN DEFAULT false,
ADD COLUMN IF NOT EXISTS published_at TIMESTAMPTZ DEFAULT NOW(),
ADD COLUMN IF NOT EXISTS target_group TEXT DEFAULT 'all';


-- 3. CREATE user_notifications (per-user notification entries)
CREATE TABLE IF NOT EXISTS user_notifications (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  
  -- References
  notification_id UUID NOT NULL REFERENCES update_center_notifications(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  
  -- For direct report access (optional)
  report_id TEXT,
  
  -- User subscription tier
  subscription_tier TEXT DEFAULT 'FREE',
  
  -- Status
  is_read BOOLEAN DEFAULT false,
  is_dismissed BOOLEAN DEFAULT false,
  
  -- Access control
  accessible_sections TEXT, -- 'all' or JSON array of section names
  
  -- Admin message (for admin-sent notifications)
  admin_message TEXT,
  
  -- Timestamps
  created_at TIMESTAMPTZ DEFAULT NOW(),
  read_at TIMESTAMPTZ,
  
  -- Unique constraint
  UNIQUE(notification_id, user_id)
);

-- Indexes
CREATE INDEX IF NOT EXISTS idx_un_user_id ON user_notifications(user_id);
CREATE INDEX IF NOT EXISTS idx_un_notification_id ON user_notifications(notification_id);
CREATE INDEX IF NOT EXISTS idx_un_is_read ON user_notifications(is_read);
CREATE INDEX IF NOT EXISTS idx_un_created_at ON user_notifications(created_at DESC);

-- 4. CREATE user_subscriptions table (if not exists)
CREATE TABLE IF NOT EXISTS user_subscriptions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  subscription_tier TEXT DEFAULT 'FREE' CHECK (subscription_tier IN ('FREE', 'BASIC', 'PREMIUM')),
  is_active BOOLEAN DEFAULT true,
  preferences JSONB DEFAULT '{}',
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  UNIQUE(user_id)
);

-- 5. RLS POLICIES

-- RLS
ALTER TABLE update_center_notifications ENABLE ROW LEVEL SECURITY;

-- Drop existing policies first (prevent duplicates)
DROP POLICY IF EXISTS "service_manage_notifications" ON update_center_notifications;
DROP POLICY IF EXISTS "users_see_notifications" ON update_center_notifications;
DROP POLICY IF EXISTS "service_ucn_all" ON update_center_notifications;
DROP POLICY IF EXISTS "authenticated_ucn_read" ON update_center_notifications;

-- Service role full access
CREATE POLICY "service_ucn_all" ON update_center_notifications
  FOR ALL TO service_role
  USING (true) WITH CHECK (true);

-- Users can read notifications
CREATE POLICY "authenticated_ucn_read" ON update_center_notifications
  FOR SELECT TO authenticated
  USING (true);

-- Grants
GRANT ALL ON update_center_notifications TO service_role;
GRANT SELECT ON update_center_notifications TO authenticated;

-- Verification
DO $$
BEGIN
  RAISE NOTICE 'âœ… published_reports columns added';
  RAISE NOTICE 'âœ… update_center_notifications table created';
END $$;


-- FUNCTION: check_ism_report_status
CREATE OR REPLACE FUNCTION check_ism_report_status(p_month TEXT)
RETURNS TABLE (
  report_month TEXT,
  status TEXT,
  can_generate BOOLEAN,
  reason TEXT,
  existing_report_id TEXT,
  ism_available BOOLEAN,
  last_check TIMESTAMPTZ
) AS $$
BEGIN
  RETURN QUERY
  SELECT 
    COALESCE(t.report_month, p_month),
    COALESCE(t.status, 'pending_ism'),
    CASE 
      WHEN t.status = 'report_generated' AND NOT COALESCE(t.is_admin_override, false) THEN false
      WHEN t.status = 'generating' THEN false
      ELSE true
    END,
    CASE 
      WHEN t.status = 'report_generated' THEN 'Report already exists for this month'
      WHEN t.status = 'generating' THEN 'Generation in progress'
      ELSE 'Ready to generate'
    END,
    t.report_id,
    COALESCE(t.ism_data_available, false),
    t.last_ism_check
  FROM ism_report_tracking t
  WHERE t.report_month = p_month
  
  UNION ALL
  
  SELECT 
    p_month,
    'pending_ism',
    true,
    'No tracking record - ready to generate',
    NULL,
    false,
    NULL
  WHERE NOT EXISTS (SELECT 1 FROM ism_report_tracking WHERE ism_report_tracking.report_month = p_month);
END;
$$ LANGUAGE plpgsql;

-- FUNCTION: init_ism_tracking
CREATE OR REPLACE FUNCTION init_ism_tracking(
  p_month TEXT,
  p_ism_available BOOLEAN DEFAULT false,
  p_ism_release_date TIMESTAMPTZ DEFAULT NULL
)
RETURNS void AS $$
BEGIN
  INSERT INTO ism_report_tracking (report_month, ism_data_available, ism_release_date, last_ism_check, status)
  VALUES (
    p_month,
    p_ism_available,
    p_ism_release_date,
    NOW(),
    CASE WHEN p_ism_available THEN 'ism_available' ELSE 'pending_ism' END
  )
  ON CONFLICT (report_month) DO UPDATE SET
    ism_data_available = EXCLUDED.ism_data_available,
    ism_release_date = COALESCE(EXCLUDED.ism_release_date, ism_report_tracking.ism_release_date),
    last_ism_check = NOW(),
    status = CASE 
      WHEN ism_report_tracking.status = 'report_generated' THEN ism_report_tracking.status
      WHEN EXCLUDED.ism_data_available THEN 'ism_available'
      ELSE ism_report_tracking.status
    END,
    updated_at = NOW();
END;
$$ LANGUAGE plpgsql;

-- FUNCTION: start_ism_generation
CREATE OR REPLACE FUNCTION start_ism_generation(
  p_month TEXT,
  p_admin_id TEXT DEFAULT NULL,
  p_is_override BOOLEAN DEFAULT false,
  p_override_reason TEXT DEFAULT NULL
)
RETURNS BOOLEAN AS $$
DECLARE
  v_current_status TEXT;
BEGIN
  SELECT status INTO v_current_status
  FROM ism_report_tracking
  WHERE report_month = p_month;
  
  IF v_current_status = 'generating' THEN
    RETURN false;
  END IF;
  
  IF v_current_status = 'report_generated' AND NOT p_is_override THEN
    RETURN false;
  END IF;
  
  INSERT INTO ism_report_tracking (
    report_month, 
    status, 
    generation_started_at,
    is_admin_override,
    admin_id,
    override_reason,
    ism_data_available
  )
  VALUES (
    p_month,
    'generating',
    NOW(),
    p_is_override,
    p_admin_id,
    p_override_reason,
    true
  )
  ON CONFLICT (report_month) DO UPDATE SET
    status = 'generating',
    generation_started_at = NOW(),
    is_admin_override = COALESCE(p_is_override, ism_report_tracking.is_admin_override),
    admin_id = COALESCE(p_admin_id, ism_report_tracking.admin_id),
    override_reason = COALESCE(p_override_reason, ism_report_tracking.override_reason),
    error_message = NULL,
    updated_at = NOW();
  
  RETURN true;
END;
$$ LANGUAGE plpgsql;

-- FUNCTION: complete_ism_generation
CREATE OR REPLACE FUNCTION complete_ism_generation(
  p_month TEXT,
  p_report_id TEXT DEFAULT NULL,
  p_success BOOLEAN DEFAULT true,
  p_error_message TEXT DEFAULT NULL
)
RETURNS void AS $$
BEGIN
  UPDATE ism_report_tracking SET
    status = CASE WHEN p_success THEN 'report_generated' ELSE 'error' END,
    report_id = COALESCE(p_report_id, report_id),
    latest_report_id = COALESCE(p_report_id, latest_report_id),
    generation_completed_at = NOW(),
    report_generated_at = CASE WHEN p_success THEN NOW() ELSE NULL END,
    error_message = p_error_message,
    error_count = CASE WHEN p_success THEN 0 ELSE error_count + 1 END,
    updated_at = NOW()
  WHERE report_month = p_month;
END;
$$ LANGUAGE plpgsql;

-- FUNCTION: get_ism_reports_history
CREATE OR REPLACE FUNCTION get_ism_reports_history(p_limit INTEGER DEFAULT 12)
RETURNS TABLE (
  id TEXT,
  report_month TEXT,
  report_title TEXT,
  created_at TIMESTAMPTZ,
  qa_score INTEGER,
  is_admin_override BOOLEAN,
  executive_summary JSONB
) AS $$
BEGIN
  RETURN QUERY
  SELECT 
    r.id,
    r.report_month,
    r.report_title,
    r.created_at,
    r.qa_score,
    r.is_admin_override,
    r.executive_summary
  FROM ism_reports r
  ORDER BY r.report_month DESC
  LIMIT p_limit;
END;
$$ LANGUAGE plpgsql;

-- FUNCTION: admin_force_ism_regenerate
CREATE OR REPLACE FUNCTION admin_force_ism_regenerate(
  p_month TEXT,
  p_admin_id TEXT,
  p_reason TEXT
)
RETURNS BOOLEAN AS $$
BEGIN
  IF p_reason IS NULL OR LENGTH(p_reason) < 5 THEN
    RAISE EXCEPTION 'Override reason must be at least 5 characters';
  END IF;
  
  INSERT INTO ism_report_tracking (
    report_month,
    status,
    ism_data_available,
    is_admin_override,
    admin_id,
    override_reason
  ) VALUES (
    p_month,
    'ism_available',
    true,
    true,
    p_admin_id,
    p_reason
  )
  ON CONFLICT (report_month) DO UPDATE SET
    status = 'ism_available',
    is_admin_override = true,
    admin_id = EXCLUDED.admin_id,
    override_reason = EXCLUDED.override_reason,
    updated_at = NOW();
  
  RETURN true;
END;
$$ LANGUAGE plpgsql;

-- FUNCTION: cleanup_ism_month
-- Deletes ALL data for a specific month
-- Usage: SELECT cleanup_ism_month('2025-11');
CREATE OR REPLACE FUNCTION cleanup_ism_month(p_month TEXT)
RETURNS TEXT AS $$
BEGIN
  DELETE FROM ism_reports WHERE report_month = p_month;
  DELETE FROM ism_report_tracking WHERE report_month = p_month;
  DELETE FROM ism_source_cache WHERE data_month = p_month;
  DELETE FROM ism_historical_cache WHERE current_month = p_month;
  DELETE FROM ism_sector_analysis WHERE report_month = p_month;
  DELETE FROM ism_ticker_selections WHERE report_month = p_month;
  DELETE FROM ism_agent_logs WHERE report_month = p_month;
  RETURN 'Cleanup complete for ' || p_month;
END;
$$ LANGUAGE plpgsql;

-- =====================================================
-- PART 5: ROW LEVEL SECURITY (RLS)
-- =====================================================

-- ============================================
-- RLS for ism_reports
-- ============================================
ALTER TABLE ism_reports ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS ism_reports_service_all ON ism_reports;
DROP POLICY IF EXISTS ism_reports_authenticated_read ON ism_reports;
DROP POLICY IF EXISTS ism_reports_authenticated_write ON ism_reports;
DROP POLICY IF EXISTS ism_reports_authenticated_update ON ism_reports;
DROP POLICY IF EXISTS ism_reports_authenticated_delete ON ism_reports;

CREATE POLICY ism_reports_service_all ON ism_reports
  FOR ALL TO service_role
  USING (true) WITH CHECK (true);

CREATE POLICY ism_reports_authenticated_read ON ism_reports
  FOR SELECT TO authenticated
  USING (true);

CREATE POLICY ism_reports_authenticated_write ON ism_reports
  FOR INSERT TO authenticated
  WITH CHECK (true);

CREATE POLICY ism_reports_authenticated_update ON ism_reports
  FOR UPDATE TO authenticated
  USING (true) WITH CHECK (true);

CREATE POLICY ism_reports_authenticated_delete ON ism_reports
  FOR DELETE TO authenticated
  USING (true);

-- ============================================
-- RLS for ism_report_tracking
-- ============================================
ALTER TABLE ism_report_tracking ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS ism_report_tracking_service_all ON ism_report_tracking;
DROP POLICY IF EXISTS ism_report_tracking_authenticated_all ON ism_report_tracking;

CREATE POLICY ism_report_tracking_service_all ON ism_report_tracking
  FOR ALL TO service_role
  USING (true) WITH CHECK (true);

CREATE POLICY ism_report_tracking_authenticated_all ON ism_report_tracking
  FOR ALL TO authenticated
  USING (true) WITH CHECK (true);

-- ============================================
-- RLS for ism_agent_logs
-- ============================================
ALTER TABLE ism_agent_logs ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS ism_agent_logs_service_all ON ism_agent_logs;
DROP POLICY IF EXISTS ism_agent_logs_authenticated_read ON ism_agent_logs;
DROP POLICY IF EXISTS ism_agent_logs_authenticated_write ON ism_agent_logs;

CREATE POLICY ism_agent_logs_service_all ON ism_agent_logs
  FOR ALL TO service_role
  USING (true) WITH CHECK (true);

CREATE POLICY ism_agent_logs_authenticated_read ON ism_agent_logs
  FOR SELECT TO authenticated
  USING (true);

CREATE POLICY ism_agent_logs_authenticated_write ON ism_agent_logs
  FOR INSERT TO authenticated
  WITH CHECK (true);

-- ============================================
-- RLS for ism_source_cache
-- ============================================
ALTER TABLE ism_source_cache ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS ism_source_cache_service_all ON ism_source_cache;
DROP POLICY IF EXISTS ism_source_cache_authenticated_all ON ism_source_cache;

CREATE POLICY ism_source_cache_service_all ON ism_source_cache
  FOR ALL TO service_role
  USING (true) WITH CHECK (true);

CREATE POLICY ism_source_cache_authenticated_all ON ism_source_cache
  FOR ALL TO authenticated
  USING (true) WITH CHECK (true);

-- ============================================
-- RLS for ism_report_progress
-- ============================================
ALTER TABLE ism_report_progress ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS ism_report_progress_service_all ON ism_report_progress;
DROP POLICY IF EXISTS ism_report_progress_authenticated_all ON ism_report_progress;

CREATE POLICY ism_report_progress_service_all ON ism_report_progress
  FOR ALL TO service_role
  USING (true) WITH CHECK (true);

CREATE POLICY ism_report_progress_authenticated_all ON ism_report_progress
  FOR ALL TO authenticated
  USING (true) WITH CHECK (true);

-- ============================================
-- RLS for company_reports
-- ============================================
ALTER TABLE company_reports ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS company_reports_service_all ON company_reports;
DROP POLICY IF EXISTS company_reports_authenticated_read ON company_reports;
DROP POLICY IF EXISTS company_reports_authenticated_write ON company_reports;
DROP POLICY IF EXISTS company_reports_authenticated_update ON company_reports;
DROP POLICY IF EXISTS company_reports_authenticated_delete ON company_reports;
DROP POLICY IF EXISTS company_reports_anon_read ON company_reports;

CREATE POLICY company_reports_service_all ON company_reports
  FOR ALL TO service_role
  USING (true) WITH CHECK (true);

CREATE POLICY company_reports_authenticated_read ON company_reports
  FOR SELECT TO authenticated
  USING (true);

CREATE POLICY company_reports_authenticated_write ON company_reports
  FOR INSERT TO authenticated
  WITH CHECK (true);

CREATE POLICY company_reports_authenticated_update ON company_reports
  FOR UPDATE TO authenticated
  USING (true) WITH CHECK (true);

CREATE POLICY company_reports_authenticated_delete ON company_reports
  FOR DELETE TO authenticated
  USING (true);

CREATE POLICY company_reports_anon_read ON company_reports
  FOR SELECT TO anon
  USING (true);

-- ============================================
-- RLS for company_agent_logs
-- ============================================
ALTER TABLE company_agent_logs ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS company_agent_logs_service_all ON company_agent_logs;
DROP POLICY IF EXISTS company_agent_logs_authenticated_read ON company_agent_logs;
DROP POLICY IF EXISTS company_agent_logs_authenticated_write ON company_agent_logs;

CREATE POLICY company_agent_logs_service_all ON company_agent_logs
  FOR ALL TO service_role
  USING (true) WITH CHECK (true);

CREATE POLICY company_agent_logs_authenticated_read ON company_agent_logs
  FOR SELECT TO authenticated
  USING (true);

CREATE POLICY company_agent_logs_authenticated_write ON company_agent_logs
  FOR INSERT TO authenticated
  WITH CHECK (true);

-- ============================================
-- RLS for crypto_reports
-- ============================================
ALTER TABLE crypto_reports ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS crypto_reports_admin_all ON crypto_reports;
DROP POLICY IF EXISTS crypto_reports_service_all ON crypto_reports;
DROP POLICY IF EXISTS crypto_reports_authenticated_read ON crypto_reports;
DROP POLICY IF EXISTS crypto_reports_authenticated_write ON crypto_reports;
DROP POLICY IF EXISTS crypto_reports_authenticated_update ON crypto_reports;
DROP POLICY IF EXISTS crypto_reports_authenticated_delete ON crypto_reports;
DROP POLICY IF EXISTS crypto_reports_anon_read ON crypto_reports;

CREATE POLICY crypto_reports_service_all ON crypto_reports
  FOR ALL TO service_role
  USING (true) WITH CHECK (true);

CREATE POLICY crypto_reports_authenticated_read ON crypto_reports
  FOR SELECT TO authenticated
  USING (true);

CREATE POLICY crypto_reports_authenticated_write ON crypto_reports
  FOR INSERT TO authenticated
  WITH CHECK (true);

CREATE POLICY crypto_reports_authenticated_update ON crypto_reports
  FOR UPDATE TO authenticated
  USING (true) WITH CHECK (true);

CREATE POLICY crypto_reports_authenticated_delete ON crypto_reports
  FOR DELETE TO authenticated
  USING (true);

CREATE POLICY crypto_reports_anon_read ON crypto_reports
  FOR SELECT TO anon
  USING (true);

-- ============================================
-- RLS for crypto_report_progress
-- ============================================
ALTER TABLE crypto_report_progress ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS crypto_progress_service_all ON crypto_report_progress;
DROP POLICY IF EXISTS crypto_progress_authenticated_all ON crypto_report_progress;

CREATE POLICY crypto_progress_service_all ON crypto_report_progress
  FOR ALL TO service_role
  USING (true) WITH CHECK (true);

CREATE POLICY crypto_progress_authenticated_all ON crypto_report_progress
  FOR ALL TO authenticated
  USING (true) WITH CHECK (true);

-- ============================================
-- RLS for crypto_agent_logs
-- ============================================
ALTER TABLE crypto_agent_logs ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS crypto_agent_logs_service_all ON crypto_agent_logs;
DROP POLICY IF EXISTS crypto_agent_logs_authenticated_read ON crypto_agent_logs;
DROP POLICY IF EXISTS crypto_agent_logs_authenticated_write ON crypto_agent_logs;

CREATE POLICY crypto_agent_logs_service_all ON crypto_agent_logs
  FOR ALL TO service_role
  USING (true) WITH CHECK (true);

CREATE POLICY crypto_agent_logs_authenticated_read ON crypto_agent_logs
  FOR SELECT TO authenticated
  USING (true);

CREATE POLICY crypto_agent_logs_authenticated_write ON crypto_agent_logs
  FOR INSERT TO authenticated
  WITH CHECK (true);

-- =====================================================
-- PART 6: CLEANUP - Remove test tables
-- =====================================================
DROP TABLE IF EXISTS v_test_user;

-- =====================================================
-- PART 7: GRANTS
-- =====================================================

-- ISM Tables
GRANT SELECT, INSERT, UPDATE, DELETE ON ism_reports TO authenticated;
GRANT SELECT, INSERT, UPDATE, DELETE ON ism_report_tracking TO authenticated;
GRANT SELECT, INSERT, DELETE ON ism_agent_logs TO authenticated;
GRANT SELECT, INSERT, UPDATE, DELETE ON ism_source_cache TO authenticated;
GRANT SELECT, INSERT, UPDATE, DELETE ON ism_report_progress TO authenticated;

GRANT ALL ON ism_reports TO service_role;
GRANT ALL ON ism_report_tracking TO service_role;
GRANT ALL ON ism_agent_logs TO service_role;
GRANT ALL ON ism_source_cache TO service_role;
GRANT ALL ON ism_report_progress TO service_role;

-- Company Tables
GRANT SELECT, INSERT, UPDATE, DELETE ON company_reports TO authenticated;
GRANT SELECT, INSERT, DELETE ON company_agent_logs TO authenticated;
GRANT SELECT ON company_reports TO anon;

GRANT ALL ON company_reports TO service_role;
GRANT ALL ON company_agent_logs TO service_role;

-- Crypto Tables
GRANT ALL ON crypto_reports TO authenticated;
GRANT ALL ON crypto_reports TO service_role;
GRANT SELECT ON crypto_reports TO anon;

GRANT ALL ON crypto_report_progress TO authenticated;
GRANT ALL ON crypto_report_progress TO service_role;

GRANT ALL ON crypto_agent_logs TO authenticated;
GRANT ALL ON crypto_agent_logs TO service_role;

-- ISM Functions
GRANT EXECUTE ON FUNCTION check_ism_report_status TO authenticated;
GRANT EXECUTE ON FUNCTION init_ism_tracking TO authenticated;
GRANT EXECUTE ON FUNCTION start_ism_generation TO authenticated;
GRANT EXECUTE ON FUNCTION complete_ism_generation TO authenticated;
GRANT EXECUTE ON FUNCTION get_ism_reports_history TO authenticated;
GRANT EXECUTE ON FUNCTION admin_force_ism_regenerate TO authenticated;

GRANT EXECUTE ON FUNCTION check_ism_report_status TO service_role;
GRANT EXECUTE ON FUNCTION init_ism_tracking TO service_role;
GRANT EXECUTE ON FUNCTION start_ism_generation TO service_role;
GRANT EXECUTE ON FUNCTION complete_ism_generation TO service_role;
GRANT EXECUTE ON FUNCTION get_ism_reports_history TO service_role;
GRANT EXECUTE ON FUNCTION admin_force_ism_regenerate TO service_role;

GRANT EXECUTE ON FUNCTION cleanup_ism_month TO authenticated;
GRANT EXECUTE ON FUNCTION cleanup_ism_month TO service_role;

-- =====================================================
-- VERIFICATION
-- =====================================================
DO $$
DECLARE
  table_count INTEGER;
  rls_enabled_count INTEGER;
BEGIN
  -- Count tables
  SELECT COUNT(*) INTO table_count
  FROM information_schema.tables
  WHERE table_schema = 'public'
  AND table_name IN (
    'ism_reports', 'ism_report_tracking', 'ism_agent_logs', 'ism_source_cache', 'ism_report_progress',
    'company_reports', 'company_agent_logs',
    'crypto_reports', 'crypto_report_progress', 'crypto_agent_logs'
  );
  
  -- Count RLS enabled tables
  SELECT COUNT(*) INTO rls_enabled_count
  FROM pg_tables t
  JOIN pg_class c ON c.relname = t.tablename
  WHERE t.schemaname = 'public'
  AND t.tablename IN (
    'ism_reports', 'ism_report_tracking', 'ism_agent_logs', 'ism_source_cache', 'ism_report_progress',
    'company_reports', 'company_agent_logs',
    'crypto_reports', 'crypto_report_progress', 'crypto_agent_logs'
  )
  AND c.relrowsecurity = true;
  
  RAISE NOTICE '';
  RAISE NOTICE '=====================================================';
  RAISE NOTICE 'âœ… FINOTAUR DATABASE SCHEMA CREATED SUCCESSFULLY!';
  RAISE NOTICE '=====================================================';
  RAISE NOTICE 'Tables created: %', table_count;
  RAISE NOTICE 'Tables with RLS enabled: %', rls_enabled_count;
  RAISE NOTICE '';
  RAISE NOTICE 'ISM Reports: ism_reports, ism_report_tracking, ism_agent_logs, ism_source_cache, ism_report_progress';
  RAISE NOTICE 'Company Analysis: company_reports, company_agent_logs';
  RAISE NOTICE 'Crypto Analysis: crypto_reports, crypto_report_progress, crypto_agent_logs';
  RAISE NOTICE '';
  RAISE NOTICE 'âœ… All RLS policies configured correctly';
  RAISE NOTICE 'âœ… All grants applied';
  RAISE NOTICE 'âœ… v_test_user table removed';
  RAISE NOTICE '=====================================================';
END $$;

-- Show RLS status for all tables
SELECT 
  t.tablename as table_name,
  c.relrowsecurity as rls_enabled,
  (SELECT COUNT(*) FROM pg_policies p WHERE p.tablename = t.tablename) as policy_count
FROM pg_tables t
JOIN pg_class c ON c.relname = t.tablename
WHERE t.schemaname = 'public'
AND t.tablename IN (
  'ism_reports', 'ism_report_tracking', 'ism_agent_logs', 'ism_source_cache', 'ism_report_progress',
  'company_reports', 'company_agent_logs',
  'crypto_reports', 'crypto_report_progress', 'crypto_agent_logs'
)
ORDER BY t.tablename;

-- =====================================================
-- ISM SECTOR & TICKER STORAGE - SQL MIGRATION
-- =====================================================
-- Run this in Supabase SQL Editor
-- =====================================================

-- ============================================
-- TABLE: ism_sector_analysis
-- Stores sector rankings from each report
-- ============================================
CREATE TABLE IF NOT EXISTS ism_sector_analysis (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    
    -- Link to report
    report_id TEXT NOT NULL,
    report_month TEXT NOT NULL,  -- Format: YYYY-MM
    
    -- Sector info
    sector_id TEXT NOT NULL,
    sector_name TEXT NOT NULL,
    etf_symbol TEXT,
    
    -- Ranking from report
    rank INTEGER NOT NULL,
    impact_score DECIMAL(3,1),
    direction TEXT,              -- 'positive', 'neutral', 'negative'
    ism_signal TEXT,             -- 'Positive', 'Negative'
    trend TEXT,                  -- 'Favorable', 'Unfavorable'
    
    -- Analysis from report
    reasoning TEXT,
    key_driver TEXT,
    key_driver_value DECIMAL(4,1),
    
    -- Metadata
    created_at TIMESTAMPTZ DEFAULT NOW(),
    
    CONSTRAINT unique_sector_per_report UNIQUE (report_id, sector_id)
);

-- Indexes
CREATE INDEX IF NOT EXISTS idx_sector_report_month ON ism_sector_analysis(report_month DESC);
CREATE INDEX IF NOT EXISTS idx_sector_report_id ON ism_sector_analysis(report_id);
CREATE INDEX IF NOT EXISTS idx_sector_id ON ism_sector_analysis(sector_id);

-- ============================================
-- TABLE: ism_ticker_selections
-- Stores ticker picks from each report
-- ============================================
CREATE TABLE IF NOT EXISTS ism_ticker_selections (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    
    -- Link to report
    report_id TEXT NOT NULL,
    report_month TEXT NOT NULL,
    
    -- Ticker info
    ticker TEXT NOT NULL,
    sector_id TEXT,
    sector_name TEXT,
    
    -- Selection type
    selection_type TEXT NOT NULL,  -- 'overweight', 'underweight', 'avoid', 'watchlist'
    conviction TEXT,               -- 'high', 'medium', 'low'
    
    -- From report analysis
    reasoning TEXT,
    archetype TEXT,                -- 'quality_defensives', 'cyclical_leaders', etc.
    
    -- Metadata
    created_at TIMESTAMPTZ DEFAULT NOW(),
    
    CONSTRAINT unique_ticker_per_report UNIQUE (report_id, ticker)
);

-- Indexes
CREATE INDEX IF NOT EXISTS idx_ticker_report_month ON ism_ticker_selections(report_month DESC);
CREATE INDEX IF NOT EXISTS idx_ticker_symbol ON ism_ticker_selections(ticker);
CREATE INDEX IF NOT EXISTS idx_ticker_selection_type ON ism_ticker_selections(selection_type);

-- ============================================
-- VIEW: Latest sector rankings
-- ============================================
CREATE OR REPLACE VIEW v_sector_rankings_latest AS
SELECT 
    sector_id,
    sector_name,
    etf_symbol,
    rank,
    impact_score,
    direction,
    ism_signal,
    trend,
    reasoning,
    key_driver,
    key_driver_value,
    report_month,
    report_id
FROM ism_sector_analysis
WHERE report_month = (SELECT MAX(report_month) FROM ism_sector_analysis)
ORDER BY rank ASC;

-- ============================================
-- VIEW: Latest ticker selections
-- ============================================
CREATE OR REPLACE VIEW v_ticker_selections_latest AS
SELECT 
    ticker,
    sector_id,
    sector_name,
    selection_type,
    conviction,
    reasoning,
    archetype,
    report_month,
    report_id
FROM ism_ticker_selections
WHERE report_month = (SELECT MAX(report_month) FROM ism_ticker_selections)
ORDER BY 
    CASE selection_type 
        WHEN 'overweight' THEN 1 
        WHEN 'watchlist' THEN 2 
        WHEN 'underweight' THEN 3 
        WHEN 'avoid' THEN 4 
    END,
    conviction DESC NULLS LAST;

-- ============================================
-- RLS Policies
-- ============================================
ALTER TABLE ism_sector_analysis ENABLE ROW LEVEL SECURITY;
ALTER TABLE ism_ticker_selections ENABLE ROW LEVEL SECURITY;

-- Drop existing policies first
DROP POLICY IF EXISTS "Read sector analysis" ON ism_sector_analysis;
DROP POLICY IF EXISTS "Read ticker selections" ON ism_ticker_selections;
DROP POLICY IF EXISTS "Service manage sectors" ON ism_sector_analysis;
DROP POLICY IF EXISTS "Service manage tickers" ON ism_ticker_selections;

-- Allow authenticated users to read
CREATE POLICY "Read sector analysis" ON ism_sector_analysis
    FOR SELECT TO authenticated USING (true);

CREATE POLICY "Read ticker selections" ON ism_ticker_selections 
    FOR SELECT TO authenticated USING (true);

-- Allow service role full access
CREATE POLICY "Service manage sectors" ON ism_sector_analysis 
    FOR ALL TO service_role USING (true) WITH CHECK (true);

CREATE POLICY "Service manage tickers" ON ism_ticker_selections 
    FOR ALL TO service_role USING (true) WITH CHECK (true);

-- ============================================
-- Grant permissions on views
-- ============================================
GRANT SELECT ON v_sector_rankings_latest TO authenticated;
GRANT SELECT ON v_ticker_selections_latest TO authenticated;

-- ============================================
-- Comments
-- ============================================
COMMENT ON TABLE ism_sector_analysis IS 'Stores sector rankings from each ISM report';
COMMENT ON TABLE ism_ticker_selections IS 'Stores ticker selections from each ISM report';
COMMENT ON VIEW v_sector_rankings_latest IS 'Quick access to most recent sector rankings';
COMMENT ON VIEW v_ticker_selections_latest IS 'Quick access to most recent ticker selections';


-- ============================================
-- ISM QUOTES TABLE
-- ============================================
CREATE TABLE IF NOT EXISTS ism_quotes (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  report_id TEXT,
  report_month VARCHAR(7) NOT NULL,
  industry VARCHAR(100) NOT NULL,
  sector VARCHAR(50),
  comment TEXT NOT NULL,
  sentiment VARCHAR(20) DEFAULT 'neutral',
  key_theme VARCHAR(50),
  is_verified BOOLEAN DEFAULT true,
  source VARCHAR(100) DEFAULT 'ISM Report',
  display_order INTEGER DEFAULT 1,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- ============================================
-- ISM SECTOR RANKINGS TABLE
-- ============================================
CREATE TABLE IF NOT EXISTS ism_sector_rankings (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  report_id TEXT NOT NULL,
  report_month VARCHAR(7) NOT NULL,
  sector_name VARCHAR(50) NOT NULL,
  sector_etf VARCHAR(10),
  rank INTEGER,
  impact_score DECIMAL(3,1),
  direction VARCHAR(20),
  reasoning TEXT,
  quote_support TEXT,
  quote_support_industry VARCHAR(100),
  change_vs_last_month VARCHAR(20),
  why_now TEXT,
  key_stocks TEXT[],
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- ============================================
-- ISM TRADE IDEAS TABLE
-- ============================================
CREATE TABLE IF NOT EXISTS ism_trade_ideas (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  report_id TEXT NOT NULL,
  report_month VARCHAR(7) NOT NULL,
  direction VARCHAR(10) NOT NULL,
  sector VARCHAR(50),
  title VARCHAR(200) NOT NULL,
  etf VARCHAR(10),
  stocks TEXT[],
  thesis TEXT,
  executive_quote TEXT,
  executive_quote_industry VARCHAR(100),
  direct_impact TEXT,
  conviction VARCHAR(10) DEFAULT 'medium',
  invalidation TEXT[],
  risks TEXT[],
  display_order INTEGER DEFAULT 1,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- ============================================
-- ADD COLUMNS IF TABLES ALREADY EXIST (FIX)
-- ============================================
ALTER TABLE ism_quotes 
ADD COLUMN IF NOT EXISTS report_id TEXT,
ADD COLUMN IF NOT EXISTS sector VARCHAR(50),
ADD COLUMN IF NOT EXISTS source VARCHAR(100) DEFAULT 'ISM Report',
ADD COLUMN IF NOT EXISTS display_order INTEGER DEFAULT 1;

ALTER TABLE ism_sector_rankings 
ADD COLUMN IF NOT EXISTS report_id TEXT,
ADD COLUMN IF NOT EXISTS quote_support TEXT,
ADD COLUMN IF NOT EXISTS quote_support_industry VARCHAR(100),
ADD COLUMN IF NOT EXISTS why_now TEXT,
ADD COLUMN IF NOT EXISTS key_stocks TEXT[];

ALTER TABLE ism_trade_ideas 
ADD COLUMN IF NOT EXISTS report_id TEXT,
ADD COLUMN IF NOT EXISTS executive_quote TEXT,
ADD COLUMN IF NOT EXISTS executive_quote_industry VARCHAR(100),
ADD COLUMN IF NOT EXISTS display_order INTEGER DEFAULT 1;

-- ============================================
-- ISM SECTOR RANKINGS TABLE
-- Stores sector impact analysis from each report
-- ============================================
CREATE TABLE IF NOT EXISTS ism_sector_rankings (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  report_id TEXT NOT NULL,                           -- â˜… NEW: Required link to report
  report_month VARCHAR(7) NOT NULL,
  sector_name VARCHAR(50) NOT NULL,
  sector_etf VARCHAR(10),
  rank INTEGER,
  impact_score DECIMAL(3,1),
  direction VARCHAR(20),                             -- 'positive', 'neutral', 'negative'
  reasoning TEXT,
  quote_support TEXT,                                -- Executive quote supporting this ranking
  quote_support_industry VARCHAR(100),               -- Industry of the supporting quote
  change_vs_last_month VARCHAR(20),
  why_now TEXT,
  key_stocks TEXT[],                                 -- Array of ticker symbols
  created_at TIMESTAMPTZ DEFAULT NOW(),
  UNIQUE(report_id, sector_name)                     -- â˜… CHANGED: Unique per report
);

-- ============================================
-- ISM TRADE IDEAS TABLE
-- Stores actionable trade ideas from each report
-- ============================================
CREATE TABLE IF NOT EXISTS ism_trade_ideas (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  report_id TEXT NOT NULL,                           -- â˜… NEW: Required link to report
  report_month VARCHAR(7) NOT NULL,
  direction VARCHAR(10) NOT NULL,                    -- 'long' or 'short'
  sector VARCHAR(50),
  title VARCHAR(200) NOT NULL,
  etf VARCHAR(10),
  stocks TEXT[],                                     -- Array of alternative stock tickers
  thesis TEXT,
  executive_quote TEXT,                              -- â˜… RENAMED from ism_connection
  executive_quote_industry VARCHAR(100),
  direct_impact TEXT,
  conviction VARCHAR(10) DEFAULT 'medium',           -- 'high', 'medium', 'low'
  invalidation TEXT[],
  risks TEXT[],
  display_order INTEGER DEFAULT 1,                   -- â˜… NEW
  created_at TIMESTAMPTZ DEFAULT NOW(),
  UNIQUE(report_id, title)                           -- â˜… CHANGED: Unique per report
);

-- ============================================
-- INDEXES
-- ============================================
CREATE INDEX IF NOT EXISTS idx_quotes_report_id ON ism_quotes(report_id);
CREATE INDEX IF NOT EXISTS idx_quotes_month ON ism_quotes(report_month);
CREATE INDEX IF NOT EXISTS idx_quotes_industry ON ism_quotes(industry);

CREATE INDEX IF NOT EXISTS idx_sectors_report_id ON ism_sector_rankings(report_id);
CREATE INDEX IF NOT EXISTS idx_sectors_month ON ism_sector_rankings(report_month);
CREATE INDEX IF NOT EXISTS idx_sectors_rank ON ism_sector_rankings(rank);

CREATE INDEX IF NOT EXISTS idx_trades_report_id ON ism_trade_ideas(report_id);
CREATE INDEX IF NOT EXISTS idx_trades_month ON ism_trade_ideas(report_month);
CREATE INDEX IF NOT EXISTS idx_trades_direction ON ism_trade_ideas(direction);

-- ============================================
-- RLS POLICIES
-- ============================================
ALTER TABLE ism_quotes ENABLE ROW LEVEL SECURITY;
ALTER TABLE ism_sector_rankings ENABLE ROW LEVEL SECURITY;
ALTER TABLE ism_trade_ideas ENABLE ROW LEVEL SECURITY;

-- Drop existing policies
DROP POLICY IF EXISTS "Read ism_quotes" ON ism_quotes;
DROP POLICY IF EXISTS "Service manage ism_quotes" ON ism_quotes;
DROP POLICY IF EXISTS "Read ism_sector_rankings" ON ism_sector_rankings;
DROP POLICY IF EXISTS "Service manage ism_sector_rankings" ON ism_sector_rankings;
DROP POLICY IF EXISTS "Read ism_trade_ideas" ON ism_trade_ideas;
DROP POLICY IF EXISTS "Service manage ism_trade_ideas" ON ism_trade_ideas;

-- ism_quotes policies
CREATE POLICY "Read ism_quotes" ON ism_quotes
  FOR SELECT TO authenticated USING (true);
CREATE POLICY "Service manage ism_quotes" ON ism_quotes
  FOR ALL TO service_role USING (true) WITH CHECK (true);

-- ism_sector_rankings policies
CREATE POLICY "Read ism_sector_rankings" ON ism_sector_rankings
  FOR SELECT TO authenticated USING (true);
CREATE POLICY "Service manage ism_sector_rankings" ON ism_sector_rankings
  FOR ALL TO service_role USING (true) WITH CHECK (true);

-- ism_trade_ideas policies
CREATE POLICY "Read ism_trade_ideas" ON ism_trade_ideas
  FOR SELECT TO authenticated USING (true);
CREATE POLICY "Service manage ism_trade_ideas" ON ism_trade_ideas
  FOR ALL TO service_role USING (true) WITH CHECK (true);

-- ============================================
-- GRANTS
-- ============================================
GRANT SELECT ON ism_quotes TO authenticated;
GRANT SELECT ON ism_sector_rankings TO authenticated;
GRANT SELECT ON ism_trade_ideas TO authenticated;

GRANT ALL ON ism_quotes TO service_role;
GRANT ALL ON ism_sector_rankings TO service_role;
GRANT ALL ON ism_trade_ideas TO service_role;

-- ============================================
-- VIEWS FOR EASY ACCESS
-- ============================================

-- Latest sector rankings view
CREATE OR REPLACE VIEW v_ism_sector_rankings_latest AS
SELECT 
  sector_name,
  sector_etf,
  rank,
  impact_score,
  direction,
  reasoning,
  key_stocks,
  quote_support,
  report_month,
  report_id
FROM ism_sector_rankings
WHERE report_month = (SELECT MAX(report_month) FROM ism_sector_rankings)
ORDER BY rank ASC;

-- Latest trade ideas view
CREATE OR REPLACE VIEW v_ism_trade_ideas_latest AS
SELECT 
  title,
  direction,
  sector,
  etf,
  stocks,
  thesis,
  executive_quote,
  conviction,
  report_month,
  report_id
FROM ism_trade_ideas
WHERE report_month = (SELECT MAX(report_month) FROM ism_trade_ideas)
ORDER BY display_order ASC;

-- Grant access to views
GRANT SELECT ON v_ism_sector_rankings_latest TO authenticated;
GRANT SELECT ON v_ism_trade_ideas_latest TO authenticated;
-- =====================================================
-- ISM SCHEDULER + SYSTEM UPDATES INTEGRATION v4.1
-- =====================================================
-- ============================================
-- 2. CREATE ISM SCHEDULER LOGS TABLE
-- ============================================

CREATE TABLE IF NOT EXISTS ism_scheduler_logs (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  job_type TEXT NOT NULL DEFAULT 'monthly_generation',
  status TEXT NOT NULL, -- 'success', 'error', 'skipped'
  data_month TEXT,
  report_id TEXT,
  duration_ms INTEGER,
  error_message TEXT,
  metadata JSONB,                                    -- â­ NEW
  executed_at TIMESTAMPTZ DEFAULT NOW(),
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Add metadata column if table already exists
ALTER TABLE ism_scheduler_logs 
ADD COLUMN IF NOT EXISTS metadata JSONB;

COMMENT ON COLUMN ism_scheduler_logs.metadata IS 'Stores email stats: emails_sent, emails_failed';


-- Indexes
CREATE INDEX IF NOT EXISTS idx_scheduler_logs_month ON ism_scheduler_logs(data_month);
CREATE INDEX IF NOT EXISTS idx_scheduler_logs_status ON ism_scheduler_logs(status);
CREATE INDEX IF NOT EXISTS idx_scheduler_logs_executed ON ism_scheduler_logs(executed_at DESC);

-- RLS
ALTER TABLE ism_scheduler_logs ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Admins view scheduler logs" ON ism_scheduler_logs;
CREATE POLICY "Admins view scheduler logs" ON ism_scheduler_logs
  FOR SELECT TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM profiles
      WHERE profiles.id = auth.uid()
      AND profiles.role IN ('admin', 'super_admin')
    )
  );

DROP POLICY IF EXISTS "Service manage scheduler logs" ON ism_scheduler_logs;
CREATE POLICY "Service manage scheduler logs" ON ism_scheduler_logs
  FOR ALL TO service_role
  USING (true)
  WITH CHECK (true);


-- ============================================
-- 3. FUNCTION TO INCREMENT UPDATE VIEWS
-- ============================================

CREATE OR REPLACE FUNCTION increment_update_views(update_id UUID)
RETURNS void AS $$
BEGIN
  UPDATE system_updates 
  SET views_count = COALESCE(views_count, 0) + 1
  WHERE id = update_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

GRANT EXECUTE ON FUNCTION increment_update_views TO authenticated;

-- ============================================
-- 3.5 FUNCTION TO CHECK IF USER IS ADMIN         â­ NEW SECTION
-- ============================================

CREATE OR REPLACE FUNCTION is_admin_user(p_user_id UUID)
RETURNS BOOLEAN AS $$
DECLARE
  v_role TEXT;
  v_email TEXT;
BEGIN
  SELECT role, email 
  INTO v_role, v_email
  FROM profiles 
  WHERE id = p_user_id;
  
  -- Admin if role is admin/super_admin OR email is admin email
  RETURN v_role IN ('admin', 'super_admin') OR v_email = 'elad2550@gmail.com';
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

GRANT EXECUTE ON FUNCTION is_admin_user(UUID) TO authenticated;
GRANT EXECUTE ON FUNCTION is_admin_user(UUID) TO service_role;

COMMENT ON FUNCTION is_admin_user IS 'Returns true if user is admin (by role or email)';

-- ============================================
-- 4. VERIFY SETUP
-- ============================================
DO $$
BEGIN
  RAISE NOTICE '';
  RAISE NOTICE '=====================================================';
  RAISE NOTICE 'âœ… ISM SCHEDULER INTEGRATION v4.1 COMPLETE';
  RAISE NOTICE '=====================================================';
  RAISE NOTICE '';
  RAISE NOTICE 'Schedule: 10:30 AM ET, days 1-5 of month';
  RAISE NOTICE 'No retries - ISM releases at 10 AM or not at all';
  RAISE NOTICE '';
  RAISE NOTICE 'Added to system_updates:';
  RAISE NOTICE '  â€¢ metadata (JSONB) - PDF URL, report info';
  RAISE NOTICE '  â€¢ is_pinned (BOOLEAN) - pin latest report';
  RAISE NOTICE '  â€¢ views_count (INTEGER) - track views';
  RAISE NOTICE '';
  RAISE NOTICE 'New table: ism_scheduler_logs';
  RAISE NOTICE '=====================================================';
END $$;

-- =====================================================
-- CREATE STORAGE BUCKET FOR ISM REPORTS
-- =====================================================
-- Run this in Supabase SQL Editor
-- =====================================================

-- Create the reports bucket if it doesn't exist
INSERT INTO storage.buckets (id, name, public, file_size_limit, allowed_mime_types)
VALUES (
  'reports',
  'reports',
  true,  -- Public bucket so users can download PDFs
  52428800,  -- 50MB max file size
  ARRAY['application/pdf']::text[]
)
ON CONFLICT (id) DO UPDATE SET
  public = EXCLUDED.public,
  file_size_limit = EXCLUDED.file_size_limit,
  allowed_mime_types = EXCLUDED.allowed_mime_types;

-- ============================================
-- STORAGE POLICIES
-- ============================================

-- Drop existing policies first
DROP POLICY IF EXISTS "Authenticated users can read reports" ON storage.objects;
DROP POLICY IF EXISTS "Service role can manage reports" ON storage.objects;
DROP POLICY IF EXISTS "Anyone can read public reports" ON storage.objects;

-- Allow authenticated users to read reports
CREATE POLICY "Authenticated users can read reports"
ON storage.objects FOR SELECT
TO authenticated
USING (bucket_id = 'reports');

-- Allow service role to upload/manage reports
CREATE POLICY "Service role can manage reports"
ON storage.objects FOR ALL
TO service_role
USING (bucket_id = 'reports')
WITH CHECK (bucket_id = 'reports');

-- Allow anon to read (for public PDF links)
CREATE POLICY "Anyone can read public reports"
ON storage.objects FOR SELECT
TO anon
USING (bucket_id = 'reports');

-- ============================================
-- VERIFY
-- ============================================

SELECT id, name, public, file_size_limit 
FROM storage.buckets 
WHERE id = 'reports';

-- =====================================================
-- CRYPTO SCHEDULER - DATABASE MIGRATION
-- =====================================================
-- Run this in Supabase SQL Editor
-- Creates tables for system updates and admin notifications
-- =====================================================

-- ============================================
-- 1. SYSTEM UPDATES TABLE
-- ============================================
-- This table stores notifications/updates shown in the Support widget

-- Drop old constraint if exists (in case table already exists with different constraint)
ALTER TABLE system_updates DROP CONSTRAINT IF EXISTS system_updates_type_check;

CREATE TABLE IF NOT EXISTS system_updates (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  title TEXT NOT NULL,
  content TEXT NOT NULL,
  type TEXT NOT NULL DEFAULT 'info',

  target_group TEXT NOT NULL DEFAULT 'all' CHECK (target_group IN ('all', 'top_secret', 'newsletter', 'trading_journal')),
  is_active BOOLEAN NOT NULL DEFAULT true,
  is_pinned BOOLEAN NOT NULL DEFAULT false,
  metadata JSONB DEFAULT '{}',
  views_count INTEGER NOT NULL DEFAULT 0,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  expires_at TIMESTAMPTZ DEFAULT NULL
);

-- Index for faster queries
-- Index for faster queries
CREATE INDEX IF NOT EXISTS idx_system_updates_target_group ON system_updates(target_group);
CREATE INDEX IF NOT EXISTS idx_system_updates_is_active ON system_updates(is_active);
CREATE INDEX IF NOT EXISTS idx_system_updates_created_at ON system_updates(created_at DESC);
CREATE INDEX IF NOT EXISTS idx_system_updates_type ON system_updates(type);
CREATE INDEX IF NOT EXISTS idx_system_updates_metadata ON system_updates USING GIN (metadata);
CREATE INDEX IF NOT EXISTS idx_system_updates_pinned ON system_updates(is_pinned) WHERE is_pinned = true;

-- Add columns if table already existed without them
ALTER TABLE system_updates 
ADD COLUMN IF NOT EXISTS metadata JSONB DEFAULT NULL;

ALTER TABLE system_updates 
ADD COLUMN IF NOT EXISTS is_pinned BOOLEAN DEFAULT false;

ALTER TABLE system_updates 
ADD COLUMN IF NOT EXISTS views_count INTEGER DEFAULT 0;

ALTER TABLE system_updates 
ADD COLUMN IF NOT EXISTS published_at TIMESTAMPTZ DEFAULT NOW();

-- Add constraint after table creation
ALTER TABLE system_updates DROP CONSTRAINT IF EXISTS system_updates_type_check;
ALTER TABLE system_updates ADD CONSTRAINT system_updates_type_check 
  CHECK (type IN ('info', 'success', 'warning', 'announcement'));
-- ============================================
-- 2. USER UPDATE READS TABLE
-- ============================================
-- Tracks which updates each user has read

CREATE TABLE IF NOT EXISTS user_update_reads (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  update_id UUID NOT NULL REFERENCES system_updates(id) ON DELETE CASCADE,
  read_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  UNIQUE(user_id, update_id)
);

-- Index for faster lookups
CREATE INDEX IF NOT EXISTS idx_user_update_reads_user_id ON user_update_reads(user_id);
CREATE INDEX IF NOT EXISTS idx_user_update_reads_update_id ON user_update_reads(update_id);

-- ============================================
-- 3. ADMIN NOTIFICATIONS TABLE
-- ============================================
-- Notifications for admin dashboard (failures, alerts, etc.)

CREATE TABLE IF NOT EXISTS admin_notifications (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  type TEXT NOT NULL,
  title TEXT NOT NULL,
  message TEXT NOT NULL,
  severity TEXT NOT NULL DEFAULT 'info' CHECK (severity IN ('info', 'warning', 'error', 'critical')),
  is_read BOOLEAN NOT NULL DEFAULT false,
  metadata JSONB DEFAULT '{}',
  created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE INDEX IF NOT EXISTS idx_admin_notifications_is_read ON admin_notifications(is_read);
CREATE INDEX IF NOT EXISTS idx_admin_notifications_severity ON admin_notifications(severity);
CREATE INDEX IF NOT EXISTS idx_admin_notifications_created_at ON admin_notifications(created_at DESC);

-- ============================================
-- 4. CRYPTO REPORTS TABLE (if not exists)
-- ============================================

CREATE TABLE IF NOT EXISTS crypto_reports (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  report_date DATE NOT NULL,
  market_regime TEXT,
  regime_score INTEGER,
  executive_summary JSONB,
  sections JSONB,
  raw_data JSONB,
  markdown_content TEXT,
  html_content TEXT,
  pdf_content BYTEA,
  quality_score INTEGER,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE INDEX IF NOT EXISTS idx_crypto_reports_report_date ON crypto_reports(report_date DESC);
CREATE INDEX IF NOT EXISTS idx_crypto_reports_created_at ON crypto_reports(created_at DESC);

-- ============================================
-- 5. SCHEDULER STATUS TABLE
-- ============================================
-- Tracks scheduler runs and status

CREATE TABLE IF NOT EXISTS scheduler_runs (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  scheduler_type TEXT NOT NULL, -- 'crypto', 'ism', 'weekly', etc.
  status TEXT NOT NULL CHECK (status IN ('started', 'completed', 'failed')),
  report_id UUID,
  started_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  completed_at TIMESTAMPTZ,
  error_message TEXT,
  metadata JSONB DEFAULT '{}'
);

CREATE INDEX IF NOT EXISTS idx_scheduler_runs_type ON scheduler_runs(scheduler_type);
CREATE INDEX IF NOT EXISTS idx_scheduler_runs_status ON scheduler_runs(status);
CREATE INDEX IF NOT EXISTS idx_scheduler_runs_started_at ON scheduler_runs(started_at DESC);

-- ============================================
-- 6. HELPER FUNCTION: INCREMENT VIEWS
-- ============================================

CREATE OR REPLACE FUNCTION increment_update_views(update_id UUID)
RETURNS VOID AS $$
BEGIN
  UPDATE system_updates 
  SET views_count = views_count + 1
  WHERE id = update_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- ============================================
-- 7. HELPER FUNCTION: CLEANUP OLD UPDATES
-- ============================================
-- Automatically deactivate updates older than 30 days (optional)

CREATE OR REPLACE FUNCTION cleanup_old_updates()
RETURNS VOID AS $$
BEGIN
  UPDATE system_updates 
  SET is_active = false
  WHERE created_at < NOW() - INTERVAL '30 days'
    AND is_active = true
    AND is_pinned = false;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- ============================================
-- 8. RLS POLICIES
-- ============================================

-- Enable RLS
ALTER TABLE system_updates ENABLE ROW LEVEL SECURITY;

-- Drop existing policies first
DROP POLICY IF EXISTS "Anyone can read active system updates" ON system_updates;
DROP POLICY IF EXISTS "Users see relevant system updates" ON system_updates;      -- â­ CHANGED
DROP POLICY IF EXISTS "Service role can manage system updates" ON system_updates;
DROP POLICY IF EXISTS "Users can manage their own update reads" ON user_update_reads;
DROP POLICY IF EXISTS "Service role can manage admin notifications" ON admin_notifications;
DROP POLICY IF EXISTS "Admins can read crypto reports" ON crypto_reports;
DROP POLICY IF EXISTS "Service role can manage crypto reports" ON crypto_reports;
DROP POLICY IF EXISTS "Service role can manage scheduler runs" ON scheduler_runs;

ALTER TABLE user_update_reads ENABLE ROW LEVEL SECURITY;
ALTER TABLE admin_notifications ENABLE ROW LEVEL SECURITY;
ALTER TABLE crypto_reports ENABLE ROW LEVEL SECURITY;
ALTER TABLE scheduler_runs ENABLE ROW LEVEL SECURITY;

-- System Updates: Admins see ALL, users see filtered by target_group     â­ NEW POLICY
CREATE POLICY "Users see relevant system updates" ON system_updates
  FOR SELECT TO authenticated
  USING (
    is_active = true
    AND (expires_at IS NULL OR expires_at > NOW())
    AND (
      -- âœ… ADMINS SEE EVERYTHING (no target_group filter!)
      is_admin_user(auth.uid())
      OR
      -- Regular users: filter by target_group + their subscription status
      target_group = 'all'
      OR
      (target_group = 'top_secret' AND EXISTS (
        SELECT 1 FROM profiles WHERE id = auth.uid() AND top_secret_enabled = true
      ))
      OR
      (target_group = 'newsletter' AND EXISTS (
        SELECT 1 FROM profiles WHERE id = auth.uid() 
        AND (newsletter_enabled = true OR newsletter_paid = true)
      ))
      OR
      (target_group = 'trading_journal' AND EXISTS (
        SELECT 1 FROM profiles WHERE id = auth.uid()
      ))
    )
  );

COMMENT ON POLICY "Users see relevant system updates" ON system_updates IS 
  'Admins see all updates without filters. Regular users filtered by target_group.';

-- System Updates: Only service role can insert/update
CREATE POLICY "Service role can manage system updates" ON system_updates
  FOR ALL USING (auth.role() = 'service_role');

-- User Update Reads: Users can read/insert their own
CREATE POLICY "Users can manage their own update reads" ON user_update_reads
  FOR ALL USING (auth.uid() = user_id);

-- Admin Notifications: Only admins/service role
CREATE POLICY "Service role can manage admin notifications" ON admin_notifications
  FOR ALL USING (auth.role() = 'service_role');

-- Crypto Reports: Admins can read
CREATE POLICY "Admins can read crypto reports" ON crypto_reports
  FOR SELECT USING (
    EXISTS (
      SELECT 1 FROM profiles 
      WHERE id = auth.uid() AND role IN ('admin', 'super_admin')
    )
  );

-- Crypto Reports: Service role can manage
CREATE POLICY "Service role can manage crypto reports" ON crypto_reports
  FOR ALL USING (auth.role() = 'service_role');

-- Scheduler Runs: Service role only
CREATE POLICY "Service role can manage scheduler runs" ON scheduler_runs
  FOR ALL USING (auth.role() = 'service_role');

-- ============================================
-- 9. GRANT PERMISSIONS
-- ============================================

-- Grant to authenticated users
GRANT SELECT ON system_updates TO authenticated;
GRANT SELECT, INSERT ON user_update_reads TO authenticated;
GRANT EXECUTE ON FUNCTION increment_update_views(UUID) TO authenticated;

-- Grant to anon (for public updates)
GRANT SELECT ON system_updates TO anon;

-- ============================================
-- 10. INITIAL SEED DATA (optional)
-- ============================================

-- Insert a welcome message for TOP SECRET subscribers
-- Using DO block to handle case where row might already exist
-- Insert welcome message only if it doesn't exist
INSERT INTO system_updates (title, content, type, target_group, is_active, is_pinned, metadata)
SELECT 
  'ğŸ‰ Welcome to TOP SECRET Reports',
  'You now have access to institutional-grade market analysis. Crypto reports are generated automatically on the 10th and 25th of each month.',
  'announcement',
  'top_secret',
  true,
  false,
  '{"report_type": "welcome"}'::jsonb
WHERE NOT EXISTS (
  SELECT 1 FROM system_updates 
  WHERE title = 'ğŸ‰ Welcome to TOP SECRET Reports' 
  AND target_group = 'top_secret'
);

-- ============================================
-- DONE!
-- ============================================
-- After running this migration:
-- 1. Deploy the updated scheduler.js
-- 2. Initialize the scheduler in your server startup
-- 3. Reports will auto-generate on 10th and 25th
-- ============================================

-- =====================================================
-- COMPANY SCHEDULER ISM + EARNINGS INTEGRATION
-- =====================================================
-- 
-- ğŸ“ ×”×—×œ×£ ××ª ×›×œ ×”×§×˜×¢ ×-"COMPANY SCHEDULER ISM INTEGRATION"
--    ×•×¢×“ ×¡×•×£ ×”-VERIFICATION (×©×•×¨×•×ª ~1867-1975 ×‘×§×•×‘×¥ ×©×œ×š)
--    ×‘×§×•×“ ×”×–×”:
--
-- =====================================================

-- ============================================
-- 1. ADD ISM COLUMNS TO company_reports
-- ============================================
ALTER TABLE company_reports 
ADD COLUMN IF NOT EXISTS is_ism_triggered BOOLEAN DEFAULT false,
ADD COLUMN IF NOT EXISTS ism_report_month TEXT,
ADD COLUMN IF NOT EXISTS ism_context JSONB,
ADD COLUMN IF NOT EXISTS pdf_path TEXT;

-- Indexes for ISM queries
CREATE INDEX IF NOT EXISTS idx_company_reports_ism_triggered 
ON company_reports(is_ism_triggered) WHERE is_ism_triggered = true;

CREATE INDEX IF NOT EXISTS idx_company_reports_ism_month 
ON company_reports(ism_report_month);

-- ============================================
-- 2. ADD EARNINGS COLUMNS TO company_reports
-- ============================================
ALTER TABLE company_reports 
ADD COLUMN IF NOT EXISTS is_earnings_triggered BOOLEAN DEFAULT false,
ADD COLUMN IF NOT EXISTS earnings_context JSONB,
ADD COLUMN IF NOT EXISTS earnings_date DATE,
ADD COLUMN IF NOT EXISTS earnings_price_change DECIMAL(10,2);

-- Indexes for Earnings queries
CREATE INDEX IF NOT EXISTS idx_company_reports_earnings_triggered 
ON company_reports(is_earnings_triggered) WHERE is_earnings_triggered = true;

CREATE INDEX IF NOT EXISTS idx_company_reports_earnings_date 
ON company_reports(earnings_date);

-- ============================================
-- 3. CREATE company_scheduler_logs TABLE
-- ============================================
CREATE TABLE IF NOT EXISTS company_scheduler_logs (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  job_type TEXT NOT NULL DEFAULT 'weekly_generation',
  status TEXT NOT NULL,
  ticker VARCHAR(10),
  report_id TEXT,
  duration_ms INTEGER,
  error_message TEXT,
  admin_id TEXT,
  metadata JSONB DEFAULT '{}',
  executed_at TIMESTAMPTZ DEFAULT NOW(),
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Indexes
CREATE INDEX IF NOT EXISTS idx_company_scheduler_logs_ticker ON company_scheduler_logs(ticker);
CREATE INDEX IF NOT EXISTS idx_company_scheduler_logs_status ON company_scheduler_logs(status);
CREATE INDEX IF NOT EXISTS idx_company_scheduler_logs_executed ON company_scheduler_logs(executed_at DESC);
CREATE INDEX IF NOT EXISTS idx_company_scheduler_logs_job_type ON company_scheduler_logs(job_type);

-- RLS
ALTER TABLE company_scheduler_logs ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Service manage company scheduler logs" ON company_scheduler_logs;
CREATE POLICY "Service manage company scheduler logs" ON company_scheduler_logs
  FOR ALL TO service_role USING (true) WITH CHECK (true);

DROP POLICY IF EXISTS "Admins view company scheduler logs" ON company_scheduler_logs;
CREATE POLICY "Admins view company scheduler logs" ON company_scheduler_logs
  FOR SELECT TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM profiles
      WHERE profiles.id = auth.uid()
      AND profiles.role IN ('admin', 'super_admin')
    )
  );

-- Grants
GRANT ALL ON company_scheduler_logs TO service_role;
GRANT SELECT ON company_scheduler_logs TO authenticated;

-- ============================================
-- 4. CREATE company_report_queue TABLE
-- ============================================
CREATE TABLE IF NOT EXISTS company_report_queue (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  ticker VARCHAR(10) NOT NULL,
  priority TEXT DEFAULT 'normal',
  status TEXT DEFAULT 'pending',
  requested_by UUID,
  scheduled_for TIMESTAMPTZ,
  include_ism BOOLEAN DEFAULT false,
  report_id TEXT,
  error_message TEXT,
  started_at TIMESTAMPTZ,
  completed_at TIMESTAMPTZ,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Indexes
CREATE INDEX IF NOT EXISTS idx_company_queue_status ON company_report_queue(status);
CREATE INDEX IF NOT EXISTS idx_company_queue_ticker ON company_report_queue(ticker);
CREATE INDEX IF NOT EXISTS idx_company_queue_priority ON company_report_queue(priority);

-- RLS
ALTER TABLE company_report_queue ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Service manage company queue" ON company_report_queue;
CREATE POLICY "Service manage company queue" ON company_report_queue
  FOR ALL TO service_role USING (true) WITH CHECK (true);

DROP POLICY IF EXISTS "Admins view company queue" ON company_report_queue;
CREATE POLICY "Admins view company queue" ON company_report_queue
  FOR SELECT TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM profiles
      WHERE profiles.id = auth.uid()
      AND profiles.role IN ('admin', 'super_admin')
    )
  );

-- Grants
GRANT ALL ON company_report_queue TO service_role;
GRANT SELECT ON company_report_queue TO authenticated;

-- ============================================
-- 5. CREATE earnings_auto_company_reports TABLE
-- ============================================
CREATE TABLE IF NOT EXISTS earnings_auto_company_reports (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  ticker VARCHAR(10) NOT NULL,
  company_name VARCHAR(255),
  earnings_date DATE NOT NULL,
  price_change DECIMAL(10,2) NOT NULL,
  price_change_direction VARCHAR(10) GENERATED ALWAYS AS (
    CASE WHEN price_change > 0 THEN 'up' ELSE 'down' END
  ) STORED,
  eps_estimate DECIMAL(10,4),
  eps_actual DECIMAL(10,4),
  eps_surprise VARCHAR(20),
  report_type VARCHAR(20) DEFAULT 'quarterly',
  source VARCHAR(50),
  status VARCHAR(20) DEFAULT 'pending' 
    CHECK (status IN ('pending', 'generating', 'completed', 'failed', 'cancelled')),
  company_report_id VARCHAR(100),
  error_message TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  processed_at TIMESTAMPTZ
);

-- Indexes
CREATE INDEX IF NOT EXISTS idx_earnings_auto_reports_status ON earnings_auto_company_reports(status);
CREATE INDEX IF NOT EXISTS idx_earnings_auto_reports_ticker ON earnings_auto_company_reports(ticker);
CREATE INDEX IF NOT EXISTS idx_earnings_auto_reports_date ON earnings_auto_company_reports(earnings_date);
CREATE INDEX IF NOT EXISTS idx_earnings_auto_reports_created ON earnings_auto_company_reports(created_at DESC);

-- Trigger for updated_at
CREATE OR REPLACE FUNCTION update_earnings_auto_reports_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trigger_update_earnings_auto_reports ON earnings_auto_company_reports;
CREATE TRIGGER trigger_update_earnings_auto_reports
  BEFORE UPDATE ON earnings_auto_company_reports
  FOR EACH ROW
  EXECUTE FUNCTION update_earnings_auto_reports_updated_at();

-- RLS
ALTER TABLE earnings_auto_company_reports ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Service manage earnings auto reports" ON earnings_auto_company_reports;
CREATE POLICY "Service manage earnings auto reports" ON earnings_auto_company_reports
  FOR ALL TO service_role USING (true) WITH CHECK (true);

DROP POLICY IF EXISTS "Admins view earnings auto reports" ON earnings_auto_company_reports;
CREATE POLICY "Admins view earnings auto reports" ON earnings_auto_company_reports
  FOR SELECT TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM profiles
      WHERE profiles.id = auth.uid()
      AND profiles.role IN ('admin', 'super_admin')
    )
  );

-- Grants
GRANT ALL ON earnings_auto_company_reports TO service_role;
GRANT SELECT ON earnings_auto_company_reports TO authenticated;

-- ============================================
-- 6. EARNINGS HELPER FUNCTIONS
-- ============================================

-- Function to get pending earnings reports
CREATE OR REPLACE FUNCTION get_pending_earnings_company_reports(p_limit INT DEFAULT 5)
RETURNS TABLE (
  id UUID,
  ticker VARCHAR,
  company_name VARCHAR,
  earnings_date DATE,
  price_change DECIMAL,
  eps_surprise VARCHAR,
  source VARCHAR
) AS $$
BEGIN
  RETURN QUERY
  SELECT 
    e.id, e.ticker, e.company_name, e.earnings_date,
    e.price_change, e.eps_surprise, e.source
  FROM earnings_auto_company_reports e
  WHERE e.status = 'pending'
  ORDER BY ABS(e.price_change) DESC, e.created_at ASC
  LIMIT p_limit;
END;
$$ LANGUAGE plpgsql;

-- Function to update earnings report status
CREATE OR REPLACE FUNCTION update_earnings_report_status(
  p_id UUID,
  p_status VARCHAR,
  p_company_report_id VARCHAR DEFAULT NULL,
  p_error_message TEXT DEFAULT NULL
)
RETURNS VOID AS $$
BEGIN
  UPDATE earnings_auto_company_reports
  SET 
    status = p_status,
    company_report_id = COALESCE(p_company_report_id, company_report_id),
    error_message = p_error_message,
    processed_at = CASE WHEN p_status IN ('completed', 'failed') THEN NOW() ELSE processed_at END
  WHERE id = p_id;
END;
$$ LANGUAGE plpgsql;

GRANT EXECUTE ON FUNCTION get_pending_earnings_company_reports(INT) TO service_role;
GRANT EXECUTE ON FUNCTION get_pending_earnings_company_reports(INT) TO authenticated;
GRANT EXECUTE ON FUNCTION update_earnings_report_status(UUID, VARCHAR, VARCHAR, TEXT) TO service_role;

-- ============================================
-- 6.5 ISM AUTO COMPANY REPORTS TABLE
-- ============================================
-- This table stores ISM-triggered company report requests
-- Used by scheduler.js on 10th and 20th of each month
-- Schedule: 9:00 AM ET (America/New_York)

CREATE TABLE IF NOT EXISTS ism_auto_company_reports (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  
  -- Ticker info
  ticker VARCHAR(10) NOT NULL,
  sector TEXT,
  
  -- ISM link
  ism_report_month TEXT NOT NULL,
  conviction TEXT DEFAULT 'medium',
  reasoning TEXT,
  
  -- Status tracking
  status VARCHAR(20) DEFAULT 'pending' 
    CHECK (status IN ('pending', 'generating', 'completed', 'failed', 'cancelled')),
  
  -- Report references
  report_id TEXT,
  company_report_id TEXT,
  
  -- Error tracking
  error_message TEXT,
  
  -- Timestamps
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  processed_at TIMESTAMPTZ
);

-- Indexes
CREATE INDEX IF NOT EXISTS idx_ism_auto_reports_status ON ism_auto_company_reports(status);
CREATE INDEX IF NOT EXISTS idx_ism_auto_reports_ticker ON ism_auto_company_reports(ticker);
CREATE INDEX IF NOT EXISTS idx_ism_auto_reports_month ON ism_auto_company_reports(ism_report_month);
CREATE INDEX IF NOT EXISTS idx_ism_auto_reports_created ON ism_auto_company_reports(created_at DESC);

-- Trigger for updated_at
CREATE OR REPLACE FUNCTION update_ism_auto_reports_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trigger_update_ism_auto_reports ON ism_auto_company_reports;
CREATE TRIGGER trigger_update_ism_auto_reports
  BEFORE UPDATE ON ism_auto_company_reports
  FOR EACH ROW
  EXECUTE FUNCTION update_ism_auto_reports_updated_at();

-- RLS
ALTER TABLE ism_auto_company_reports ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Service manage ism auto reports" ON ism_auto_company_reports;
CREATE POLICY "Service manage ism auto reports" ON ism_auto_company_reports
  FOR ALL TO service_role USING (true) WITH CHECK (true);

DROP POLICY IF EXISTS "Admins view ism auto reports" ON ism_auto_company_reports;
CREATE POLICY "Admins view ism auto reports" ON ism_auto_company_reports
  FOR SELECT TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM profiles
      WHERE profiles.id = auth.uid()
      AND profiles.role IN ('admin', 'super_admin')
    )
  );

-- Grants
GRANT ALL ON ism_auto_company_reports TO service_role;
GRANT SELECT ON ism_auto_company_reports TO authenticated;

-- ============================================
-- 6.6 ISM AUTO COMPANY REPORTS FUNCTIONS
-- ============================================

-- Function: schedule_company_reports_from_ism
-- Called by company-hook.js after ISM report is generated
CREATE OR REPLACE FUNCTION schedule_company_reports_from_ism(
  p_ism_report_month TEXT,
  p_count INT DEFAULT 2
)
RETURNS TABLE (
  ticker TEXT,
  sector TEXT,
  scheduled BOOLEAN
) AS $$
BEGIN
  RETURN QUERY
  WITH top_tickers AS (
    SELECT 
      ts.ticker,
      ts.sector_name as sector,
      ts.conviction
    FROM ism_ticker_selections ts
    WHERE ts.report_month = p_ism_report_month
      AND ts.selection_type = 'overweight'
    ORDER BY 
      CASE ts.conviction 
        WHEN 'high' THEN 1 
        WHEN 'medium' THEN 2 
        ELSE 3 
      END
    LIMIT p_count
  ),
  inserted AS (
    INSERT INTO ism_auto_company_reports (ticker, sector, ism_report_month, conviction, status)
    SELECT 
      tt.ticker,
      tt.sector,
      p_ism_report_month,
      tt.conviction,
      'pending'
    FROM top_tickers tt
    WHERE NOT EXISTS (
      SELECT 1 FROM ism_auto_company_reports iar
      WHERE iar.ticker = tt.ticker 
        AND iar.ism_report_month = p_ism_report_month
    )
    RETURNING ticker, sector
  )
  SELECT 
    tt.ticker::TEXT,
    tt.sector::TEXT,
    EXISTS (SELECT 1 FROM inserted i WHERE i.ticker = tt.ticker) as scheduled
  FROM top_tickers tt;
END;
$$ LANGUAGE plpgsql;

-- Function: get_pending_auto_company_reports
-- Called by company-hook.js to process pending reports
CREATE OR REPLACE FUNCTION get_pending_auto_company_reports(p_limit INT DEFAULT 5)
RETURNS TABLE (
  id UUID,
  ticker VARCHAR,
  sector TEXT,
  ism_report_month TEXT,
  conviction TEXT
) AS $$
BEGIN
  RETURN QUERY
  SELECT 
    iar.id,
    iar.ticker,
    iar.sector,
    iar.ism_report_month,
    iar.conviction
  FROM ism_auto_company_reports iar
  WHERE iar.status = 'pending'
  ORDER BY 
    CASE iar.conviction 
      WHEN 'high' THEN 1 
      WHEN 'medium' THEN 2 
      ELSE 3 
    END,
    iar.created_at ASC
  LIMIT p_limit;
END;
$$ LANGUAGE plpgsql;

-- Function: update_auto_company_report_status
-- Called by company-hook.js to update report status
CREATE OR REPLACE FUNCTION update_auto_company_report_status(
  p_id UUID,
  p_status VARCHAR,
  p_company_report_id TEXT DEFAULT NULL,
  p_error_message TEXT DEFAULT NULL
)
RETURNS VOID AS $$
BEGIN
  UPDATE ism_auto_company_reports
  SET 
    status = p_status,
    company_report_id = COALESCE(p_company_report_id, company_report_id),
    report_id = COALESCE(p_company_report_id, report_id),
    error_message = p_error_message,
    processed_at = CASE WHEN p_status IN ('completed', 'failed') THEN NOW() ELSE processed_at END,
    updated_at = NOW()
  WHERE id = p_id;
END;
$$ LANGUAGE plpgsql;

-- Function: get_ism_sector_context
-- Called by company-hook.js to get ISM context for sector
CREATE OR REPLACE FUNCTION get_ism_sector_context(p_sector TEXT)
RETURNS JSONB AS $$
DECLARE
  v_context JSONB;
BEGIN
  SELECT jsonb_build_object(
    'sector', p_sector,
    'latest_ranking', (
      SELECT jsonb_build_object(
        'rank', rank,
        'impact_score', impact_score,
        'direction', direction,
        'reasoning', reasoning,
        'report_month', report_month
      )
      FROM ism_sector_analysis
      WHERE sector_name ILIKE '%' || p_sector || '%'
      ORDER BY report_month DESC
      LIMIT 1
    ),
    'trade_ideas', (
      SELECT jsonb_agg(jsonb_build_object(
        'title', title,
        'thesis', thesis,
        'conviction', conviction,
        'etf', etf
      ))
      FROM (
        SELECT title, thesis, conviction, etf
        FROM ism_trade_ideas
        WHERE sector ILIKE '%' || p_sector || '%'
        ORDER BY report_month DESC
        LIMIT 2
      ) sub
    )
  ) INTO v_context;
  
  RETURN COALESCE(v_context, '{}'::jsonb);
END;
$$ LANGUAGE plpgsql;

-- Grants for ISM auto functions
GRANT EXECUTE ON FUNCTION schedule_company_reports_from_ism(TEXT, INT) TO service_role;
GRANT EXECUTE ON FUNCTION schedule_company_reports_from_ism(TEXT, INT) TO authenticated;
GRANT EXECUTE ON FUNCTION get_pending_auto_company_reports(INT) TO service_role;
GRANT EXECUTE ON FUNCTION get_pending_auto_company_reports(INT) TO authenticated;
GRANT EXECUTE ON FUNCTION update_auto_company_report_status(UUID, VARCHAR, TEXT, TEXT) TO service_role;
GRANT EXECUTE ON FUNCTION get_ism_sector_context(TEXT) TO service_role;
GRANT EXECUTE ON FUNCTION get_ism_sector_context(TEXT) TO authenticated;

-- ============================================
-- 7. VERIFICATION
-- ============================================
DO $$
BEGIN
  RAISE NOTICE '';
  RAISE NOTICE '=====================================================';
  RAISE NOTICE 'âœ… COMPANY SCHEDULER ISM + EARNINGS INTEGRATION COMPLETE';
  RAISE NOTICE '=====================================================';
  RAISE NOTICE '';
  RAISE NOTICE 'Added to company_reports:';
  RAISE NOTICE '  â€¢ is_ism_triggered (BOOLEAN)';
  RAISE NOTICE '  â€¢ ism_report_month (TEXT)';
  RAISE NOTICE '  â€¢ ism_context (JSONB)';
  RAISE NOTICE '  â€¢ pdf_path (TEXT)';
  RAISE NOTICE '  â€¢ is_earnings_triggered (BOOLEAN)';
  RAISE NOTICE '  â€¢ earnings_context (JSONB)';
  RAISE NOTICE '  â€¢ earnings_date (DATE)';
  RAISE NOTICE '  â€¢ earnings_price_change (DECIMAL)';
  RAISE NOTICE '';
  RAISE NOTICE 'New tables:';
  RAISE NOTICE '  â€¢ company_scheduler_logs';
  RAISE NOTICE '  â€¢ company_report_queue';
  RAISE NOTICE '  â€¢ earnings_auto_company_reports';
  RAISE NOTICE '  â€¢ ism_auto_company_reports';
  RAISE NOTICE '';
  RAISE NOTICE 'Schedule (All times ET - America/New_York):';
  RAISE NOTICE '  â€¢ 10th at 9:00 AM ET - ISM Company Report #1';
  RAISE NOTICE '  â€¢ 20th at 9:00 AM ET - ISM Company Report #2';
  RAISE NOTICE '  â€¢ 30th at 9:00 AM ET - Earnings Company Report';
  RAISE NOTICE '=====================================================';
END $$;

-- Verify columns were added
SELECT column_name, data_type 
FROM information_schema.columns 
WHERE table_name = 'company_reports' 
AND column_name IN (
  'is_ism_triggered', 'ism_report_month', 'ism_context', 'pdf_path',
  'is_earnings_triggered', 'earnings_context', 'earnings_date', 'earnings_price_change'
)
ORDER BY column_name;

-- =====================================================
-- ADMIN SEES ALL REPORTS - SQL MIGRATION
-- =====================================================
-- Run this in Supabase SQL Editor
-- =====================================================

-- ============================================
-- 1. FUNCTION: Get system updates for user
-- Returns ALL updates for admins, filtered for regular users
-- ============================================

CREATE OR REPLACE FUNCTION get_system_updates_for_user(
  p_user_id UUID,
  p_limit INTEGER DEFAULT 20
)
RETURNS TABLE (
  id UUID,
  title TEXT,
  content TEXT,
  type TEXT,
  target_group TEXT,
  is_active BOOLEAN,
  is_pinned BOOLEAN,
  metadata JSONB,
  views_count INTEGER,
  created_at TIMESTAMPTZ,
  expires_at TIMESTAMPTZ,
  is_read BOOLEAN
) AS $$
DECLARE
  v_user_role TEXT;
  v_user_email TEXT;
  v_account_type TEXT;
  v_top_secret_enabled BOOLEAN;
  v_newsletter_paid BOOLEAN;
BEGIN
  -- Get user info
  SELECT 
    p.role,
    p.email,
    COALESCE(p.account_type, 'free'),
    COALESCE(p.top_secret_enabled, false),
    COALESCE(p.newsletter_paid, false)
  INTO v_user_role, v_user_email, v_account_type, v_top_secret_enabled, v_newsletter_paid
  FROM profiles p
  WHERE p.id = p_user_id;
  
  -- Admin check: role is admin/super_admin OR email is admin email
  IF v_user_role IN ('admin', 'super_admin') OR v_user_email = 'elad2550@gmail.com' THEN
    -- Admins see ALL active updates
    RETURN QUERY
    SELECT 
      su.id,
      su.title,
      su.content,
      su.type,
      su.target_group,
      su.is_active,
      su.is_pinned,
      su.metadata,
      su.views_count,
      su.created_at,
      su.expires_at,
      COALESCE(uur.read_at IS NOT NULL, false) as is_read
    FROM system_updates su
    LEFT JOIN user_update_reads uur ON uur.update_id = su.id AND uur.user_id = p_user_id
    WHERE su.is_active = true
      AND (su.expires_at IS NULL OR su.expires_at > NOW())
    ORDER BY su.is_pinned DESC, su.created_at DESC
    LIMIT p_limit;
  ELSE
    -- Regular users: filter by target_group
    RETURN QUERY
    SELECT 
      su.id,
      su.title,
      su.content,
      su.type,
      su.target_group,
      su.is_active,
      su.is_pinned,
      su.metadata,
      su.views_count,
      su.created_at,
      su.expires_at,
      COALESCE(uur.read_at IS NOT NULL, false) as is_read
    FROM system_updates su
    LEFT JOIN user_update_reads uur ON uur.update_id = su.id AND uur.user_id = p_user_id
    WHERE su.is_active = true
      AND (su.expires_at IS NULL OR su.expires_at > NOW())
      AND (
        su.target_group = 'all'
        OR (su.target_group = 'top_secret' AND v_top_secret_enabled = true)
        OR (su.target_group = 'newsletter' AND v_newsletter_paid = true)
        OR (su.target_group = 'trading_journal' AND v_account_type IN ('basic', 'premium', 'pro'))
      )
    ORDER BY su.is_pinned DESC, su.created_at DESC
    LIMIT p_limit;
  END IF;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Grant execute to authenticated users
GRANT EXECUTE ON FUNCTION get_system_updates_for_user(UUID, INTEGER) TO authenticated;

-- ============================================
-- 2. FUNCTION: Check if user is admin
-- ============================================

CREATE OR REPLACE FUNCTION is_admin_user(p_user_id UUID)
RETURNS BOOLEAN AS $$
DECLARE
  v_role TEXT;
  v_email TEXT;
BEGIN
  SELECT role, email 
  INTO v_role, v_email
  FROM profiles 
  WHERE id = p_user_id;
  
  RETURN v_role IN ('admin', 'super_admin') OR v_email = 'elad2550@gmail.com';
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

GRANT EXECUTE ON FUNCTION is_admin_user(UUID) TO authenticated;

-- ============================================
-- 3. UPDATE RLS POLICY for system_updates
-- Allow admins to see all, others see filtered
-- ============================================

-- Drop old policies
DROP POLICY IF EXISTS "Anyone can read active system updates" ON system_updates;
DROP POLICY IF EXISTS "Users see relevant system updates" ON system_updates;

-- New policy: Admins see all, others see based on target_group
CREATE POLICY "Users see relevant system updates" ON system_updates
  FOR SELECT TO authenticated
  USING (
    is_active = true
    AND (expires_at IS NULL OR expires_at > NOW())
    AND (
      -- Admins see everything
      is_admin_user(auth.uid())
      OR
      -- Others see based on target_group
      target_group = 'all'
      OR
      (target_group = 'top_secret' AND EXISTS (
        SELECT 1 FROM profiles WHERE id = auth.uid() AND top_secret_enabled = true
      ))
      OR
      (target_group = 'newsletter' AND EXISTS (
        SELECT 1 FROM profiles WHERE id = auth.uid() AND newsletter_paid = true
      ))
      OR
      (target_group = 'trading_journal' AND EXISTS (
        SELECT 1 FROM profiles WHERE id = auth.uid() AND account_type IN ('basic', 'premium', 'pro')
      ))
    )
  );

-- ============================================
-- 4. VERIFY ADMIN EMAIL
-- ============================================

-- Make sure your profile has admin role
UPDATE profiles 
SET role = 'admin'
WHERE email = 'elad2550@gmail.com'
  AND role NOT IN ('admin', 'super_admin');

-- ============================================
-- 4.5 ENABLE EMAIL NOTIFICATIONS FOR ADMIN    â­ NEW SECTION
-- ============================================

-- Set newsletter preferences for admin (so you get emails)
UPDATE profiles 
SET newsletter_preferences = COALESCE(newsletter_preferences, '{}'::jsonb) || 
    jsonb_build_object('update_center_email', true)
WHERE email = 'elad2550@gmail.com'
  AND (newsletter_preferences IS NULL 
       OR NOT newsletter_preferences ? 'update_center_email');

-- Also enable for all TOP SECRET users
UPDATE profiles 
SET newsletter_preferences = COALESCE(newsletter_preferences, '{}'::jsonb) || 
    jsonb_build_object('update_center_email', true)
WHERE top_secret_enabled = true
  AND (newsletter_preferences IS NULL 
       OR NOT newsletter_preferences ? 'update_center_email');

-- ============================================
-- DONE!
-- ============================================

DO $$
BEGIN
  RAISE NOTICE '';
  RAISE NOTICE '=====================================================';
  RAISE NOTICE 'âœ… ADMIN SEES ALL REPORTS - MIGRATION COMPLETE';
  RAISE NOTICE '=====================================================';
  RAISE NOTICE '';
  RAISE NOTICE 'Admin email: elad2550@gmail.com';
  RAISE NOTICE 'Now sees ALL system_updates regardless of target_group';
  RAISE NOTICE '';
  RAISE NOTICE 'Access rules:';
  RAISE NOTICE '  â€¢ top_secret â†’ top_secret_enabled = true';
  RAISE NOTICE '  â€¢ newsletter â†’ newsletter_paid = true';
  RAISE NOTICE '  â€¢ trading_journal â†’ account_type IN (basic, premium, pro)';
  RAISE NOTICE '=====================================================';
END $$;
-- =====================================================
-- MIGRATION 11: Top Secret 14-Day Trial & Journal Discount
-- =====================================================

-- PART 1: TOP SECRET TRIAL COLUMNS
ALTER TABLE profiles ADD COLUMN IF NOT EXISTS top_secret_trial_used BOOLEAN DEFAULT FALSE;
COMMENT ON COLUMN profiles.top_secret_trial_used IS 'Whether user has used their Top Secret 14-day trial';

ALTER TABLE profiles ADD COLUMN IF NOT EXISTS top_secret_trial_start_date TIMESTAMPTZ;
COMMENT ON COLUMN profiles.top_secret_trial_start_date IS 'When Top Secret trial started';

ALTER TABLE profiles ADD COLUMN IF NOT EXISTS top_secret_trial_ends_at TIMESTAMPTZ;
COMMENT ON COLUMN profiles.top_secret_trial_ends_at IS 'When Top Secret trial ends';

ALTER TABLE profiles ADD COLUMN IF NOT EXISTS top_secret_is_in_trial BOOLEAN DEFAULT FALSE;
COMMENT ON COLUMN profiles.top_secret_is_in_trial IS 'Whether user is currently in Top Secret trial period';

-- PART 2: JOURNAL DISCOUNT COLUMNS
ALTER TABLE profiles ADD COLUMN IF NOT EXISTS journal_discount_available BOOLEAN DEFAULT FALSE;
COMMENT ON COLUMN profiles.journal_discount_available IS '25% one-time Journal discount available (for newsletter/top_secret subscribers)';

ALTER TABLE profiles ADD COLUMN IF NOT EXISTS journal_discount_percent INTEGER DEFAULT 25;
COMMENT ON COLUMN profiles.journal_discount_percent IS 'Discount percentage for Journal (default 25%)';

ALTER TABLE profiles ADD COLUMN IF NOT EXISTS journal_discount_used BOOLEAN DEFAULT FALSE;
COMMENT ON COLUMN profiles.journal_discount_used IS 'Whether user has used their Journal discount';

ALTER TABLE profiles ADD COLUMN IF NOT EXISTS journal_discount_used_at TIMESTAMPTZ;
COMMENT ON COLUMN profiles.journal_discount_used_at IS 'When Journal discount was used';

ALTER TABLE profiles ADD COLUMN IF NOT EXISTS journal_discount_source TEXT;
COMMENT ON COLUMN profiles.journal_discount_source IS 'Source of discount: top_secret, newsletter, promo';

-- PART 3: INDEXES
CREATE INDEX IF NOT EXISTS idx_profiles_top_secret_trial
ON profiles(top_secret_is_in_trial) WHERE top_secret_is_in_trial = TRUE;

CREATE INDEX IF NOT EXISTS idx_profiles_journal_discount_available
ON profiles(journal_discount_available) WHERE journal_discount_available = TRUE;





-- PART 4: FUNCTION - Start Top Secret Trial
DROP FUNCTION IF EXISTS start_top_secret_trial(UUID);

CREATE OR REPLACE FUNCTION start_top_secret_trial(p_user_id UUID)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_profile RECORD;
  v_trial_end TIMESTAMPTZ;
BEGIN
  SELECT top_secret_trial_used, top_secret_is_in_trial, top_secret_enabled
  INTO v_profile FROM profiles WHERE id = p_user_id;

  IF NOT FOUND THEN
    RETURN jsonb_build_object('success', false, 'error', 'User not found');
  END IF;

  IF v_profile.top_secret_trial_used THEN
    RETURN jsonb_build_object('success', false, 'error', 'Trial already used');
  END IF;

  IF v_profile.top_secret_enabled THEN
    RETURN jsonb_build_object('success', false, 'error', 'Already subscribed to Top Secret');
  END IF;

  v_trial_end := NOW() + INTERVAL '14 days';

  UPDATE profiles SET
    top_secret_is_in_trial = TRUE,
    top_secret_trial_used = TRUE,
    top_secret_trial_start_date = NOW(),
    top_secret_trial_ends_at = v_trial_end,
    top_secret_enabled = TRUE,
    top_secret_status = 'active',
    top_secret_started_at = NOW(),
    top_secret_expires_at = v_trial_end,
    journal_discount_available = TRUE,
    journal_discount_source = 'top_secret',
    updated_at = NOW()
  WHERE id = p_user_id;

  INSERT INTO subscription_events (user_id, event_type, new_plan, metadata)
  VALUES (p_user_id, 'trial_started', 'top_secret',
    jsonb_build_object('trial_days', 14, 'trial_ends_at', v_trial_end, 'source', 'post_signup'));

  RETURN jsonb_build_object('success', true, 'trial_ends_at', v_trial_end, 'journal_discount_enabled', true);
END;
$$;

-- PART 5: FUNCTION - Check and Expire Trials
DROP FUNCTION IF EXISTS check_expired_top_secret_trials();

CREATE OR REPLACE FUNCTION check_expired_top_secret_trials()
RETURNS INTEGER
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_expired_count INTEGER := 0;
  v_user RECORD;
BEGIN
  FOR v_user IN
    SELECT id, email, top_secret_trial_ends_at
    FROM profiles
    WHERE top_secret_is_in_trial = TRUE
      AND top_secret_trial_ends_at < NOW()
      AND top_secret_whop_membership_id IS NULL
  LOOP
    UPDATE profiles SET
      top_secret_is_in_trial = FALSE,
      top_secret_enabled = FALSE,
      top_secret_status = 'inactive',
      updated_at = NOW()
    WHERE id = v_user.id;

    INSERT INTO subscription_events (user_id, event_type, old_plan, metadata)
    VALUES (v_user.id, 'trial_expired', 'top_secret',
      jsonb_build_object('trial_ended_at', v_user.top_secret_trial_ends_at));

    v_expired_count := v_expired_count + 1;
  END LOOP;

  RETURN v_expired_count;
END;
$$;

-- PART 6: FUNCTION - Grant Journal Discount
DROP FUNCTION IF EXISTS grant_journal_discount(UUID, TEXT, INTEGER);

CREATE OR REPLACE FUNCTION grant_journal_discount(
  p_user_id UUID,
  p_source TEXT DEFAULT 'top_secret',
  p_percent INTEGER DEFAULT 25
)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_profile RECORD;
BEGIN
  SELECT journal_discount_available, journal_discount_used
  INTO v_profile FROM profiles WHERE id = p_user_id;

  IF NOT FOUND THEN
    RETURN jsonb_build_object('success', false, 'error', 'User not found');
  END IF;

  IF v_profile.journal_discount_used THEN
    RETURN jsonb_build_object('success', false, 'error', 'Discount already used');
  END IF;

  UPDATE profiles SET
    journal_discount_available = TRUE,
    journal_discount_percent = p_percent,
    journal_discount_source = p_source,
    updated_at = NOW()
  WHERE id = p_user_id;

  RETURN jsonb_build_object('success', true, 'discount_percent', p_percent, 'source', p_source);
END;
$$;

-- PART 7: FUNCTION - Use Journal Discount
DROP FUNCTION IF EXISTS use_journal_discount(UUID);

CREATE OR REPLACE FUNCTION use_journal_discount(p_user_id UUID)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_profile RECORD;
BEGIN
  SELECT journal_discount_available, journal_discount_used, journal_discount_percent
  INTO v_profile FROM profiles WHERE id = p_user_id;

  IF NOT FOUND THEN
    RETURN jsonb_build_object('success', false, 'error', 'User not found');
  END IF;

  IF NOT v_profile.journal_discount_available THEN
    RETURN jsonb_build_object('success', false, 'error', 'No discount available');
  END IF;

  IF v_profile.journal_discount_used THEN
    RETURN jsonb_build_object('success', false, 'error', 'Discount already used');
  END IF;

  UPDATE profiles SET
    journal_discount_used = TRUE,
    journal_discount_used_at = NOW(),
    updated_at = NOW()
  WHERE id = p_user_id;

  RETURN jsonb_build_object('success', true, 'discount_percent', v_profile.journal_discount_percent, 'used_at', NOW());
END;
$$;

-- PART 8: GRANT DISCOUNT TO EXISTING SUBSCRIBERS
UPDATE profiles SET
  journal_discount_available = TRUE,
  journal_discount_percent = 25,
  journal_discount_source = 'newsletter'
WHERE newsletter_enabled = TRUE
  AND (journal_discount_used IS NULL OR journal_discount_used = FALSE)
  AND (journal_discount_available IS NULL OR journal_discount_available = FALSE);

UPDATE profiles SET
  journal_discount_available = TRUE,
  journal_discount_percent = 25,
  journal_discount_source = 'top_secret'
WHERE top_secret_enabled = TRUE
  AND (journal_discount_used IS NULL OR journal_discount_used = FALSE)
  AND (journal_discount_available IS NULL OR journal_discount_available = FALSE);

-- PART 9: TRIGGER - Auto-grant discount on newsletter subscribe
DROP FUNCTION IF EXISTS auto_grant_journal_discount() CASCADE;

CREATE OR REPLACE FUNCTION auto_grant_journal_discount()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  IF NEW.newsletter_enabled = TRUE AND
     (OLD.newsletter_enabled IS NULL OR OLD.newsletter_enabled = FALSE) AND
     (NEW.journal_discount_used IS NULL OR NEW.journal_discount_used = FALSE) THEN
    NEW.journal_discount_available := TRUE;
    NEW.journal_discount_percent := 25;
    NEW.journal_discount_source := 'newsletter';
  END IF;

  IF NEW.top_secret_enabled = TRUE AND
     (OLD.top_secret_enabled IS NULL OR OLD.top_secret_enabled = FALSE) AND
     (NEW.journal_discount_used IS NULL OR NEW.journal_discount_used = FALSE) THEN
    NEW.journal_discount_available := TRUE;
    NEW.journal_discount_percent := 25;
    NEW.journal_discount_source := 'top_secret';
  END IF;

  RETURN NEW;
END;
$$;

DROP TRIGGER IF EXISTS trigger_auto_grant_journal_discount ON profiles;

CREATE TRIGGER trigger_auto_grant_journal_discount
  BEFORE UPDATE ON profiles
  FOR EACH ROW
  EXECUTE FUNCTION auto_grant_journal_discount();

-- PART 10: PERMISSIONS
GRANT EXECUTE ON FUNCTION start_top_secret_trial(UUID) TO service_role, authenticated;
GRANT EXECUTE ON FUNCTION check_expired_top_secret_trials() TO service_role;
GRANT EXECUTE ON FUNCTION grant_journal_discount(UUID, TEXT, INTEGER) TO service_role, authenticated;
GRANT EXECUTE ON FUNCTION use_journal_discount(UUID) TO service_role, authenticated;

-- PART 11: CREATE COUPON FOR JOURNAL DISCOUNT
INSERT INTO admin_coupons (
  code, name, description, discount_type, discount_percent, duration_type,
  is_active, applicable_plans, first_time_only, stackable_with_affiliate, priority
) VALUES (
  'TOPSECRET25',
  'Top Secret Subscriber Discount',
  '25% off first month of Trading Journal for Top Secret/Newsletter subscribers',
  'percentage',
  25,
  'first_payment_only',
  TRUE,
  ARRAY['basic_monthly', 'basic_yearly', 'premium_monthly', 'premium_yearly'],
  TRUE,
  FALSE,
  100
) ON CONFLICT (code) DO UPDATE SET
  is_active = TRUE,
  discount_percent = 25,
  updated_at = NOW();

-- VERIFICATION
SELECT
  CASE WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'profiles' AND column_name = 'top_secret_trial_used') THEN 'YES' ELSE 'NO' END as trial_used,
  CASE WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'profiles' AND column_name = 'top_secret_is_in_trial') THEN 'YES' ELSE 'NO' END as is_in_trial,
  CASE WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'profiles' AND column_name = 'journal_discount_available') THEN 'YES' ELSE 'NO' END as discount_available,
  CASE WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'profiles' AND column_name = 'journal_discount_used') THEN 'YES' ELSE 'NO' END as discount_used;
 -- =====================================================
-- FIX RLS FOR system_updates - COMPLETE v2.0
-- =====================================================
-- 1. service_role can INSERT (scheduler works)
-- 2. Admins can manage updates from frontend
-- 3. Users see updates based on their target_group
-- =====================================================

-- 1. DROP ALL EXISTING POLICIES
DROP POLICY IF EXISTS "Service role can manage system updates" ON system_updates;
DROP POLICY IF EXISTS "Users see relevant system updates" ON system_updates;
DROP POLICY IF EXISTS "Anyone can read active system updates" ON system_updates;
DROP POLICY IF EXISTS "service_role_full_access" ON system_updates;
DROP POLICY IF EXISTS "authenticated_select_filtered" ON system_updates;
DROP POLICY IF EXISTS "anon_select_public" ON system_updates;
DROP POLICY IF EXISTS "Admins can manage updates" ON system_updates;
DROP POLICY IF EXISTS "Users can read updates for their group" ON system_updates;
DROP POLICY IF EXISTS "admin_manage_updates" ON system_updates;

-- 2. CREATE 4 POLICIES

-- Policy 1: service_role FULL access (schedulers)
CREATE POLICY "service_role_full_access" ON system_updates
  FOR ALL TO service_role
  USING (true) WITH CHECK (true);

-- Policy 2: Admins manage updates from frontend
CREATE POLICY "admin_manage_updates" ON system_updates
  FOR ALL TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM profiles 
      WHERE id = auth.uid() 
      AND (role IN ('admin', 'super_admin') OR email = 'elad2550@gmail.com')
    )
  )
  WITH CHECK (
    EXISTS (
      SELECT 1 FROM profiles 
      WHERE id = auth.uid() 
      AND (role IN ('admin', 'super_admin') OR email = 'elad2550@gmail.com')
    )
  );

-- Policy 3: Users SELECT by target_group
CREATE POLICY "authenticated_select_filtered" ON system_updates
  FOR SELECT TO authenticated
  USING (
    is_active = true
    AND (expires_at IS NULL OR expires_at > NOW())
    AND (
      EXISTS (
        SELECT 1 FROM profiles 
        WHERE id = auth.uid() 
        AND (role IN ('admin', 'super_admin') OR email = 'elad2550@gmail.com')
      )
      OR target_group = 'all'
      OR (target_group = 'top_secret' AND EXISTS (
        SELECT 1 FROM profiles WHERE id = auth.uid() AND top_secret_enabled = true
      ))
      OR (target_group = 'newsletter' AND EXISTS (
        SELECT 1 FROM profiles WHERE id = auth.uid() 
        AND (newsletter_enabled = true OR newsletter_paid = true)
      ))
      OR (target_group = 'trading_journal' AND EXISTS (
        SELECT 1 FROM profiles WHERE id = auth.uid() AND account_type IN ('basic', 'premium', 'pro')
      ))
    )
  );

-- Policy 4: Anon sees public only
CREATE POLICY "anon_select_public" ON system_updates
  FOR SELECT TO anon
  USING (
    is_active = true
    AND target_group = 'all'
    AND (expires_at IS NULL OR expires_at > NOW())
  );

-- 3. GRANTS
GRANT SELECT, INSERT, UPDATE, DELETE ON system_updates TO service_role;
GRANT SELECT, INSERT, UPDATE, DELETE ON system_updates TO authenticated;
GRANT SELECT ON system_updates TO anon;

-- =====================================================
-- FIX: Remove problematic trigger on system_updates
-- =====================================================
-- This trigger was causing: "unrecognized configuration parameter 'app.settings.supabase_url'"
-- Email notifications are handled by scheduler.js instead of database triggers
-- =====================================================

-- Step 1: Drop the problematic trigger (all possible names)
DROP TRIGGER IF EXISTS trigger_notify_update_center_email ON system_updates;
DROP TRIGGER IF EXISTS notify_update_center_email_trigger ON system_updates;
DROP TRIGGER IF EXISTS on_system_update_notify ON system_updates;
DROP TRIGGER IF EXISTS on_system_update_insert ON system_updates;
DROP TRIGGER IF EXISTS notify_system_update ON system_updates;
DROP TRIGGER IF EXISTS send_notification_trigger ON system_updates;
DROP TRIGGER IF EXISTS webhook_trigger ON system_updates;
DROP TRIGGER IF EXISTS notify_update_center ON system_updates;

-- Step 2: Drop the problematic function
DROP FUNCTION IF EXISTS notify_update_center_email() CASCADE;

-- Step 3: Verification
DO $$
DECLARE
    v_trigger_count INTEGER;
BEGIN
    SELECT COUNT(*) INTO v_trigger_count
    FROM pg_trigger t
    JOIN pg_class c ON t.tgrelid = c.oid
    WHERE c.relname = 'system_updates'
    AND t.tgisinternal = false
    AND t.tgname NOT LIKE '%updated_at%';
    
    RAISE NOTICE '';
    RAISE NOTICE '=====================================================';
    RAISE NOTICE 'âœ… TRIGGER FIX APPLIED';
    RAISE NOTICE '=====================================================';
    RAISE NOTICE 'Remaining non-system triggers on system_updates: %', v_trigger_count;
    IF v_trigger_count = 0 THEN
        RAISE NOTICE 'âœ… All problematic triggers removed!';
    ELSE
        RAISE NOTICE 'âš ï¸ Some triggers remain - check manually';
    END IF;
    RAISE NOTICE '=====================================================';
END $$;

-- =====================================================
-- FIX: Add missing 'metadata' column to published_reports
-- =====================================================
-- Run this in Supabase SQL Editor
-- 
-- Issue from logs:
-- [Orchestrator v8.4] Publish to TOP SECRET failed: 
-- Could not find the 'metadata' column of 'published_reports' in the schema cache
-- =====================================================

-- Add metadata column if it doesn't exist
ALTER TABLE published_reports 
ADD COLUMN IF NOT EXISTS metadata JSONB DEFAULT '{}';

-- Add any other potentially missing columns
ALTER TABLE published_reports 
ADD COLUMN IF NOT EXISTS is_featured BOOLEAN DEFAULT false;

ALTER TABLE published_reports 
ADD COLUMN IF NOT EXISTS is_pinned BOOLEAN DEFAULT false;

ALTER TABLE published_reports 
ADD COLUMN IF NOT EXISTS original_report_id UUID;

ALTER TABLE published_reports 
ADD COLUMN IF NOT EXISTS pdf_storage_path TEXT;

ALTER TABLE published_reports 
ADD COLUMN IF NOT EXISTS pdf_url TEXT;

ALTER TABLE published_reports 
ADD COLUMN IF NOT EXISTS markdown_content TEXT;

ALTER TABLE published_reports 
ADD COLUMN IF NOT EXISTS html_content TEXT;

ALTER TABLE published_reports 
ADD COLUMN IF NOT EXISTS highlights JSONB;

ALTER TABLE published_reports 
ADD COLUMN IF NOT EXISTS key_metric_label TEXT;

ALTER TABLE published_reports 
ADD COLUMN IF NOT EXISTS key_metric_value TEXT;

ALTER TABLE published_reports 
ADD COLUMN IF NOT EXISTS key_insights_count INTEGER;

ALTER TABLE published_reports 
ADD COLUMN IF NOT EXISTS qa_score INTEGER;

ALTER TABLE published_reports 
ADD COLUMN IF NOT EXISTS comments_count INTEGER DEFAULT 0;

ALTER TABLE published_reports 
ADD COLUMN IF NOT EXISTS likes_count INTEGER DEFAULT 0;

ALTER TABLE published_reports 
ADD COLUMN IF NOT EXISTS ticker VARCHAR(20);

ALTER TABLE published_reports 
ADD COLUMN IF NOT EXISTS company_name TEXT;

ALTER TABLE published_reports 
ADD COLUMN IF NOT EXISTS sector TEXT;

ALTER TABLE published_reports 
ADD COLUMN IF NOT EXISTS report_month VARCHAR(10);

ALTER TABLE published_reports 
ADD COLUMN IF NOT EXISTS market_regime TEXT;

-- Create unique constraint for report_type + original_report_id (for upsert)
-- This prevents duplicates when publishing the same report multiple times
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_constraint 
    WHERE conname = 'published_reports_type_original_id_unique'
  ) THEN
    ALTER TABLE published_reports 
    ADD CONSTRAINT published_reports_type_original_id_unique 
    UNIQUE (report_type, original_report_id);
  END IF;
EXCEPTION
  WHEN duplicate_table THEN
    NULL;
  WHEN duplicate_object THEN
    NULL;
END $$;

-- Create indexes for better query performance
CREATE INDEX IF NOT EXISTS idx_published_reports_type 
ON published_reports(report_type);

CREATE INDEX IF NOT EXISTS idx_published_reports_published_at 
ON published_reports(published_at DESC);

CREATE INDEX IF NOT EXISTS idx_published_reports_ticker 
ON published_reports(ticker);

CREATE INDEX IF NOT EXISTS idx_published_reports_original_id 
ON published_reports(original_report_id);

CREATE INDEX IF NOT EXISTS idx_published_reports_featured 
ON published_reports(is_featured) WHERE is_featured = true;

-- Refresh schema cache
NOTIFY pgrst, 'reload schema';

-- Verify the columns exist
SELECT column_name, data_type, is_nullable 
FROM information_schema.columns 
WHERE table_name = 'published_reports'
ORDER BY ordinal_position;

-- =====================================================
-- END OF FINOTAUR DATABASE SCHEMA
-- =====================================================
-- =====================================================
-- WEEKLY REPORTS TABLE - MIGRATION
-- =====================================================
-- Run this in Supabase SQL Editor
-- This creates the missing weekly_reports table
-- =====================================================

-- ============================================
-- TABLE: weekly_reports
-- Main table for Weekly Tactical Review reports
-- ============================================
CREATE TABLE IF NOT EXISTS public.weekly_reports (
  id TEXT PRIMARY KEY,
  report_date DATE NOT NULL,
  report_title TEXT DEFAULT 'Weekly Tactical Review',
  
  -- Report Sections (JSONB)
  sections JSONB,
  summary JSONB,
  
  -- Charts (base64 or URLs)
  charts JSONB,
  
  -- Generated Content
  markdown_content TEXT,
  html_content TEXT,
  pdf_path TEXT,
  pdf_url TEXT,
  
  -- Executive Summary
  executive_summary JSONB,
  central_thesis TEXT,
  
  -- Processing Info
  processing_info JSONB,
  generation_duration_seconds INTEGER,
  
  -- Quality Assurance
  qa_score INTEGER DEFAULT 0,
  qa_passed BOOLEAN DEFAULT false,
  
  -- Status
  status TEXT DEFAULT 'completed',
  error_message TEXT,
  
  -- Timestamps
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- ============================================
-- INDEXES
-- ============================================
CREATE INDEX IF NOT EXISTS idx_weekly_reports_date ON weekly_reports(report_date DESC);
CREATE INDEX IF NOT EXISTS idx_weekly_reports_created ON weekly_reports(created_at DESC);
CREATE INDEX IF NOT EXISTS idx_weekly_reports_status ON weekly_reports(status);

-- ============================================
-- TRIGGER: Auto-update updated_at
-- ============================================
DROP TRIGGER IF EXISTS update_weekly_reports_updated_at ON weekly_reports;
CREATE TRIGGER update_weekly_reports_updated_at
  BEFORE UPDATE ON weekly_reports
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- ============================================
-- RLS POLICIES
-- ============================================
ALTER TABLE weekly_reports ENABLE ROW LEVEL SECURITY;

-- Drop ALL existing policies first (prevent duplicates)
DROP POLICY IF EXISTS "weekly_reports_service_all" ON weekly_reports;
DROP POLICY IF EXISTS "weekly_reports_authenticated_read" ON weekly_reports;
DROP POLICY IF EXISTS "weekly_reports_authenticated_write" ON weekly_reports;
DROP POLICY IF EXISTS "weekly_reports_authenticated_update" ON weekly_reports;
DROP POLICY IF EXISTS "weekly_reports_authenticated_delete" ON weekly_reports;

-- Service role full access
CREATE POLICY "weekly_reports_service_all" ON weekly_reports
  FOR ALL TO service_role
  USING (true) WITH CHECK (true);

-- Authenticated users can read
CREATE POLICY "weekly_reports_authenticated_read" ON weekly_reports
  FOR SELECT TO authenticated
  USING (true);

-- Authenticated users can write (for admin panel)
CREATE POLICY "weekly_reports_authenticated_write" ON weekly_reports
  FOR INSERT TO authenticated
  WITH CHECK (
    EXISTS (
      SELECT 1 FROM profiles
      WHERE id = auth.uid() AND role IN ('admin', 'super_admin')
    )
  );

-- Authenticated users can update
CREATE POLICY "weekly_reports_authenticated_update" ON weekly_reports
  FOR UPDATE TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM profiles
      WHERE id = auth.uid() AND role IN ('admin', 'super_admin')
    )
  )
  WITH CHECK (
    EXISTS (
      SELECT 1 FROM profiles
      WHERE id = auth.uid() AND role IN ('admin', 'super_admin')
    )
  );

-- ============================================
-- GRANTS
-- ============================================
GRANT SELECT, INSERT, UPDATE, DELETE ON weekly_reports TO authenticated;
GRANT ALL ON weekly_reports TO service_role;

-- ============================================
-- Auto-fill pdf_path trigger for weekly_reports
-- ============================================
CREATE OR REPLACE FUNCTION auto_fill_weekly_pdf_path()
RETURNS TRIGGER AS $$
BEGIN
  IF NEW.pdf_path IS NULL THEN
    NEW.pdf_path := 'weekly-reports/weekly-report-' || NEW.report_date || '.pdf';
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trigger_auto_fill_weekly_pdf_path ON weekly_reports;

CREATE TRIGGER trigger_auto_fill_weekly_pdf_path
  BEFORE INSERT OR UPDATE ON weekly_reports
  FOR EACH ROW
  EXECUTE FUNCTION auto_fill_weekly_pdf_path();

-- Fix existing weekly_reports with missing pdf_path
UPDATE weekly_reports 
SET 
  pdf_path = 'weekly-reports/weekly-report-' || report_date || '.pdf',
  updated_at = NOW()
WHERE pdf_path IS NULL OR pdf_path = '';

-- ============================================
-- TABLE: weekly_report_progress
-- Real-time progress tracking
-- ============================================
CREATE TABLE IF NOT EXISTS public.weekly_report_progress (
  report_id TEXT PRIMARY KEY,
  status TEXT NOT NULL DEFAULT 'running',
  progress INTEGER DEFAULT 0,
  current_phase TEXT,
  current_agent_id TEXT,
  current_agent_name TEXT,
  completed_agents TEXT[],
  total_agents INTEGER,
  elapsed_seconds INTEGER,
  error TEXT,
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- RLS
ALTER TABLE weekly_report_progress ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "weekly_progress_service_all" ON weekly_report_progress;
DROP POLICY IF EXISTS "weekly_progress_authenticated_all" ON weekly_report_progress;

CREATE POLICY "weekly_progress_service_all" ON weekly_report_progress
  FOR ALL TO service_role
  USING (true) WITH CHECK (true);

CREATE POLICY "weekly_progress_authenticated_all" ON weekly_report_progress
  FOR ALL TO authenticated
  USING (true) WITH CHECK (true);

GRANT ALL ON weekly_report_progress TO authenticated;
GRANT ALL ON weekly_report_progress TO service_role;

-- ============================================
-- TABLE: weekly_scheduler_logs
-- Scheduler execution logs
-- ============================================
CREATE TABLE IF NOT EXISTS public.weekly_scheduler_logs (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  job_type TEXT NOT NULL DEFAULT 'weekly_generation',
  status TEXT NOT NULL,
  report_id TEXT,
  report_date DATE,
  duration_ms INTEGER,
  error_message TEXT,
  metadata JSONB DEFAULT '{}',
  executed_at TIMESTAMPTZ DEFAULT NOW(),
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Indexes
CREATE INDEX IF NOT EXISTS idx_weekly_scheduler_logs_status ON weekly_scheduler_logs(status);
CREATE INDEX IF NOT EXISTS idx_weekly_scheduler_logs_executed ON weekly_scheduler_logs(executed_at DESC);

-- RLS
ALTER TABLE weekly_scheduler_logs ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "weekly_scheduler_logs_service_all" ON weekly_scheduler_logs;
DROP POLICY IF EXISTS "weekly_scheduler_logs_admin_read" ON weekly_scheduler_logs;

CREATE POLICY "weekly_scheduler_logs_service_all" ON weekly_scheduler_logs
  FOR ALL TO service_role
  USING (true) WITH CHECK (true);

CREATE POLICY "weekly_scheduler_logs_admin_read" ON weekly_scheduler_logs
  FOR SELECT TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM profiles
      WHERE id = auth.uid() AND role IN ('admin', 'super_admin')
    )
  );

GRANT ALL ON weekly_scheduler_logs TO service_role;
GRANT SELECT ON weekly_scheduler_logs TO authenticated;

-- ============================================
-- AUTO-PUBLISH TRIGGER FOR WEEKLY REPORTS
-- ============================================
DROP FUNCTION IF EXISTS auto_publish_weekly_report() CASCADE;

CREATE OR REPLACE FUNCTION auto_publish_weekly_report()
RETURNS TRIGGER AS $$
DECLARE
    v_existing_id UUID;
    v_is_deleted BOOLEAN;
BEGIN
    -- Only proceed if we have content
    IF NEW.markdown_content IS NULL OR LENGTH(NEW.markdown_content) < 100 THEN
        RETURN NEW;
    END IF;

    -- CHECK IF THIS REPORT WAS DELETED - DON'T RE-SYNC
    SELECT EXISTS (
        SELECT 1 FROM deleted_published_reports
        WHERE report_type = 'weekly' AND original_report_id = NEW.id
    ) INTO v_is_deleted;
    
    IF v_is_deleted THEN
        RETURN NEW;
    END IF;

    -- Check if already exists
    SELECT id INTO v_existing_id
    FROM published_reports
    WHERE original_report_id = NEW.id AND report_type = 'weekly';

    IF v_existing_id IS NOT NULL THEN
        -- UPDATE existing
        UPDATE published_reports
        SET 
            markdown_content = NEW.markdown_content,
            html_content = NEW.html_content,
            markdown_preview = LEFT(NEW.markdown_content, 500),
            pdf_url = NEW.pdf_url,
            pdf_storage_path = NEW.pdf_path,
            qa_score = NEW.qa_score,
            updated_at = NOW()
        WHERE id = v_existing_id;
        
        RAISE NOTICE '[AutoPublish] Updated Weekly report % in published_reports', NEW.id;
    ELSE
        -- INSERT new
        INSERT INTO published_reports (
            report_type,
            original_report_id,
            title,
            subtitle,
            markdown_content,
            html_content,
            markdown_preview,
            pdf_url,
            pdf_storage_path,
            highlights,
            key_metric_label,
            key_metric_value,
            qa_score,
            is_featured,
            is_pinned,
            target_group,
            published_at,
            created_at,
            updated_at
        ) VALUES (
            'weekly',
            NEW.id,
            'Weekly Tactical Review',
            TO_CHAR(NEW.report_date, 'Month DD, YYYY'),
            NEW.markdown_content,
            NEW.html_content,
            LEFT(NEW.markdown_content, 500),
            NEW.pdf_url,
            NEW.pdf_path,
            COALESCE(
                ARRAY(SELECT jsonb_array_elements_text(NEW.executive_summary->'key_points')),
                ARRAY['Weekly Market Analysis']::TEXT[]
            ),
            'Week',
            TO_CHAR(NEW.report_date, 'Mon DD'),
            NEW.qa_score,
            true,  -- is_featured
            false, -- is_pinned
            'top_secret',
            NOW(),
            NOW(),
            NOW()
        );
        
        RAISE NOTICE '[AutoPublish] Created Weekly report % in published_reports', NEW.id;
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trigger_auto_publish_weekly ON weekly_reports;

CREATE TRIGGER trigger_auto_publish_weekly
    AFTER INSERT OR UPDATE OF markdown_content, html_content
    ON weekly_reports
    FOR EACH ROW
    EXECUTE FUNCTION auto_publish_weekly_report();

-- ============================================
-- TABLE: daily_scheduler_logs
-- Scheduler execution logs for daily reports
-- ============================================
CREATE TABLE IF NOT EXISTS public.daily_scheduler_logs (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  job_type TEXT NOT NULL DEFAULT 'daily_generation',
  status TEXT NOT NULL,
  report_id TEXT,
  report_date DATE,
  duration_ms INTEGER,
  error_message TEXT,
  metadata JSONB DEFAULT '{}',
  executed_at TIMESTAMPTZ DEFAULT NOW(),
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Indexes
CREATE INDEX IF NOT EXISTS idx_daily_scheduler_logs_status ON daily_scheduler_logs(status);
CREATE INDEX IF NOT EXISTS idx_daily_scheduler_logs_executed ON daily_scheduler_logs(executed_at DESC);
CREATE INDEX IF NOT EXISTS idx_daily_scheduler_logs_date ON daily_scheduler_logs(report_date DESC);

-- RLS
ALTER TABLE daily_scheduler_logs ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "daily_scheduler_logs_service_all" ON daily_scheduler_logs;
CREATE POLICY "daily_scheduler_logs_service_all" ON daily_scheduler_logs
  FOR ALL TO service_role USING (true) WITH CHECK (true);

DROP POLICY IF EXISTS "daily_scheduler_logs_admin_read" ON daily_scheduler_logs;
CREATE POLICY "daily_scheduler_logs_admin_read" ON daily_scheduler_logs
  FOR SELECT TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM profiles
      WHERE id = auth.uid() AND role IN ('admin', 'super_admin')
    )
  );

GRANT ALL ON daily_scheduler_logs TO service_role;
GRANT SELECT ON daily_scheduler_logs TO authenticated;

-- ============================================
-- VERIFICATION
-- ============================================
DO $$
DECLARE
    v_table_exists BOOLEAN;
    v_progress_exists BOOLEAN;
    v_logs_exists BOOLEAN;
BEGIN
    SELECT EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_schema = 'public' AND table_name = 'weekly_reports'
    ) INTO v_table_exists;
    
    SELECT EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_schema = 'public' AND table_name = 'weekly_report_progress'
    ) INTO v_progress_exists;
    
    SELECT EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_schema = 'public' AND table_name = 'weekly_scheduler_logs'
    ) INTO v_logs_exists;
    
    RAISE NOTICE '';
    RAISE NOTICE '=====================================================';
    RAISE NOTICE 'âœ… WEEKLY REPORTS MIGRATION COMPLETE';
    RAISE NOTICE '=====================================================';
    RAISE NOTICE '';
    RAISE NOTICE 'Tables created:';
    RAISE NOTICE '  â€¢ weekly_reports: %', CASE WHEN v_table_exists THEN 'YES' ELSE 'NO' END;
    RAISE NOTICE '  â€¢ weekly_report_progress: %', CASE WHEN v_progress_exists THEN 'YES' ELSE 'NO' END;
    RAISE NOTICE '  â€¢ weekly_scheduler_logs: %', CASE WHEN v_logs_exists THEN 'YES' ELSE 'NO' END;
    RAISE NOTICE '';
    RAISE NOTICE 'Features:';
    RAISE NOTICE '  â€¢ RLS policies configured';
    RAISE NOTICE '  â€¢ Auto-publish trigger active';
    RAISE NOTICE '  â€¢ Grants applied';
    RAISE NOTICE '=====================================================';
END $$;

-- Show table structure
SELECT column_name, data_type, is_nullable
FROM information_schema.columns
WHERE table_name = 'weekly_reports'
ORDER BY ordinal_position;
-- =====================================================
-- FIX: Add proper UNIQUE CONSTRAINT for weekly reports upsert
-- =====================================================

-- First, remove duplicates if any exist
DELETE FROM published_reports a
USING published_reports b
WHERE a.id > b.id 
  AND a.report_type = b.report_type 
  AND a.original_report_id = b.original_report_id
  AND a.original_report_id IS NOT NULL;

-- Add the unique constraint (not just index)
ALTER TABLE published_reports 
DROP CONSTRAINT IF EXISTS published_reports_type_original_id_key;

ALTER TABLE published_reports 
ADD CONSTRAINT published_reports_type_original_id_key 
UNIQUE (report_type, original_report_id);

-- Verify
SELECT conname, contype 
FROM pg_constraint 
WHERE conrelid = 'published_reports'::regclass;

-- =====================================================
-- DAILY INTELLIGENCE REPORTS TABLE
-- =====================================================

-- 1. ×˜×‘×œ×” ×¨××©×™×ª ×œ×“×•×—×•×ª ×™×•××™×™×
CREATE TABLE IF NOT EXISTS public.daily_reports (
  id TEXT PRIMARY KEY,
  report_date DATE NOT NULL UNIQUE,
  report_title TEXT DEFAULT 'Daily Intelligence Report',
  
  -- Market Snapshot
  market_snapshot JSONB,
  locked_prices JSONB,
  
  -- Report Sections (JSONB)
  sections JSONB,
  
  -- Generated Content
  markdown_content TEXT,
  html_content TEXT,
  pdf_path TEXT,
  pdf_url TEXT,
  
  -- Quality
  qa_score INTEGER DEFAULT 0,
  
  -- Status
  status TEXT DEFAULT 'completed',
  
  -- Timestamps
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Indexes
CREATE INDEX IF NOT EXISTS idx_daily_reports_date ON daily_reports(report_date DESC);
CREATE INDEX IF NOT EXISTS idx_daily_reports_created ON daily_reports(created_at DESC);

-- Unique constraint to prevent duplicate dates
ALTER TABLE daily_reports 
DROP CONSTRAINT IF EXISTS daily_reports_report_date_unique;
ALTER TABLE daily_reports 
ADD CONSTRAINT daily_reports_report_date_unique UNIQUE (report_date);

-- Trigger for updated_at
DROP TRIGGER IF EXISTS update_daily_reports_updated_at ON daily_reports;
CREATE TRIGGER update_daily_reports_updated_at
  BEFORE UPDATE ON daily_reports
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- Enable replica identity for real-time
ALTER TABLE daily_reports REPLICA IDENTITY FULL;

-- RLS
ALTER TABLE daily_reports ENABLE ROW LEVEL SECURITY;

-- Drop existing policies first
DROP POLICY IF EXISTS "daily_reports_service_all" ON daily_reports;
DROP POLICY IF EXISTS "daily_reports_authenticated_read" ON daily_reports;
DROP POLICY IF EXISTS "daily_reports_admin_insert" ON daily_reports;
DROP POLICY IF EXISTS "daily_reports_admin_update" ON daily_reports;

-- Service role full access
CREATE POLICY "daily_reports_service_all" ON daily_reports
  FOR ALL TO service_role USING (true) WITH CHECK (true);

-- Authenticated users can READ
CREATE POLICY "daily_reports_authenticated_read" ON daily_reports
  FOR SELECT TO authenticated USING (true);

-- Admins can INSERT
CREATE POLICY "daily_reports_admin_insert" ON daily_reports
  FOR INSERT TO authenticated
  WITH CHECK (
    EXISTS (
      SELECT 1 FROM profiles
      WHERE id = auth.uid() 
      AND (role IN ('admin', 'super_admin') OR email = 'elad2550@gmail.com')
    )
  );

-- Admins can UPDATE
CREATE POLICY "daily_reports_admin_update" ON daily_reports
  FOR UPDATE TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM profiles
      WHERE id = auth.uid() 
      AND (role IN ('admin', 'super_admin') OR email = 'elad2550@gmail.com')
    )
  )
  WITH CHECK (
    EXISTS (
      SELECT 1 FROM profiles
      WHERE id = auth.uid() 
      AND (role IN ('admin', 'super_admin') OR email = 'elad2550@gmail.com')
    )
  );

GRANT ALL ON daily_reports TO service_role;
GRANT SELECT, INSERT, UPDATE ON daily_reports TO authenticated;

-- Auto-fill pdf_path trigger
CREATE OR REPLACE FUNCTION auto_fill_pdf_path()
RETURNS TRIGGER AS $$
BEGIN
  -- ×× pdf_path ×¨×™×§, ××œ× ××•×ª×• ××•×˜×•××˜×™×ª
  IF NEW.pdf_path IS NULL THEN
    NEW.pdf_path := 'daily-reports/daily-report-' || NEW.report_date || '.pdf';
  END IF;
  
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trigger_auto_fill_pdf_path ON daily_reports;

CREATE TRIGGER trigger_auto_fill_pdf_path
  BEFORE INSERT OR UPDATE ON daily_reports
  FOR EACH ROW
  EXECUTE FUNCTION auto_fill_pdf_path();

-- 2. Auto-publish trigger
DROP FUNCTION IF EXISTS auto_publish_daily_report() CASCADE;

CREATE OR REPLACE FUNCTION auto_publish_daily_report()
RETURNS TRIGGER AS $$
DECLARE
    v_existing_id UUID;
    v_is_deleted BOOLEAN := FALSE;
BEGIN
    -- Only proceed if we have content
    IF NEW.markdown_content IS NULL OR LENGTH(NEW.markdown_content) < 100 THEN
        RETURN NEW;
    END IF;

    -- Check if this report was deleted - DON'T RE-SYNC
    SELECT EXISTS (
        SELECT 1 FROM deleted_published_reports
        WHERE report_type = 'daily' AND original_report_id = NEW.id
    ) INTO v_is_deleted;
    
    IF v_is_deleted THEN
        RAISE NOTICE '[AutoPublish] Daily report % was deleted by admin - skipping sync', NEW.id;
        RETURN NEW;
    END IF;

    -- Check if already exists in published_reports
    SELECT id INTO v_existing_id
    FROM published_reports
    WHERE original_report_id = NEW.id AND report_type = 'daily';

    IF v_existing_id IS NOT NULL THEN
        -- UPDATE existing
        UPDATE published_reports
        SET 
            title = COALESCE(NEW.report_title, 'Daily Intelligence Report'),
            subtitle = TO_CHAR(NEW.report_date, 'FMMonth DD, YYYY'),
            markdown_content = NEW.markdown_content,
            html_content = NEW.html_content,
            markdown_preview = LEFT(NEW.markdown_content, 500),
            pdf_storage_path = NEW.pdf_path,
            qa_score = NEW.qa_score,
            updated_at = NOW()
        WHERE id = v_existing_id;
        
        RAISE NOTICE '[AutoPublish] Updated Daily report % in published_reports', NEW.id;
    ELSE
        -- INSERT new
        INSERT INTO published_reports (
            report_type,
            original_report_id,
            title,
            subtitle,
            markdown_content,
            html_content,
            markdown_preview,
            pdf_storage_path,
            highlights,
            key_metric_label,
            key_metric_value,
            qa_score,
            is_featured,
            is_pinned,
            target_group,
            published_at,
            created_at,
            updated_at
        ) VALUES (
            'daily',
            NEW.id,
            COALESCE(NEW.report_title, 'Daily Intelligence Report'),
            TO_CHAR(NEW.report_date, 'FMMonth DD, YYYY'),
            NEW.markdown_content,
            NEW.html_content,
            LEFT(NEW.markdown_content, 500),
            NEW.pdf_path,
            ARRAY['Daily Market Analysis']::TEXT[],
            'Date',
            TO_CHAR(NEW.report_date, 'Mon DD'),
            NEW.qa_score,
            true,  -- is_featured
            false, -- is_pinned
            'top_secret',
            NOW(),
            NOW(),
            NOW()
        );
        
        RAISE NOTICE '[AutoPublish] Created Daily report % in published_reports', NEW.id;
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Create trigger
DROP TRIGGER IF EXISTS trigger_auto_publish_daily ON daily_reports;

CREATE TRIGGER trigger_auto_publish_daily
    AFTER INSERT OR UPDATE OF markdown_content, html_content, pdf_path
    ON daily_reports
    FOR EACH ROW
    EXECUTE FUNCTION auto_publish_daily_report();

-- 3. Add 'daily' to report_type constraint
ALTER TABLE published_reports 
DROP CONSTRAINT IF EXISTS published_reports_report_type_check;

-- No constraint needed - the column accepts any text

-- 4. ×¤×•× ×§×¦×™×” ×œ×©×œ×™×¤×ª 2 ×”×“×•×—×•×ª ×”××—×¨×•× ×™×
-- CRITICAL: Sort by report_date DESC, then created_at DESC
-- This ensures proper ordering even if multiple reports exist

DROP FUNCTION IF EXISTS get_latest_daily_reports(INT);

DROP FUNCTION IF EXISTS get_latest_daily_reports(INT);

CREATE OR REPLACE FUNCTION get_latest_daily_reports(p_count INT DEFAULT 2)
RETURNS TABLE (
    id TEXT,
    report_date DATE,
    report_title TEXT,
    markdown_content TEXT,
    html_content TEXT,
    pdf_url TEXT,
    pdf_path TEXT,
    qa_score INTEGER,
    created_at TIMESTAMPTZ,
    updated_at TIMESTAMPTZ
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        dr.id,
        dr.report_date,
        dr.report_title,
        dr.markdown_content,
        dr.html_content,
        dr.pdf_url,
        dr.pdf_path,
        dr.qa_score,
        dr.created_at,
        dr.updated_at
    FROM daily_reports dr
    WHERE dr.status = 'completed'
    ORDER BY dr.report_date DESC, dr.updated_at DESC
    LIMIT p_count;
END;
$$ LANGUAGE plpgsql;

GRANT EXECUTE ON FUNCTION get_latest_daily_reports(INT) TO authenticated;
GRANT EXECUTE ON FUNCTION get_latest_daily_reports(INT) TO service_role;

-- Grant permissions
GRANT EXECUTE ON FUNCTION get_latest_daily_reports(INT) TO authenticated;
GRANT EXECUTE ON FUNCTION get_latest_daily_reports(INT) TO service_role;
-- 3. FUNCTION: Get latest weekly report
CREATE OR REPLACE FUNCTION get_latest_weekly_report()
RETURNS TABLE (
    id TEXT,
    report_date DATE,
    report_title TEXT,
    markdown_content TEXT,
    html_content TEXT,
    pdf_url TEXT,
    qa_score INTEGER,
    created_at TIMESTAMPTZ
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        wr.id,
        wr.report_date,
        wr.report_title,
        wr.markdown_content,
        wr.html_content,
        wr.pdf_url,
        wr.qa_score,
        wr.created_at
    FROM weekly_reports wr
    WHERE wr.status = 'completed'
    ORDER BY wr.report_date DESC
    LIMIT 1;
END;
$$ LANGUAGE plpgsql;

GRANT EXECUTE ON FUNCTION get_latest_weekly_report() TO authenticated;

GRANT EXECUTE ON FUNCTION get_latest_daily_reports(INT) TO authenticated;

-- ============================================================================
-- FIX: Ensure daily_reports and weekly_reports have correct ID types
-- ============================================================================
-- Note: If tables were created with TEXT id, this ensures compatibility
-- The get_latest functions return the correct types

-- Add pdf_path column if missing (for signed URL generation)
ALTER TABLE daily_reports ADD COLUMN IF NOT EXISTS pdf_path TEXT;
ALTER TABLE weekly_reports ADD COLUMN IF NOT EXISTS pdf_path TEXT;

-- Add metadata column if missing
ALTER TABLE daily_reports ADD COLUMN IF NOT EXISTS metadata JSONB DEFAULT '{}'::jsonb;
ALTER TABLE weekly_reports ADD COLUMN IF NOT EXISTS metadata JSONB DEFAULT '{}'::jsonb;

-- ============================================================================
-- STORAGE BUCKET SETUP REMINDER
-- ============================================================================
-- Run this in the Storage section of Supabase Dashboard:
-- 
-- 1. Create a bucket named 'reports' (if it doesn't exist)
-- 2. Set it to PUBLIC if you want direct URLs, or PRIVATE for signed URLs
-- 3. Policies should already exist from earlier in this file
-- ============================================================================
-- VERIFY DAILY/WEEKLY SETUP
-- ============================================================================
DO $$
BEGIN
    RAISE NOTICE '';
    RAISE NOTICE '=====================================================';
    RAISE NOTICE 'âœ… DAILY & WEEKLY REPORTS TABLES VERIFIED';
    RAISE NOTICE '=====================================================';
    RAISE NOTICE '';
    RAISE NOTICE 'Tables: daily_reports, weekly_reports';
    RAISE NOTICE 'Functions: get_latest_daily_reports(), get_latest_weekly_report()';
    RAISE NOTICE 'Storage bucket: reports (for PDF files)';
    RAISE NOTICE '=====================================================';
END $$;

-- =====================================================
-- FIX EXISTING DAILY REPORTS - SQL MIGRATION
-- =====================================================
-- Run this in Supabase SQL Editor
-- This fixes existing daily_reports records that have:
-- - pdf_url = '/api/newsletter/pdf' (wrong value)
-- - pdf_path = null (missing)
-- =====================================================

-- Step 1: Check current state
SELECT 
    id,
    report_date,
    report_title,
    pdf_url,
    pdf_path,
    LENGTH(markdown_content) as content_length,
    qa_score,
    status
FROM daily_reports
ORDER BY report_date DESC
LIMIT 10;

-- Step 2: Fix pdf_path for existing reports (CRITICAL!)
-- This sets pdf_path to the correct Storage path format
UPDATE daily_reports
SET 
    pdf_path = 'daily-reports/daily-report-' || report_date::TEXT || '.pdf',
    updated_at = NOW()
WHERE 
    pdf_path IS NULL 
    OR pdf_path = ''
    OR pdf_path LIKE '%/api/%';

-- Step 3: Verify the fix
SELECT 
    id,
    report_date,
    pdf_path,
    pdf_url,
    status
FROM daily_reports
WHERE report_date >= '2026-01-01'
ORDER BY report_date DESC;

-- Step 4: Check if PDFs exist in Storage (run this separately)
-- This query just shows what SHOULD be in Storage
SELECT 
    report_date,
    pdf_path,
    'Check in Storage: reports/' || pdf_path as storage_check_location
FROM daily_reports
WHERE pdf_path IS NOT NULL
ORDER BY report_date DESC
LIMIT 10;

-- =====================================================
-- IMPORTANT: After running this SQL, you need to:
-- 1. Manually upload the PDFs to Supabase Storage
-- 2. Or re-generate the reports using the fixed scheduler
-- =====================================================

-- Step 5: Add missing columns if they don't exist
ALTER TABLE daily_reports ADD COLUMN IF NOT EXISTS pdf_path TEXT;
ALTER TABLE daily_reports ADD COLUMN IF NOT EXISTS status TEXT DEFAULT 'completed';
ALTER TABLE daily_reports ADD COLUMN IF NOT EXISTS market_snapshot JSONB;
ALTER TABLE daily_reports ADD COLUMN IF NOT EXISTS locked_prices JSONB;
ALTER TABLE daily_reports ADD COLUMN IF NOT EXISTS metadata JSONB DEFAULT '{}'::jsonb;

-- Step 6: Verification
DO $$
DECLARE
    v_total INTEGER;
    v_with_path INTEGER;
    v_without_path INTEGER;
BEGIN
    SELECT COUNT(*) INTO v_total FROM daily_reports;
    SELECT COUNT(*) INTO v_with_path FROM daily_reports WHERE pdf_path IS NOT NULL AND pdf_path != '';
    SELECT COUNT(*) INTO v_without_path FROM daily_reports WHERE pdf_path IS NULL OR pdf_path = '';
    
    RAISE NOTICE '';
    RAISE NOTICE '=====================================================';
    RAISE NOTICE 'âœ… DAILY REPORTS FIX COMPLETE';
    RAISE NOTICE '=====================================================';
    RAISE NOTICE '';
    RAISE NOTICE 'Total reports: %', v_total;
    RAISE NOTICE 'With pdf_path: %', v_with_path;
    RAISE NOTICE 'Without pdf_path: %', v_without_path;
    RAISE NOTICE '';
    RAISE NOTICE 'NEXT STEPS:';
    RAISE NOTICE '1. Check if PDFs exist in Storage bucket "reports"';
    RAISE NOTICE '2. If not, re-generate reports with fixed scheduler';
    RAISE NOTICE '3. Or manually upload PDFs to: daily-reports/daily-report-YYYY-MM-DD.pdf';
    RAISE NOTICE '=====================================================';
END $$;



-- =====================================================
-- US MARKET HOLIDAYS - DATABASE SCHEMA v1.0
-- =====================================================
-- ğŸ“… Complete holiday management for Finotaur
-- 
-- Features:
--   - All US market holidays (2024-2035)
--   - Early closing days
--   - Helper functions for queries
--   - Auto-update triggers
-- =====================================================

-- =====================================================
-- TABLE: us_market_holidays
-- =====================================================

CREATE TABLE IF NOT EXISTS us_market_holidays (
  id SERIAL PRIMARY KEY,
  date DATE NOT NULL UNIQUE,
  name VARCHAR(100) NOT NULL,
  type VARCHAR(20) NOT NULL CHECK (type IN ('full_close', 'early_close')),
  close_time VARCHAR(20),
  original_date DATE,
  is_observed BOOLEAN DEFAULT false,
  year INTEGER NOT NULL,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Add comments
COMMENT ON TABLE us_market_holidays IS 'US stock market holidays and early closing days';
COMMENT ON COLUMN us_market_holidays.type IS 'full_close = markets closed all day, early_close = markets close at 1:00 PM ET';
COMMENT ON COLUMN us_market_holidays.is_observed IS 'True if holiday falls on weekend and is observed on adjacent weekday';

-- =====================================================
-- INDEXES
-- =====================================================

CREATE INDEX IF NOT EXISTS idx_holidays_date ON us_market_holidays(date);
CREATE INDEX IF NOT EXISTS idx_holidays_year ON us_market_holidays(year);
CREATE INDEX IF NOT EXISTS idx_holidays_type ON us_market_holidays(type);

-- =====================================================
-- TRIGGER: auto-update updated_at
-- Using existing update_updated_at_column() function
-- =====================================================

DROP TRIGGER IF EXISTS holidays_updated_at ON us_market_holidays;
CREATE TRIGGER holidays_updated_at
  BEFORE UPDATE ON us_market_holidays
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();

-- =====================================================
-- HELPER FUNCTIONS
-- =====================================================

-- Check if a date is a market holiday
CREATE OR REPLACE FUNCTION is_market_holiday(check_date DATE)
RETURNS TABLE(
  is_holiday BOOLEAN, 
  holiday_name VARCHAR, 
  holiday_type VARCHAR, 
  close_time VARCHAR
) AS $$
BEGIN
  RETURN QUERY
  SELECT 
    TRUE as is_holiday,
    h.name as holiday_name,
    h.type as holiday_type,
    h.close_time
  FROM us_market_holidays h
  WHERE h.date = check_date;
  
  IF NOT FOUND THEN
    RETURN QUERY SELECT FALSE, NULL::VARCHAR, NULL::VARCHAR, NULL::VARCHAR;
  END IF;
END;
$$ LANGUAGE plpgsql;

-- Get next trading day after a given date
CREATE OR REPLACE FUNCTION get_next_trading_day(from_date DATE)
RETURNS DATE AS $$
DECLARE
  next_date DATE := from_date + 1;
  max_iterations INTEGER := 14;
  iteration INTEGER := 0;
BEGIN
  WHILE iteration < max_iterations LOOP
    IF EXTRACT(DOW FROM next_date) IN (0, 6) THEN
      next_date := next_date + 1;
      iteration := iteration + 1;
      CONTINUE;
    END IF;
    
    IF EXISTS (SELECT 1 FROM us_market_holidays WHERE date = next_date AND type = 'full_close') THEN
      next_date := next_date + 1;
      iteration := iteration + 1;
      CONTINUE;
    END IF;
    
    RETURN next_date;
  END LOOP;
  
  RETURN from_date + 1;
END;
$$ LANGUAGE plpgsql;

-- Check if daily report should be generated
CREATE OR REPLACE FUNCTION should_generate_daily_report(check_date DATE DEFAULT CURRENT_DATE)
RETURNS TABLE(
  should_generate BOOLEAN, 
  reason VARCHAR, 
  next_trading_day DATE,
  is_early_close BOOLEAN,
  early_close_time VARCHAR
) AS $$
DECLARE
  day_of_week INTEGER;
  holiday_rec RECORD;
BEGIN
  day_of_week := EXTRACT(DOW FROM check_date);
  
  IF day_of_week IN (0, 6) THEN
    RETURN QUERY SELECT 
      FALSE, 
      'Weekend'::VARCHAR, 
      get_next_trading_day(check_date),
      FALSE,
      NULL::VARCHAR;
    RETURN;
  END IF;
  
  SELECT * INTO holiday_rec 
  FROM us_market_holidays 
  WHERE date = check_date AND type = 'full_close';
  
  IF FOUND THEN
    RETURN QUERY SELECT 
      FALSE, 
      holiday_rec.name::VARCHAR, 
      get_next_trading_day(check_date),
      FALSE,
      NULL::VARCHAR;
    RETURN;
  END IF;
  
  SELECT * INTO holiday_rec 
  FROM us_market_holidays 
  WHERE date = check_date AND type = 'early_close';
  
  IF FOUND THEN
    RETURN QUERY SELECT 
      TRUE, 
      holiday_rec.name::VARCHAR, 
      NULL::DATE,
      TRUE,
      holiday_rec.close_time::VARCHAR;
    RETURN;
  END IF;
  
  RETURN QUERY SELECT 
    TRUE, 
    NULL::VARCHAR, 
    NULL::DATE,
    FALSE,
    NULL::VARCHAR;
END;
$$ LANGUAGE plpgsql;

-- Get holidays for a week (for Weekly Report)
CREATE OR REPLACE FUNCTION get_week_holidays(week_start DATE)
RETURNS TABLE(
  date DATE,
  name VARCHAR,
  type VARCHAR,
  close_time VARCHAR,
  day_name VARCHAR
) AS $$
DECLARE
  monday DATE;
  friday DATE;
BEGIN
  monday := week_start - (EXTRACT(DOW FROM week_start)::INTEGER - 1);
  IF EXTRACT(DOW FROM week_start) = 0 THEN
    monday := week_start + 1;
  END IF;
  friday := monday + 4;
  
  RETURN QUERY
  SELECT 
    h.date,
    h.name,
    h.type,
    h.close_time,
    CASE EXTRACT(DOW FROM h.date)
      WHEN 1 THEN 'Monday'
      WHEN 2 THEN 'Tuesday'
      WHEN 3 THEN 'Wednesday'
      WHEN 4 THEN 'Thursday'
      WHEN 5 THEN 'Friday'
    END::VARCHAR as day_name
  FROM us_market_holidays h
  WHERE h.date BETWEEN monday AND friday
  ORDER BY h.date;
END;
$$ LANGUAGE plpgsql;

-- =====================================================
-- VIEWS
-- =====================================================

CREATE OR REPLACE VIEW upcoming_holidays AS
SELECT 
  date,
  name,
  type,
  close_time,
  CASE EXTRACT(DOW FROM date)
    WHEN 0 THEN 'Sunday'
    WHEN 1 THEN 'Monday'
    WHEN 2 THEN 'Tuesday'
    WHEN 3 THEN 'Wednesday'
    WHEN 4 THEN 'Thursday'
    WHEN 5 THEN 'Friday'
    WHEN 6 THEN 'Saturday'
  END as day_name,
  date - CURRENT_DATE as days_until,
  year
FROM us_market_holidays
WHERE date >= CURRENT_DATE
ORDER BY date
LIMIT 30;

CREATE OR REPLACE VIEW current_year_holidays AS
SELECT 
  date,
  name,
  type,
  close_time,
  CASE EXTRACT(DOW FROM date)
    WHEN 0 THEN 'Sunday'
    WHEN 1 THEN 'Monday'
    WHEN 2 THEN 'Tuesday'
    WHEN 3 THEN 'Wednesday'
    WHEN 4 THEN 'Thursday'
    WHEN 5 THEN 'Friday'
    WHEN 6 THEN 'Saturday'
  END as day_name,
  is_observed
FROM us_market_holidays
WHERE year = EXTRACT(YEAR FROM CURRENT_DATE)
ORDER BY date;

-- =====================================================
-- DATA: INSERT ALL HOLIDAYS (2024-2035)
-- =====================================================

DELETE FROM us_market_holidays WHERE year >= 2024 AND year <= 2035;

INSERT INTO us_market_holidays (date, name, type, close_time, original_date, is_observed, year) VALUES
-- 2024
('2024-01-01', 'New Year''s Day', 'full_close', NULL, '2024-01-01', false, 2024),
('2024-01-15', 'Martin Luther King Jr. Day', 'full_close', NULL, '2024-01-15', false, 2024),
('2024-02-19', 'Presidents'' Day', 'full_close', NULL, '2024-02-19', false, 2024),
('2024-03-29', 'Good Friday', 'full_close', NULL, '2024-03-29', false, 2024),
('2024-05-27', 'Memorial Day', 'full_close', NULL, '2024-05-27', false, 2024),
('2024-06-19', 'Juneteenth', 'full_close', NULL, '2024-06-19', false, 2024),
('2024-07-04', 'Independence Day', 'full_close', NULL, '2024-07-04', false, 2024),
('2024-07-03', 'Day Before Independence Day', 'early_close', '1:00 PM ET', '2024-07-03', false, 2024),
('2024-09-02', 'Labor Day', 'full_close', NULL, '2024-09-02', false, 2024),
('2024-11-28', 'Thanksgiving Day', 'full_close', NULL, '2024-11-28', false, 2024),
('2024-11-29', 'Day After Thanksgiving', 'early_close', '1:00 PM ET', '2024-11-29', false, 2024),
('2024-12-25', 'Christmas Day', 'full_close', NULL, '2024-12-25', false, 2024),
('2024-12-24', 'Christmas Eve', 'early_close', '1:00 PM ET', '2024-12-24', false, 2024),
-- 2025
('2025-01-01', 'New Year''s Day', 'full_close', NULL, '2025-01-01', false, 2025),
('2025-01-20', 'Martin Luther King Jr. Day', 'full_close', NULL, '2025-01-20', false, 2025),
('2025-02-17', 'Presidents'' Day', 'full_close', NULL, '2025-02-17', false, 2025),
('2025-04-18', 'Good Friday', 'full_close', NULL, '2025-04-18', false, 2025),
('2025-05-26', 'Memorial Day', 'full_close', NULL, '2025-05-26', false, 2025),
('2025-06-19', 'Juneteenth', 'full_close', NULL, '2025-06-19', false, 2025),
('2025-07-04', 'Independence Day', 'full_close', NULL, '2025-07-04', false, 2025),
('2025-07-03', 'Day Before Independence Day', 'early_close', '1:00 PM ET', '2025-07-03', false, 2025),
('2025-09-01', 'Labor Day', 'full_close', NULL, '2025-09-01', false, 2025),
('2025-11-27', 'Thanksgiving Day', 'full_close', NULL, '2025-11-27', false, 2025),
('2025-11-28', 'Day After Thanksgiving', 'early_close', '1:00 PM ET', '2025-11-28', false, 2025),
('2025-12-25', 'Christmas Day', 'full_close', NULL, '2025-12-25', false, 2025),
('2025-12-24', 'Christmas Eve', 'early_close', '1:00 PM ET', '2025-12-24', false, 2025),
-- 2026
('2026-01-01', 'New Year''s Day', 'full_close', NULL, '2026-01-01', false, 2026),
('2026-01-19', 'Martin Luther King Jr. Day', 'full_close', NULL, '2026-01-19', false, 2026),
('2026-02-16', 'Presidents'' Day', 'full_close', NULL, '2026-02-16', false, 2026),
('2026-04-03', 'Good Friday', 'full_close', NULL, '2026-04-03', false, 2026),
('2026-05-25', 'Memorial Day', 'full_close', NULL, '2026-05-25', false, 2026),
('2026-06-19', 'Juneteenth', 'full_close', NULL, '2026-06-19', false, 2026),
('2026-07-03', 'Independence Day', 'full_close', NULL, '2026-07-04', true, 2026),
('2026-07-02', 'Day Before Independence Day', 'early_close', '1:00 PM ET', '2026-07-02', false, 2026),
('2026-09-07', 'Labor Day', 'full_close', NULL, '2026-09-07', false, 2026),
('2026-11-26', 'Thanksgiving Day', 'full_close', NULL, '2026-11-26', false, 2026),
('2026-11-27', 'Day After Thanksgiving', 'early_close', '1:00 PM ET', '2026-11-27', false, 2026),
('2026-12-25', 'Christmas Day', 'full_close', NULL, '2026-12-25', false, 2026),
('2026-12-24', 'Christmas Eve', 'early_close', '1:00 PM ET', '2026-12-24', false, 2026),
-- 2027-2035 (continuing...)
('2027-01-01', 'New Year''s Day', 'full_close', NULL, '2027-01-01', false, 2027),
('2027-01-18', 'Martin Luther King Jr. Day', 'full_close', NULL, '2027-01-18', false, 2027),
('2027-02-15', 'Presidents'' Day', 'full_close', NULL, '2027-02-15', false, 2027),
('2027-03-26', 'Good Friday', 'full_close', NULL, '2027-03-26', false, 2027),
('2027-05-31', 'Memorial Day', 'full_close', NULL, '2027-05-31', false, 2027),
('2027-06-18', 'Juneteenth', 'full_close', NULL, '2027-06-19', true, 2027),
('2027-07-05', 'Independence Day', 'full_close', NULL, '2027-07-04', true, 2027),
('2027-09-06', 'Labor Day', 'full_close', NULL, '2027-09-06', false, 2027),
('2027-11-25', 'Thanksgiving Day', 'full_close', NULL, '2027-11-25', false, 2027),
('2027-11-26', 'Day After Thanksgiving', 'early_close', '1:00 PM ET', '2027-11-26', false, 2027),
('2027-12-24', 'Christmas Day', 'full_close', NULL, '2027-12-25', true, 2027),
-- 2028
('2028-01-03', 'New Year''s Day', 'full_close', NULL, '2028-01-01', true, 2028),
('2028-01-17', 'Martin Luther King Jr. Day', 'full_close', NULL, '2028-01-17', false, 2028),
('2028-02-21', 'Presidents'' Day', 'full_close', NULL, '2028-02-21', false, 2028),
('2028-04-14', 'Good Friday', 'full_close', NULL, '2028-04-14', false, 2028),
('2028-05-29', 'Memorial Day', 'full_close', NULL, '2028-05-29', false, 2028),
('2028-06-19', 'Juneteenth', 'full_close', NULL, '2028-06-19', false, 2028),
('2028-07-04', 'Independence Day', 'full_close', NULL, '2028-07-04', false, 2028),
('2028-07-03', 'Day Before Independence Day', 'early_close', '1:00 PM ET', '2028-07-03', false, 2028),
('2028-09-04', 'Labor Day', 'full_close', NULL, '2028-09-04', false, 2028),
('2028-11-23', 'Thanksgiving Day', 'full_close', NULL, '2028-11-23', false, 2028),
('2028-11-24', 'Day After Thanksgiving', 'early_close', '1:00 PM ET', '2028-11-24', false, 2028),
('2028-12-25', 'Christmas Day', 'full_close', NULL, '2028-12-25', false, 2028),
-- 2029
('2029-01-01', 'New Year''s Day', 'full_close', NULL, '2029-01-01', false, 2029),
('2029-01-15', 'Martin Luther King Jr. Day', 'full_close', NULL, '2029-01-15', false, 2029),
('2029-02-19', 'Presidents'' Day', 'full_close', NULL, '2029-02-19', false, 2029),
('2029-03-30', 'Good Friday', 'full_close', NULL, '2029-03-30', false, 2029),
('2029-05-28', 'Memorial Day', 'full_close', NULL, '2029-05-28', false, 2029),
('2029-06-19', 'Juneteenth', 'full_close', NULL, '2029-06-19', false, 2029),
('2029-07-04', 'Independence Day', 'full_close', NULL, '2029-07-04', false, 2029),
('2029-07-03', 'Day Before Independence Day', 'early_close', '1:00 PM ET', '2029-07-03', false, 2029),
('2029-09-03', 'Labor Day', 'full_close', NULL, '2029-09-03', false, 2029),
('2029-11-22', 'Thanksgiving Day', 'full_close', NULL, '2029-11-22', false, 2029),
('2029-11-23', 'Day After Thanksgiving', 'early_close', '1:00 PM ET', '2029-11-23', false, 2029),
('2029-12-25', 'Christmas Day', 'full_close', NULL, '2029-12-25', false, 2029),
('2029-12-24', 'Christmas Eve', 'early_close', '1:00 PM ET', '2029-12-24', false, 2029),
-- 2030
('2030-01-01', 'New Year''s Day', 'full_close', NULL, '2030-01-01', false, 2030),
('2030-01-21', 'Martin Luther King Jr. Day', 'full_close', NULL, '2030-01-21', false, 2030),
('2030-02-18', 'Presidents'' Day', 'full_close', NULL, '2030-02-18', false, 2030),
('2030-04-19', 'Good Friday', 'full_close', NULL, '2030-04-19', false, 2030),
('2030-05-27', 'Memorial Day', 'full_close', NULL, '2030-05-27', false, 2030),
('2030-06-19', 'Juneteenth', 'full_close', NULL, '2030-06-19', false, 2030),
('2030-07-04', 'Independence Day', 'full_close', NULL, '2030-07-04', false, 2030),
('2030-07-03', 'Day Before Independence Day', 'early_close', '1:00 PM ET', '2030-07-03', false, 2030),
('2030-09-02', 'Labor Day', 'full_close', NULL, '2030-09-02', false, 2030),
('2030-11-28', 'Thanksgiving Day', 'full_close', NULL, '2030-11-28', false, 2030),
('2030-11-29', 'Day After Thanksgiving', 'early_close', '1:00 PM ET', '2030-11-29', false, 2030),
('2030-12-25', 'Christmas Day', 'full_close', NULL, '2030-12-25', false, 2030),
('2030-12-24', 'Christmas Eve', 'early_close', '1:00 PM ET', '2030-12-24', false, 2030),
-- 2031-2035
('2031-01-01', 'New Year''s Day', 'full_close', NULL, '2031-01-01', false, 2031),
('2031-01-20', 'Martin Luther King Jr. Day', 'full_close', NULL, '2031-01-20', false, 2031),
('2031-02-17', 'Presidents'' Day', 'full_close', NULL, '2031-02-17', false, 2031),
('2031-04-11', 'Good Friday', 'full_close', NULL, '2031-04-11', false, 2031),
('2031-05-26', 'Memorial Day', 'full_close', NULL, '2031-05-26', false, 2031),
('2031-06-19', 'Juneteenth', 'full_close', NULL, '2031-06-19', false, 2031),
('2031-07-04', 'Independence Day', 'full_close', NULL, '2031-07-04', false, 2031),
('2031-07-03', 'Day Before Independence Day', 'early_close', '1:00 PM ET', '2031-07-03', false, 2031),
('2031-09-01', 'Labor Day', 'full_close', NULL, '2031-09-01', false, 2031),
('2031-11-27', 'Thanksgiving Day', 'full_close', NULL, '2031-11-27', false, 2031),
('2031-11-28', 'Day After Thanksgiving', 'early_close', '1:00 PM ET', '2031-11-28', false, 2031),
('2031-12-25', 'Christmas Day', 'full_close', NULL, '2031-12-25', false, 2031),
('2031-12-24', 'Christmas Eve', 'early_close', '1:00 PM ET', '2031-12-24', false, 2031),
-- 2032
('2032-01-01', 'New Year''s Day', 'full_close', NULL, '2032-01-01', false, 2032),
('2032-01-19', 'Martin Luther King Jr. Day', 'full_close', NULL, '2032-01-19', false, 2032),
('2032-02-16', 'Presidents'' Day', 'full_close', NULL, '2032-02-16', false, 2032),
('2032-03-26', 'Good Friday', 'full_close', NULL, '2032-03-26', false, 2032),
('2032-05-31', 'Memorial Day', 'full_close', NULL, '2032-05-31', false, 2032),
('2032-06-18', 'Juneteenth', 'full_close', NULL, '2032-06-19', true, 2032),
('2032-07-05', 'Independence Day', 'full_close', NULL, '2032-07-04', true, 2032),
('2032-09-06', 'Labor Day', 'full_close', NULL, '2032-09-06', false, 2032),
('2032-11-25', 'Thanksgiving Day', 'full_close', NULL, '2032-11-25', false, 2032),
('2032-11-26', 'Day After Thanksgiving', 'early_close', '1:00 PM ET', '2032-11-26', false, 2032),
('2032-12-24', 'Christmas Day', 'full_close', NULL, '2032-12-25', true, 2032),
-- 2033
('2032-12-31', 'New Year''s Day', 'full_close', NULL, '2033-01-01', true, 2033),
('2033-01-17', 'Martin Luther King Jr. Day', 'full_close', NULL, '2033-01-17', false, 2033),
('2033-02-21', 'Presidents'' Day', 'full_close', NULL, '2033-02-21', false, 2033),
('2033-04-15', 'Good Friday', 'full_close', NULL, '2033-04-15', false, 2033),
('2033-05-30', 'Memorial Day', 'full_close', NULL, '2033-05-30', false, 2033),
('2033-06-20', 'Juneteenth', 'full_close', NULL, '2033-06-19', true, 2033),
('2033-07-04', 'Independence Day', 'full_close', NULL, '2033-07-04', false, 2033),
('2033-09-05', 'Labor Day', 'full_close', NULL, '2033-09-05', false, 2033),
('2033-11-24', 'Thanksgiving Day', 'full_close', NULL, '2033-11-24', false, 2033),
('2033-11-25', 'Day After Thanksgiving', 'early_close', '1:00 PM ET', '2033-11-25', false, 2033),
('2033-12-26', 'Christmas Day', 'full_close', NULL, '2033-12-25', true, 2033),
-- 2034
('2034-01-02', 'New Year''s Day', 'full_close', NULL, '2034-01-01', true, 2034),
('2034-01-16', 'Martin Luther King Jr. Day', 'full_close', NULL, '2034-01-16', false, 2034),
('2034-02-20', 'Presidents'' Day', 'full_close', NULL, '2034-02-20', false, 2034),
('2034-04-07', 'Good Friday', 'full_close', NULL, '2034-04-07', false, 2034),
('2034-05-29', 'Memorial Day', 'full_close', NULL, '2034-05-29', false, 2034),
('2034-06-19', 'Juneteenth', 'full_close', NULL, '2034-06-19', false, 2034),
('2034-07-04', 'Independence Day', 'full_close', NULL, '2034-07-04', false, 2034),
('2034-07-03', 'Day Before Independence Day', 'early_close', '1:00 PM ET', '2034-07-03', false, 2034),
('2034-09-04', 'Labor Day', 'full_close', NULL, '2034-09-04', false, 2034),
('2034-11-23', 'Thanksgiving Day', 'full_close', NULL, '2034-11-23', false, 2034),
('2034-11-24', 'Day After Thanksgiving', 'early_close', '1:00 PM ET', '2034-11-24', false, 2034),
('2034-12-25', 'Christmas Day', 'full_close', NULL, '2034-12-25', false, 2034),
-- 2035
('2035-01-01', 'New Year''s Day', 'full_close', NULL, '2035-01-01', false, 2035),
('2035-01-15', 'Martin Luther King Jr. Day', 'full_close', NULL, '2035-01-15', false, 2035),
('2035-02-19', 'Presidents'' Day', 'full_close', NULL, '2035-02-19', false, 2035),
('2035-03-23', 'Good Friday', 'full_close', NULL, '2035-03-23', false, 2035),
('2035-05-28', 'Memorial Day', 'full_close', NULL, '2035-05-28', false, 2035),
('2035-06-19', 'Juneteenth', 'full_close', NULL, '2035-06-19', false, 2035),
('2035-07-04', 'Independence Day', 'full_close', NULL, '2035-07-04', false, 2035),
('2035-07-03', 'Day Before Independence Day', 'early_close', '1:00 PM ET', '2035-07-03', false, 2035),
('2035-09-03', 'Labor Day', 'full_close', NULL, '2035-09-03', false, 2035),
('2035-11-22', 'Thanksgiving Day', 'full_close', NULL, '2035-11-22', false, 2035),
('2035-11-23', 'Day After Thanksgiving', 'early_close', '1:00 PM ET', '2035-11-23', false, 2035),
('2035-12-25', 'Christmas Day', 'full_close', NULL, '2035-12-25', false, 2035),
('2035-12-24', 'Christmas Eve', 'early_close', '1:00 PM ET', '2035-12-24', false, 2035);

-- =====================================================
-- RLS POLICIES
-- =====================================================

ALTER TABLE us_market_holidays ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Anyone can read holidays" ON us_market_holidays;
CREATE POLICY "Anyone can read holidays" ON us_market_holidays
  FOR SELECT USING (true);

DROP POLICY IF EXISTS "Service role can modify holidays" ON us_market_holidays;
CREATE POLICY "Service role can modify holidays" ON us_market_holidays
  FOR ALL USING (auth.role() = 'service_role');

-- =====================================================
-- GRANTS
-- =====================================================

GRANT SELECT ON us_market_holidays TO authenticated;
GRANT SELECT ON us_market_holidays TO anon;
GRANT ALL ON us_market_holidays TO service_role;

GRANT SELECT ON upcoming_holidays TO authenticated;
GRANT SELECT ON upcoming_holidays TO anon;
GRANT SELECT ON current_year_holidays TO authenticated;
GRANT SELECT ON current_year_holidays TO anon;

GRANT EXECUTE ON FUNCTION is_market_holiday(DATE) TO authenticated;
GRANT EXECUTE ON FUNCTION is_market_holiday(DATE) TO service_role;
GRANT EXECUTE ON FUNCTION get_next_trading_day(DATE) TO authenticated;
GRANT EXECUTE ON FUNCTION get_next_trading_day(DATE) TO service_role;
GRANT EXECUTE ON FUNCTION should_generate_daily_report(DATE) TO authenticated;
GRANT EXECUTE ON FUNCTION should_generate_daily_report(DATE) TO service_role;
GRANT EXECUTE ON FUNCTION get_week_holidays(DATE) TO authenticated;
GRANT EXECUTE ON FUNCTION get_week_holidays(DATE) TO service_role;

-- =====================================================
-- VERIFICATION
-- =====================================================
DO $$
DECLARE
  v_count INTEGER;
BEGIN
  SELECT COUNT(*) INTO v_count FROM us_market_holidays;
  
  RAISE NOTICE '';
  RAISE NOTICE '=====================================================';
  RAISE NOTICE 'âœ… US MARKET HOLIDAYS MIGRATION COMPLETE';
  RAISE NOTICE '=====================================================';
  RAISE NOTICE 'Total holidays inserted: %', v_count;
  RAISE NOTICE '';
  RAISE NOTICE 'Functions available:';
  RAISE NOTICE '  â€¢ is_market_holiday(date)';
  RAISE NOTICE '  â€¢ get_next_trading_day(date)';
  RAISE NOTICE '  â€¢ should_generate_daily_report(date)';
  RAISE NOTICE '  â€¢ get_week_holidays(date)';
  RAISE NOTICE '';
  RAISE NOTICE 'Views available:';
  RAISE NOTICE '  â€¢ upcoming_holidays';
  RAISE NOTICE '  â€¢ current_year_holidays';
  RAISE NOTICE '=====================================================';
END $$;

-- Quick verification
SELECT * FROM should_generate_daily_report(CURRENT_DATE);
SELECT * FROM upcoming_holidays LIMIT 5;
-- =====================================================
-- END OF FINOTAUR DATABASE SCHEMA
-- =====================================================